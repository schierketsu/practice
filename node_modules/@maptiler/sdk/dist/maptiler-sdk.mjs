var mi = Object.defineProperty;
var Pn = (r) => {
  throw TypeError(r);
};
var yi = (r, e, t) => e in r ? mi(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var g = (r, e, t) => yi(r, typeof e != "symbol" ? e + "" : e, t), gr = (r, e, t) => e.has(r) || Pn("Cannot " + t);
var L = (r, e, t) => (gr(r, e, "read from private field"), t ? t.call(r) : e.get(r)), Y = (r, e, t) => e.has(r) ? Pn("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(r) : e.set(r, t), J = (r, e, t, n) => (gr(r, e, "write to private field"), n ? n.call(r, t) : e.set(r, t), t), Q = (r, e, t) => (gr(r, e, "access private method"), t);
import k from "maplibre-gl";
import { Base64 as gi } from "js-base64";
import vi from "events";
import { Language as bi, getLanguageInfoFromCode as Rn, config as vr, MapStyle as ft, mapStylePresetList as br, expandMapStyle as wi, MapStyleVariant as Si, ReferenceMapStyle as xi, toLanguageInfo as zn, getLanguageInfoFromFlag as ki, geolocation as On } from "@maptiler/client";
import { MapStyle as Sf, MapStyleVariant as xf, ReferenceMapStyle as kf, ServiceError as Lf, areSameLanguages as Cf, bufferToPixelDataBrowser as Ef, canParsePixelData as Af, circumferenceAtLatitude as Tf, coordinates as _f, data as If, elevation as Mf, expandMapStyle as Pf, geocoding as Rf, geolocation as zf, getAutoLanguage as Of, getBufferToPixelDataParser as Ff, getLanguageInfoFromCode as $f, getLanguageInfoFromFlag as Nf, getLanguageInfoFromKey as jf, getTileCache as Df, isLanguageInfo as Uf, mapStylePresetList as Bf, math as qf, misc as Vf, staticMaps as Gf, styleToStyle as Hf, toLanguageInfo as Zf } from "@maptiler/client";
import { v4 as Li } from "uuid";
let Ci = class extends k.Marker {
  addTo(e) {
    return super.addTo(e);
  }
};
class Jc extends k.Popup {
  addTo(e) {
    return super.addTo(e);
  }
}
class Qc extends k.Style {
  constructor(e, t = {}) {
    super(e, t);
  }
}
class ep extends k.CanvasSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class tp extends k.GeoJSONSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class rp extends k.ImageSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class np extends k.RasterTileSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class ap extends k.RasterDEMTileSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class op extends k.VectorTileSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class ip extends k.VideoSource {
  onAdd(e) {
    super.onAdd(e);
  }
}
class Na extends k.NavigationControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class Ei extends k.GeolocateControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class sp extends k.AttributionControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class Ai extends k.LogoControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class Ti extends k.ScaleControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class _i extends k.FullscreenControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class lp extends k.TerrainControl {
  onAdd(e) {
    return super.onAdd(e);
  }
}
class up extends k.BoxZoomHandler {
  constructor(e, t) {
    super(e, t);
  }
}
class cp extends k.ScrollZoomHandler {
  constructor(e, t) {
    super(e, t);
  }
}
class pp extends k.CooperativeGesturesHandler {
  constructor(e, t) {
    super(e, t);
  }
}
class fp extends k.KeyboardHandler {
  constructor(e) {
    super(e);
  }
}
class dp extends k.TwoFingersTouchPitchHandler {
  constructor(e) {
    super(e);
  }
}
class hp extends k.MapWheelEvent {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
class mp extends k.MapTouchEvent {
  constructor(e, t, n) {
    super(e, t, n);
  }
}
class yp extends k.MapMouseEvent {
  constructor(e, t, n, a = {}) {
    super(e, t, n, a);
  }
}
const z = {
  /**
   * Language mode to display labels in both the local language and the language of the visitor's device, concatenated.
   * Note that if those two languages are the same, labels won't be duplicated.
   */
  VISITOR: {
    code: null,
    flag: "visitor",
    name: "Visitor",
    latin: !0,
    isMode: !0,
    geocoding: !1
  },
  /**
   * Language mode to display labels in both the local language and English, concatenated.
   * Note that if those two languages are the same, labels won't be duplicated.
   */
  VISITOR_ENGLISH: {
    code: null,
    flag: "visitor_en",
    name: "Visitor English",
    latin: !0,
    isMode: !0,
    geocoding: !1
  },
  /**
   * Language mode to display labels in a language enforced in the style.
   */
  STYLE: {
    code: null,
    flag: "style",
    name: "Style",
    latin: !1,
    isMode: !0,
    geocoding: !1
  },
  /**
   * Language mode to display labels in a language enforced in the style. The language cannot be further modified.
   */
  STYLE_LOCK: {
    code: null,
    flag: "style_lock",
    name: "Style Lock",
    latin: !1,
    isMode: !0,
    geocoding: !1
  },
  ...bi
};
function Fn() {
  if (typeof navigator > "u") {
    const e = Intl.DateTimeFormat().resolvedOptions().locale.split("-")[0], t = Rn(e);
    return t || z.ENGLISH;
  }
  return Array.from(new Set(navigator.languages.map((e) => e.split("-")[0]))).map((e) => Rn(e)).filter((e) => e)[0] ?? z.LOCAL;
}
const W = {
  maptilerLogoURL: "https://api.maptiler.com/resources/logo.svg",
  maptilerURL: "https://www.maptiler.com/",
  maptilerApiHost: "api.maptiler.com",
  telemetryURL: "https://api.maptiler.com/metrics",
  rtlPluginURL: "https://cdn.maptiler.com/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.min.js",
  primaryLanguage: z.STYLE,
  secondaryLanguage: z.LOCAL,
  terrainSourceURL: "https://api.maptiler.com/tiles/terrain-rgb-v2/tiles.json",
  terrainSourceId: "maptiler-terrain"
};
Object.freeze(W);
const on = Li();
class Ii extends vi {
  constructor() {
    super(...arguments);
    /**
     * The primary language. By default, the language of the web browser is used.
     */
    g(this, "primaryLanguage", W.primaryLanguage);
    /**
     * The secondary language, to overwrite the default language defined in the map style.
     * This settings is highly dependant on the style compatibility and may not work in most cases.
     */
    g(this, "secondaryLanguage");
    /**
     * Setting on whether of not the SDK runs with a session logic.
     * A "session" is started at the initialization of the SDK and finished when the browser
     * page is being refreshed.
     * When `session` is enabled (default: true), the extra URL param `mtsid` is added to queries
     * on the MapTiler Cloud API. This allows MapTiler to enable "session based billing".
     */
    g(this, "session", !0);
    /**
     * Enables client-side caching of requests for tiles and fonts.
     * The cached requests persist multiple browser sessions and will be reused when possible.
     * Works only for requests to the MapTiler Cloud API when sessions are enabled.
     */
    g(this, "caching", !0);
    /**
     * Telemetry is enabled by default but can be opted-out by setting this value to `false`.
     * The telemetry is very valuable to the team at MapTiler because it shares information
     * about where to add the extra effort. It also helps spotting some incompatibility issues
     * that may arise between the SDK and a specific version of a module.
     *
     * It consists in sending metrics about usage of the following features:
     * - SDK version [string]
     * - API key [string]
     * - MapTiler sesion ID (if opted-in) [string]
     * - if tile caching is enabled [boolean]
     * - if language specified at initialization [boolean]
     * - if terrain is activated at initialization [boolean]
     * - if globe projection is activated at initialization [boolean]
     *
     * In addition, each official module will be added to a list, alongside its version number.
     */
    g(this, "telemetry", !0);
    /**
     * Unit to be used
     */
    g(this, "_unit", "metric");
    /**
     * MapTiler Cloud API key
     */
    g(this, "_apiKey", "");
  }
  /**
   * Set the unit system
   */
  set unit(t) {
    this._unit = t, this.emit("unit", t);
  }
  /**
   * Get the unit system
   */
  get unit() {
    return this._unit;
  }
  /**
   * Set the MapTiler Cloud API key
   */
  set apiKey(t) {
    this._apiKey = t, vr.apiKey = t, this.emit("apiKey", t);
  }
  /**
   * Get the MapTiler Cloud API key
   */
  get apiKey() {
    return this._apiKey;
  }
  /**
   * Set a the custom fetch function to replace the default one
   */
  set fetch(t) {
    vr.fetch = t;
  }
  /**
   * Get the fetch fucntion
   */
  get fetch() {
    return vr.fetch;
  }
}
const j = new Ii();
class $n extends Ai {
  constructor(t = {}) {
    super(t);
    g(this, "logoURL", "");
    g(this, "linkURL", "");
    this.logoURL = t.logoURL ?? W.maptilerLogoURL, this.linkURL = t.linkURL ?? W.maptilerURL;
  }
  onAdd(t) {
    this._map = t, this._compact = this.options.compact ?? !1, this._container = window.document.createElement("div"), this._container.className = "maplibregl-ctrl";
    const n = window.document.createElement("a");
    return n.style.backgroundRepeat = "no-repeat", n.style.cursor = "pointer", n.style.display = "block", n.style.height = "23px", n.style.margin = "0 0 -4px -4px", n.style.overflow = "hidden", n.style.width = "88px", n.style.backgroundImage = `url(${this.logoURL})`, n.style.backgroundSize = "100px 30px", n.style.width = "100px", n.style.height = "30px", n.target = "_blank", n.rel = "noopener", n.href = this.linkURL, n.setAttribute("aria-label", "MapTiler logo"), n.setAttribute("rel", "noopener"), this._container.appendChild(n), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
  }
}
const $r = "localcache_source", Nr = "localcache", Mi = "maptiler_sdk", Pi = 1e3, Ri = 100, jr = typeof caches < "u", { addProtocol: Nn } = k;
function zi(r, e) {
  if (jr && j.caching && j.session && r.host === W.maptilerApiHost) {
    if (e === "Source" && r.href.includes("tiles.json"))
      return r.href.replace("https://", `${$r}://`);
    if (e === "Tile" || e === "Glyphs")
      return r.href.replace("https://", `${Nr}://`);
  }
  return r.href;
}
let wr;
async function ja() {
  return wr || (wr = await caches.open(Mi)), wr;
}
let jn = 0;
async function Oi() {
  const r = await ja(), e = await r.keys(), t = e.slice(0, Math.max(e.length - Pi, 0));
  for (const n of t)
    r.delete(n);
}
function Fi() {
  Nn(
    $r,
    async (r, e) => {
      if (!r.url) throw new Error("");
      r.url = r.url.replace(`${$r}://`, "https://");
      const t = r;
      t.signal = e.signal;
      const n = await fetch(r.url, t), a = await n.json();
      return a.tiles && a.tiles.length > 0 && (a.tiles[0] += `&last-modified=${n.headers.get("Last-Modified")}`), {
        data: a,
        cacheControl: n.headers.get("Cache-Control"),
        expires: n.headers.get("Expires")
      };
    }
  ), Nn(Nr, async (r, e) => {
    if (!r.url) throw new Error("");
    r.url = r.url.replace(`${Nr}://`, "https://");
    const t = new URL(r.url), n = new URL(t);
    n.searchParams.delete("mtsid"), n.searchParams.delete("key");
    const a = n.toString(), o = new URL(t);
    o.searchParams.delete("last-modified");
    const i = o.toString(), s = async (d) => ({
      data: await d.arrayBuffer(),
      cacheControl: d.headers.get("Cache-Control"),
      expires: d.headers.get("Expires")
    }), l = await ja(), u = await l.match(a);
    if (u)
      return s(u);
    const c = r;
    c.signal = e.signal;
    const p = await fetch(i, c);
    return p.status >= 200 && p.status < 300 && (l.put(a, p.clone()).catch(() => {
    }), ++jn > Ri && (Oi(), jn = 0)), s(p);
  });
}
async function $i(r) {
  if (typeof window > "u") return;
  const e = k.getRTLTextPluginStatus();
  if (e === "unavailable" || e === "requested")
    try {
      await k.setRTLTextPlugin(r ?? W.rtlPluginURL, !0);
    } catch (t) {
      console.error("Error enabling RTL plugin. It is enabled by default and cannot be unset after. Are you attempting to enable it twice?", t);
    }
}
function Ni(r, e) {
  for (const t of r)
    typeof e[t] == "function" && (e[t] = e[t].bind(e));
}
function Dn(r, e) {
  let t = null;
  try {
    t = new URL(r);
  } catch {
    return {
      url: r
    };
  }
  return t.host === W.maptilerApiHost && (t.searchParams.has("key") || t.searchParams.append("key", j.apiKey), j.session && t.searchParams.append("mtsid", on)), {
    url: zi(t, e)
  };
}
function Un(r) {
  return (e, t) => {
    if (r != null) {
      const n = r(e, t), a = Dn((n == null ? void 0 : n.url) ?? "", t);
      return {
        ...n,
        ...a
      };
    }
    return Dn(e, t);
  };
}
function Da() {
  return Math.random().toString(36).substring(2);
}
function Qt(r) {
  return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/gi.test(r);
}
function ji(r) {
  try {
    return JSON.parse(r);
  } catch {
  }
  return null;
}
function Di() {
  return document.createElement("canvas").getContext("webgl2") ? null : typeof WebGL2RenderingContext < "u" ? "Graphic rendering with WebGL2 has been disabled or is not supported by your graphic card. The map cannot be displayed." : "Your browser does not support graphic rendering with WebGL2. The map cannot be displayed.";
}
function Ui(r) {
  const e = Di();
  if (!e) return;
  let t = null;
  if (typeof r == "string" ? t = document.getElementById(r) : r instanceof HTMLElement && (t = r), !t)
    throw new Error("The Map container must be provided.");
  const n = document.createElement("div");
  throw n.innerHTML = e, n.classList.add("webgl-warning-div"), t.appendChild(n), new Error(e);
}
function gp(r) {
  const e = "The WebGL context was lost.", t = r.getContainer(), n = document.createElement("div");
  n.innerHTML = e, n.classList.add("webgl-warning-div"), t.appendChild(n);
}
function Bn(r, e) {
  return !(!Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" || e && !r[1].startsWith("name:") || !e && r[1] !== "name");
}
function Bi(r, e, t) {
  const n = structuredClone(r), a = (o) => {
    if (typeof o != "string")
      for (let i = 0; i < o.length; i += 1)
        Bn(o[i], t) ? o[i] = structuredClone(e) : a(o[i]);
  };
  return Bn(n, t) ? e : (a(n), n);
}
function qi(r, e) {
  const t = e ? /\{name:\S+\}/ : /\{name\}/;
  return {
    contains: t.test(r),
    exactMatch: new RegExp(`^${t.source}$`).test(r)
  };
}
function Vi(r, e, t) {
  const n = t ? /\{name:\S+\}/ : /\{name\}/, a = r.split(n);
  return ["concat", ...a.flatMap((s, l) => l === a.length - 1 ? [s] : [s, e])];
}
function Gi(r) {
  var n;
  const e = /\{name(?::(?<language>\S+))?\}/g, t = [];
  for (; ; ) {
    const a = e.exec(r);
    if (!a) break;
    const o = ((n = a.groups) == null ? void 0 : n.language) ?? null;
    t.push(o);
  }
  return t;
}
function Hi(r) {
  return !Array.isArray(r) || r.length !== 2 || r[0] !== "get" || typeof r[1] != "string" ? null : r[1].trim() === "name" ? {
    isLanguage: !0,
    localization: null
  } : r[1].trim().startsWith("name:") ? {
    isLanguage: !0,
    localization: r[1].trim().split(":").pop()
  } : null;
}
function Zi(r) {
  const e = [], t = structuredClone(r), n = (a) => {
    if (typeof a != "string")
      for (let o = 0; o < a.length; o += 1) {
        const i = Hi(a[o]);
        i ? e.push(i.localization) : n(a[o]);
      }
  };
  return n([t]), e;
}
function Ki(r, e) {
  const t = [];
  for (const o of r) {
    if (o.type !== "symbol")
      continue;
    const i = o, { id: s, layout: l } = i;
    if (!l || !("text-field" in l))
      continue;
    const u = e.getLayoutProperty(s, "text-field");
    if (u)
      if (typeof u == "string") {
        const c = Gi(u);
        t.push(c);
      } else {
        const c = Zi(u);
        t.push(c);
      }
  }
  const n = t.flat(), a = {
    unlocalized: 0,
    localized: {}
  };
  for (const o of n)
    o === null ? a.unlocalized += 1 : (o in a.localized || (a.localized[o] = 0), a.localized[o] += 1);
  return a;
}
var Xi = 8, Yi = {
  version: {
    required: !0,
    type: "enum",
    values: [
      8
    ]
  },
  name: {
    type: "string"
  },
  metadata: {
    type: "*"
  },
  center: {
    type: "array",
    value: "number"
  },
  centerAltitude: {
    type: "number"
  },
  zoom: {
    type: "number"
  },
  bearing: {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees"
  },
  pitch: {
    type: "number",
    default: 0,
    units: "degrees"
  },
  roll: {
    type: "number",
    default: 0,
    units: "degrees"
  },
  state: {
    type: "state",
    default: {}
  },
  light: {
    type: "light"
  },
  sky: {
    type: "sky"
  },
  projection: {
    type: "projection"
  },
  terrain: {
    type: "terrain"
  },
  sources: {
    required: !0,
    type: "sources"
  },
  sprite: {
    type: "sprite"
  },
  glyphs: {
    type: "string"
  },
  "font-faces": {
    type: "array",
    value: "fontFaces"
  },
  transition: {
    type: "transition"
  },
  layers: {
    required: !0,
    type: "array",
    value: "layer"
  }
}, Wi = {
  "*": {
    type: "source"
  }
}, Ji = [
  "source_vector",
  "source_raster",
  "source_raster_dem",
  "source_geojson",
  "source_video",
  "source_image"
], Qi = {
  type: {
    required: !0,
    type: "enum",
    values: {
      vector: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    default: "xyz"
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  attribution: {
    type: "string"
  },
  promoteId: {
    type: "promoteId"
  },
  volatile: {
    type: "boolean",
    default: !1
  },
  encoding: {
    type: "enum",
    values: {
      mvt: {},
      mlt: {}
    },
    default: "mvt"
  },
  "*": {
    type: "*"
  }
}, es = {
  type: {
    required: !0,
    type: "enum",
    values: {
      raster: {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels"
  },
  scheme: {
    type: "enum",
    values: {
      xyz: {},
      tms: {}
    },
    default: "xyz"
  },
  attribution: {
    type: "string"
  },
  volatile: {
    type: "boolean",
    default: !1
  },
  "*": {
    type: "*"
  }
}, ts = {
  type: {
    required: !0,
    type: "enum",
    values: {
      "raster-dem": {}
    }
  },
  url: {
    type: "string"
  },
  tiles: {
    type: "array",
    value: "string"
  },
  bounds: {
    type: "array",
    value: "number",
    length: 4,
    default: [
      -180,
      -85.051129,
      180,
      85.051129
    ]
  },
  minzoom: {
    type: "number",
    default: 0
  },
  maxzoom: {
    type: "number",
    default: 22
  },
  tileSize: {
    type: "number",
    default: 512,
    units: "pixels"
  },
  attribution: {
    type: "string"
  },
  encoding: {
    type: "enum",
    values: {
      terrarium: {},
      mapbox: {},
      custom: {}
    },
    default: "mapbox"
  },
  redFactor: {
    type: "number",
    default: 1
  },
  blueFactor: {
    type: "number",
    default: 1
  },
  greenFactor: {
    type: "number",
    default: 1
  },
  baseShift: {
    type: "number",
    default: 0
  },
  volatile: {
    type: "boolean",
    default: !1
  },
  "*": {
    type: "*"
  }
}, rs = {
  type: {
    required: !0,
    type: "enum",
    values: {
      geojson: {}
    }
  },
  data: {
    required: !0,
    type: "*"
  },
  maxzoom: {
    type: "number",
    default: 18
  },
  attribution: {
    type: "string"
  },
  buffer: {
    type: "number",
    default: 128,
    maximum: 512,
    minimum: 0
  },
  filter: {
    type: "*"
  },
  tolerance: {
    type: "number",
    default: 0.375
  },
  cluster: {
    type: "boolean",
    default: !1
  },
  clusterRadius: {
    type: "number",
    default: 50,
    minimum: 0
  },
  clusterMaxZoom: {
    type: "number"
  },
  clusterMinPoints: {
    type: "number"
  },
  clusterProperties: {
    type: "*"
  },
  lineMetrics: {
    type: "boolean",
    default: !1
  },
  generateId: {
    type: "boolean",
    default: !1
  },
  promoteId: {
    type: "promoteId"
  }
}, ns = {
  type: {
    required: !0,
    type: "enum",
    values: {
      video: {}
    }
  },
  urls: {
    required: !0,
    type: "array",
    value: "string"
  },
  coordinates: {
    required: !0,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
}, as = {
  type: {
    required: !0,
    type: "enum",
    values: {
      image: {}
    }
  },
  url: {
    required: !0,
    type: "string"
  },
  coordinates: {
    required: !0,
    type: "array",
    length: 4,
    value: {
      type: "array",
      length: 2,
      value: "number"
    }
  }
}, os = {
  id: {
    type: "string",
    required: !0
  },
  type: {
    type: "enum",
    values: {
      fill: {},
      line: {},
      symbol: {},
      circle: {},
      heatmap: {},
      "fill-extrusion": {},
      raster: {},
      hillshade: {},
      "color-relief": {},
      background: {}
    },
    required: !0
  },
  metadata: {
    type: "*"
  },
  source: {
    type: "string"
  },
  "source-layer": {
    type: "string"
  },
  minzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  maxzoom: {
    type: "number",
    minimum: 0,
    maximum: 24
  },
  filter: {
    type: "filter"
  },
  layout: {
    type: "layout"
  },
  paint: {
    type: "paint"
  }
}, is = [
  "layout_fill",
  "layout_line",
  "layout_circle",
  "layout_heatmap",
  "layout_fill-extrusion",
  "layout_symbol",
  "layout_raster",
  "layout_hillshade",
  "layout_color-relief",
  "layout_background"
], ss = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, ls = {
  "fill-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, us = {
  "circle-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, cs = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, ps = {
  "line-cap": {
    type: "enum",
    values: {
      butt: {},
      round: {},
      square: {}
    },
    default: "butt",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-join": {
    type: "enum",
    values: {
      bevel: {},
      round: {},
      miter: {}
    },
    default: "miter",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "line-miter-limit": {
    type: "number",
    default: 2,
    requires: [
      {
        "line-join": "miter"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-round-limit": {
    type: "number",
    default: 1.05,
    requires: [
      {
        "line-join": "round"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, fs = {
  "symbol-placement": {
    type: "enum",
    values: {
      point: {},
      line: {},
      "line-center": {}
    },
    default: "point",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-spacing": {
    type: "number",
    default: 250,
    minimum: 1,
    units: "pixels",
    requires: [
      {
        "symbol-placement": "line"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-avoid-edges": {
    type: "boolean",
    default: !1,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "symbol-sort-key": {
    type: "number",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "symbol-z-order": {
    type: "enum",
    values: {
      auto: {},
      "viewport-y": {},
      source: {}
    },
    default: "auto",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-allow-overlap": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image",
      {
        "!": "icon-overlap"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-ignore-placement": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-optional": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-size": {
    type: "number",
    default: 1,
    minimum: 0,
    units: "factor of the original icon size",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-text-fit": {
    type: "enum",
    values: {
      none: {},
      width: {},
      height: {},
      both: {}
    },
    default: "none",
    requires: [
      "icon-image",
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-text-fit-padding": {
    type: "array",
    value: "number",
    length: 4,
    default: [
      0,
      0,
      0,
      0
    ],
    units: "pixels",
    requires: [
      "icon-image",
      "text-field",
      {
        "icon-text-fit": [
          "both",
          "width",
          "height"
        ]
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-image": {
    type: "resolvedImage",
    tokens: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-padding": {
    type: "padding",
    default: [
      2
    ],
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-keep-upright": {
    type: "boolean",
    default: !1,
    requires: [
      "icon-image",
      {
        "icon-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-offset": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    default: "center",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      auto: {}
    },
    default: "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotation-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {},
      "viewport-glyph": {},
      auto: {}
    },
    default: "auto",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-field": {
    type: "formatted",
    default: "",
    tokens: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-font": {
    type: "array",
    value: "string",
    default: [
      "Open Sans Regular",
      "Arial Unicode MS Regular"
    ],
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-size": {
    type: "number",
    default: 16,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-width": {
    type: "number",
    default: 10,
    minimum: 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-line-height": {
    type: "number",
    default: 1.2,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-letter-spacing": {
    type: "number",
    default: 0,
    units: "ems",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-justify": {
    type: "enum",
    values: {
      auto: {},
      left: {},
      center: {},
      right: {}
    },
    default: "center",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-radial-offset": {
    type: "number",
    units: "ems",
    default: 0,
    requires: [
      "text-field"
    ],
    "property-type": "data-driven",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    }
  },
  "text-variable-anchor": {
    type: "array",
    value: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-variable-anchor-offset": {
    type: "variableAnchorOffsetCollection",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-anchor": {
    type: "enum",
    values: {
      center: {},
      left: {},
      right: {},
      top: {},
      bottom: {},
      "top-left": {},
      "top-right": {},
      "bottom-left": {},
      "bottom-right": {}
    },
    default: "center",
    requires: [
      "text-field",
      {
        "!": "text-variable-anchor"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-max-angle": {
    type: "number",
    default: 45,
    units: "degrees",
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-writing-mode": {
    type: "array",
    value: "enum",
    values: {
      horizontal: {},
      vertical: {}
    },
    requires: [
      "text-field",
      {
        "symbol-placement": [
          "point"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-rotate": {
    type: "number",
    default: 0,
    period: 360,
    units: "degrees",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-padding": {
    type: "number",
    default: 2,
    minimum: 0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-keep-upright": {
    type: "boolean",
    default: !0,
    requires: [
      "text-field",
      {
        "text-rotation-alignment": "map"
      },
      {
        "symbol-placement": [
          "line",
          "line-center"
        ]
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-transform": {
    type: "enum",
    values: {
      none: {},
      uppercase: {},
      lowercase: {}
    },
    default: "none",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-offset": {
    type: "array",
    value: "number",
    units: "ems",
    length: 2,
    default: [
      0,
      0
    ],
    requires: [
      "text-field",
      {
        "!": "text-radial-offset"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "data-driven"
  },
  "text-allow-overlap": {
    type: "boolean",
    default: !1,
    requires: [
      "text-field",
      {
        "!": "text-overlap"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-overlap": {
    type: "enum",
    values: {
      never: {},
      always: {},
      cooperative: {}
    },
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-ignore-placement": {
    type: "boolean",
    default: !1,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-optional": {
    type: "boolean",
    default: !1,
    requires: [
      "text-field",
      "icon-image"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, ds = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, hs = {
  visibility: {
    type: "enum",
    values: {
      visible: {},
      none: {}
    },
    default: "visible",
    "property-type": "constant"
  }
}, ms = {
  type: "array",
  value: "*"
}, ys = {
  type: "enum",
  values: {
    "==": {},
    "!=": {},
    ">": {},
    ">=": {},
    "<": {},
    "<=": {},
    in: {},
    "!in": {},
    all: {},
    any: {},
    none: {},
    has: {},
    "!has": {}
  }
}, gs = {
  type: "enum",
  values: {
    Point: {},
    LineString: {},
    Polygon: {}
  }
}, vs = {
  type: "array",
  minimum: 0,
  maximum: 24,
  value: [
    "number",
    "color"
  ],
  length: 2
}, bs = {
  type: "array",
  value: "*",
  minimum: 1
}, ws = {
  anchor: {
    type: "enum",
    default: "viewport",
    values: {
      map: {},
      viewport: {}
    },
    "property-type": "data-constant",
    transition: !1,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    }
  },
  position: {
    type: "array",
    default: [
      1.15,
      210,
      30
    ],
    length: 3,
    value: "number",
    "property-type": "data-constant",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    }
  },
  color: {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  intensity: {
    type: "number",
    "property-type": "data-constant",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  }
}, Ss = {
  "sky-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#88C6FC",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "horizon-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "fog-color": {
    type: "color",
    "property-type": "data-constant",
    default: "#ffffff",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "fog-ground-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "horizon-fog-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "sky-horizon-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  },
  "atmosphere-blend": {
    type: "number",
    "property-type": "data-constant",
    default: 0.8,
    minimum: 0,
    maximum: 1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    transition: !0
  }
}, xs = {
  source: {
    type: "string",
    required: !0
  },
  exaggeration: {
    type: "number",
    minimum: 0,
    default: 1
  }
}, ks = {
  type: {
    type: "projectionDefinition",
    default: "mercator",
    "property-type": "data-constant",
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    }
  }
}, Ls = [
  "paint_fill",
  "paint_line",
  "paint_circle",
  "paint_heatmap",
  "paint_fill-extrusion",
  "paint_symbol",
  "paint_raster",
  "paint_hillshade",
  "paint_color-relief",
  "paint_background"
], Cs = {
  "fill-antialias": {
    type: "boolean",
    default: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      {
        "!": "fill-pattern"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-outline-color": {
    type: "color",
    transition: !0,
    requires: [
      {
        "!": "fill-pattern"
      },
      {
        "fill-antialias": !0
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "fill-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "fill-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "fill-pattern": {
    type: "resolvedImage",
    transition: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  }
}, Es = {
  "line-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "line-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "line-width": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-gap-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-offset": {
    type: "number",
    default: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "line-dasharray": {
    type: "array",
    value: "number",
    minimum: 0,
    transition: !0,
    units: "line widths",
    requires: [
      {
        "!": "line-pattern"
      }
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  },
  "line-pattern": {
    type: "resolvedImage",
    transition: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom",
        "feature"
      ]
    },
    "property-type": "cross-faded-data-driven"
  },
  "line-gradient": {
    type: "color",
    transition: !1,
    requires: [
      {
        "!": "line-dasharray"
      },
      {
        "!": "line-pattern"
      },
      {
        source: "geojson",
        has: {
          lineMetrics: !0
        }
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "line-progress"
      ]
    },
    "property-type": "color-ramp"
  }
}, As = {
  "circle-radius": {
    type: "number",
    default: 5,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-blur": {
    type: "number",
    default: 0,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "circle-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-scale": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-pitch-alignment": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "viewport",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "circle-stroke-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "circle-stroke-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  }
}, Ts = {
  "heatmap-radius": {
    type: "number",
    default: 30,
    minimum: 1,
    transition: !0,
    units: "pixels",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-weight": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "heatmap-intensity": {
    type: "number",
    default: 1,
    minimum: 0,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "heatmap-color": {
    type: "color",
    default: [
      "interpolate",
      [
        "linear"
      ],
      [
        "heatmap-density"
      ],
      0,
      "rgba(0, 0, 255, 0)",
      0.1,
      "royalblue",
      0.3,
      "cyan",
      0.5,
      "lime",
      0.7,
      "yellow",
      1,
      "red"
    ],
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "heatmap-density"
      ]
    },
    "property-type": "color-ramp"
  },
  "heatmap-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, _s = {
  "icon-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: !0,
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "icon-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    requires: [
      "icon-image"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "icon-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "icon-image",
      "icon-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    overridable: !0,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-color": {
    type: "color",
    default: "rgba(0, 0, 0, 0)",
    transition: !0,
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-width": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-halo-blur": {
    type: "number",
    default: 0,
    minimum: 0,
    transition: !0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom",
        "feature",
        "feature-state"
      ]
    },
    "property-type": "data-driven"
  },
  "text-translate": {
    type: "array",
    value: "number",
    length: 2,
    default: [
      0,
      0
    ],
    transition: !0,
    units: "pixels",
    requires: [
      "text-field"
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "text-translate-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "map",
    requires: [
      "text-field",
      "text-translate"
    ],
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, Is = {
  "raster-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-hue-rotate": {
    type: "number",
    default: 0,
    period: 360,
    transition: !0,
    units: "degrees",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-min": {
    type: "number",
    default: 0,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-brightness-max": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-saturation": {
    type: "number",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-contrast": {
    type: "number",
    default: 0,
    minimum: -1,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-resampling": {
    type: "enum",
    values: {
      linear: {},
      nearest: {}
    },
    default: "linear",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "raster-fade-duration": {
    type: "number",
    default: 300,
    minimum: 0,
    transition: !1,
    units: "milliseconds",
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, Ms = {
  "hillshade-illumination-direction": {
    type: "numberArray",
    default: 335,
    minimum: 0,
    maximum: 359,
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-altitude": {
    type: "numberArray",
    default: 45,
    minimum: 0,
    maximum: 90,
    transition: !1,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-illumination-anchor": {
    type: "enum",
    values: {
      map: {},
      viewport: {}
    },
    default: "viewport",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-exaggeration": {
    type: "number",
    default: 0.5,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-shadow-color": {
    type: "colorArray",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-highlight-color": {
    type: "colorArray",
    default: "#FFFFFF",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-accent-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "hillshade-method": {
    type: "enum",
    values: {
      standard: {},
      basic: {},
      combined: {},
      igor: {},
      multidirectional: {}
    },
    default: "standard",
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, Ps = {
  "background-color": {
    type: "color",
    default: "#000000",
    transition: !0,
    requires: [
      {
        "!": "background-pattern"
      }
    ],
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  },
  "background-pattern": {
    type: "resolvedImage",
    transition: !0,
    expression: {
      interpolated: !1,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "cross-faded"
  },
  "background-opacity": {
    type: "number",
    default: 1,
    minimum: 0,
    maximum: 1,
    transition: !0,
    expression: {
      interpolated: !0,
      parameters: [
        "zoom"
      ]
    },
    "property-type": "data-constant"
  }
}, Rs = {
  duration: {
    type: "number",
    default: 300,
    minimum: 0,
    units: "milliseconds"
  },
  delay: {
    type: "number",
    default: 0,
    minimum: 0,
    units: "milliseconds"
  }
}, zs = {
  "*": {
    type: "string"
  }
}, Os = {
  $version: Xi,
  $root: Yi,
  sources: Wi,
  source: Ji,
  source_vector: Qi,
  source_raster: es,
  source_raster_dem: ts,
  source_geojson: rs,
  source_video: ns,
  source_image: as,
  layer: os,
  layout: is,
  layout_background: ss,
  layout_fill: ls,
  layout_circle: us,
  layout_heatmap: cs,
  "layout_fill-extrusion": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  },
  layout_line: ps,
  layout_symbol: fs,
  layout_raster: ds,
  layout_hillshade: hs,
  "layout_color-relief": {
    visibility: {
      type: "enum",
      values: {
        visible: {},
        none: {}
      },
      default: "visible",
      "property-type": "constant"
    }
  },
  filter: ms,
  filter_operator: ys,
  geometry_type: gs,
  function: {
    expression: {
      type: "expression"
    },
    stops: {
      type: "array",
      value: "function_stop"
    },
    base: {
      type: "number",
      default: 1,
      minimum: 0
    },
    property: {
      type: "string",
      default: "$zoom"
    },
    type: {
      type: "enum",
      values: {
        identity: {},
        exponential: {},
        interval: {},
        categorical: {}
      },
      default: "exponential"
    },
    colorSpace: {
      type: "enum",
      values: {
        rgb: {},
        lab: {},
        hcl: {}
      },
      default: "rgb"
    },
    default: {
      type: "*",
      required: !1
    }
  },
  function_stop: vs,
  expression: bs,
  light: ws,
  sky: Ss,
  terrain: xs,
  projection: ks,
  paint: Ls,
  paint_fill: Cs,
  "paint_fill-extrusion": {
    "fill-extrusion-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-color": {
      type: "color",
      default: "#000000",
      transition: !0,
      requires: [
        {
          "!": "fill-extrusion-pattern"
        }
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-translate": {
      type: "array",
      value: "number",
      length: 2,
      default: [
        0,
        0
      ],
      transition: !0,
      units: "pixels",
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-translate-anchor": {
      type: "enum",
      values: {
        map: {},
        viewport: {}
      },
      default: "map",
      requires: [
        "fill-extrusion-translate"
      ],
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "fill-extrusion-pattern": {
      type: "resolvedImage",
      transition: !0,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom",
          "feature"
        ]
      },
      "property-type": "cross-faded-data-driven"
    },
    "fill-extrusion-height": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-base": {
      type: "number",
      default: 0,
      minimum: 0,
      units: "meters",
      transition: !0,
      requires: [
        "fill-extrusion-height"
      ],
      expression: {
        interpolated: !0,
        parameters: [
          "zoom",
          "feature",
          "feature-state"
        ]
      },
      "property-type": "data-driven"
    },
    "fill-extrusion-vertical-gradient": {
      type: "boolean",
      default: !0,
      transition: !1,
      expression: {
        interpolated: !1,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    }
  },
  paint_line: Es,
  paint_circle: As,
  paint_heatmap: Ts,
  paint_symbol: _s,
  paint_raster: Is,
  paint_hillshade: Ms,
  "paint_color-relief": {
    "color-relief-opacity": {
      type: "number",
      default: 1,
      minimum: 0,
      maximum: 1,
      transition: !0,
      expression: {
        interpolated: !0,
        parameters: [
          "zoom"
        ]
      },
      "property-type": "data-constant"
    },
    "color-relief-color": {
      type: "color",
      transition: !1,
      expression: {
        interpolated: !0,
        parameters: [
          "elevation"
        ]
      },
      "property-type": "color-ramp"
    }
  },
  paint_background: Ps,
  transition: Rs,
  "property-type": {
    "data-driven": {
      type: "property-type"
    },
    "cross-faded": {
      type: "property-type"
    },
    "cross-faded-data-driven": {
      type: "property-type"
    },
    "color-ramp": {
      type: "property-type"
    },
    "data-constant": {
      type: "property-type"
    },
    constant: {
      type: "property-type"
    }
  },
  promoteId: zs
};
class w {
  constructor(e, t, n, a) {
    this.message = (e ? `${e}: ` : "") + n, a && (this.identifier = a), t != null && t.__line__ && (this.line = t.__line__);
  }
}
function qt(r, ...e) {
  for (const t of e)
    for (const n in t)
      r[n] = t[n];
  return r;
}
class ve extends Error {
  constructor(e, t) {
    super(t), this.message = t, this.key = e;
  }
}
class sn {
  constructor(e, t = []) {
    this.parent = e, this.bindings = {};
    for (const [n, a] of t)
      this.bindings[n] = a;
  }
  concat(e) {
    return new sn(this, e);
  }
  get(e) {
    if (this.bindings[e])
      return this.bindings[e];
    if (this.parent)
      return this.parent.get(e);
    throw new Error(`${e} not found in scope.`);
  }
  has(e) {
    return this.bindings[e] ? !0 : this.parent ? this.parent.has(e) : !1;
  }
}
const er = { kind: "null" }, S = { kind: "number" }, P = { kind: "string" }, M = { kind: "boolean" }, be = { kind: "color" }, tr = { kind: "projectionDefinition" }, De = { kind: "object" }, I = { kind: "value" }, Fs = { kind: "error" }, rr = { kind: "collator" }, nr = { kind: "formatted" }, ar = { kind: "padding" }, yt = { kind: "colorArray" }, or = { kind: "numberArray" }, Tt = { kind: "resolvedImage" }, ir = { kind: "variableAnchorOffsetCollection" };
function ae(r, e) {
  return {
    kind: "array",
    itemType: r,
    N: e
  };
}
function D(r) {
  if (r.kind === "array") {
    const e = D(r.itemType);
    return typeof r.N == "number" ? `array<${e}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${e}>`;
  } else
    return r.kind;
}
const $s = [
  er,
  S,
  P,
  M,
  be,
  tr,
  nr,
  De,
  ae(I),
  ar,
  or,
  yt,
  Tt,
  ir
];
function gt(r, e) {
  if (e.kind === "error")
    return null;
  if (r.kind === "array") {
    if (e.kind === "array" && (e.N === 0 && e.itemType.kind === "value" || !gt(r.itemType, e.itemType)) && (typeof r.N != "number" || r.N === e.N))
      return null;
  } else {
    if (r.kind === e.kind)
      return null;
    if (r.kind === "value") {
      for (const t of $s)
        if (!gt(t, e))
          return null;
    }
  }
  return `Expected ${D(r)} but found ${D(e)} instead.`;
}
function ln(r, e) {
  return e.some((t) => t.kind === r.kind);
}
function Ue(r, e) {
  return e.some((t) => t === "null" ? r === null : t === "array" ? Array.isArray(r) : t === "object" ? r && !Array.isArray(r) && typeof r == "object" : t === typeof r);
}
function Ae(r, e) {
  return r.kind === "array" && e.kind === "array" ? r.itemType.kind === e.itemType.kind && typeof r.N == "number" : r.kind === e.kind;
}
const Ua = 0.96422, Ba = 1, qa = 0.82521, Va = 4 / 29, rt = 6 / 29, Ga = 3 * rt * rt, Ns = rt * rt * rt, js = Math.PI / 180, Ds = 180 / Math.PI;
function Ha(r) {
  return r = r % 360, r < 0 && (r += 360), r;
}
function Za([r, e, t, n]) {
  r = Sr(r), e = Sr(e), t = Sr(t);
  let a, o;
  const i = xr((0.2225045 * r + 0.7168786 * e + 0.0606169 * t) / Ba);
  r === e && e === t ? a = o = i : (a = xr((0.4360747 * r + 0.3850649 * e + 0.1430804 * t) / Ua), o = xr((0.0139322 * r + 0.0971045 * e + 0.7141733 * t) / qa));
  const s = 116 * i - 16;
  return [s < 0 ? 0 : s, 500 * (a - i), 200 * (i - o), n];
}
function Sr(r) {
  return r <= 0.04045 ? r / 12.92 : Math.pow((r + 0.055) / 1.055, 2.4);
}
function xr(r) {
  return r > Ns ? Math.pow(r, 1 / 3) : r / Ga + Va;
}
function Ka([r, e, t, n]) {
  let a = (r + 16) / 116, o = isNaN(e) ? a : a + e / 500, i = isNaN(t) ? a : a - t / 200;
  return a = Ba * Lr(a), o = Ua * Lr(o), i = qa * Lr(i), [
    kr(3.1338561 * o - 1.6168667 * a - 0.4906146 * i),
    // D50 -> sRGB
    kr(-0.9787684 * o + 1.9161415 * a + 0.033454 * i),
    kr(0.0719453 * o - 0.2289914 * a + 1.4052427 * i),
    n
  ];
}
function kr(r) {
  return r = r <= 304e-5 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - 0.055, r < 0 ? 0 : r > 1 ? 1 : r;
}
function Lr(r) {
  return r > rt ? r * r * r : Ga * (r - Va);
}
function Us(r) {
  const [e, t, n, a] = Za(r), o = Math.sqrt(t * t + n * n);
  return [Math.round(o * 1e4) ? Ha(Math.atan2(n, t) * Ds) : NaN, o, e, a];
}
function Bs([r, e, t, n]) {
  return r = isNaN(r) ? 0 : r * js, Ka([t, Math.cos(r) * e, Math.sin(r) * e, n]);
}
function qs([r, e, t, n]) {
  r = Ha(r), e /= 100, t /= 100;
  function a(o) {
    const i = (o + r / 30) % 12, s = e * Math.min(t, 1 - t);
    return t - s * Math.max(-1, Math.min(i - 3, 9 - i, 1));
  }
  return [a(0), a(8), a(4), n];
}
const Vs = Object.hasOwn || function(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
};
function dt(r, e) {
  return Vs(r, e) ? r[e] : void 0;
}
function Gs(r) {
  if (r = r.toLowerCase().trim(), r === "transparent")
    return [0, 0, 0, 0];
  const e = dt(Hs, r);
  if (e) {
    const [a, o, i] = e;
    return [a / 255, o / 255, i / 255, 1];
  }
  if (r.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(r)) {
    const o = r.length < 6 ? 1 : 2;
    let i = 1;
    return [
      Rt(r.slice(i, i += o)),
      Rt(r.slice(i, i += o)),
      Rt(r.slice(i, i += o)),
      Rt(r.slice(i, i + o) || "ff")
    ];
  }
  if (r.startsWith("rgb")) {
    const a = /^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, o = r.match(a);
    if (o) {
      const [
        i,
        // eslint-disable-line @typescript-eslint/no-unused-vars
        s,
        // <numeric>
        l,
        // %         (optional)
        u,
        // ,         (optional)
        c,
        // <numeric>
        p,
        // %         (optional)
        d,
        // ,         (optional)
        f,
        // <numeric>
        h,
        // %         (optional)
        m,
        // ,|/       (optional)
        y,
        // <numeric> (optional)
        b
        // %         (optional)
      ] = o, v = [u || " ", d || " ", m].join("");
      if (v === "  " || v === "  /" || v === ",," || v === ",,,") {
        const x = [l, p, h].join(""), E = x === "%%%" ? 100 : x === "" ? 255 : 0;
        if (E) {
          const C = [
            Qe(+s / E, 0, 1),
            Qe(+c / E, 0, 1),
            Qe(+f / E, 0, 1),
            y ? qn(+y, b) : 1
          ];
          if (Vn(C))
            return C;
        }
      }
      return;
    }
  }
  const t = /^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/, n = r.match(t);
  if (n) {
    const [
      a,
      // eslint-disable-line @typescript-eslint/no-unused-vars
      o,
      // <numeric>
      i,
      // ,         (optional)
      s,
      // <numeric>
      l,
      // ,         (optional)
      u,
      // <numeric>
      c,
      // ,|/       (optional)
      p,
      // <numeric> (optional)
      d
      // %         (optional)
    ] = n, f = [i || " ", l || " ", c].join("");
    if (f === "  " || f === "  /" || f === ",," || f === ",,,") {
      const h = [
        +o,
        Qe(+s, 0, 100),
        Qe(+u, 0, 100),
        p ? qn(+p, d) : 1
      ];
      if (Vn(h))
        return qs(h);
    }
  }
}
function Rt(r) {
  return parseInt(r.padEnd(2, r), 16) / 255;
}
function qn(r, e) {
  return Qe(e ? r / 100 : r, 0, 1);
}
function Qe(r, e, t) {
  return Math.min(Math.max(e, r), t);
}
function Vn(r) {
  return !r.some(Number.isNaN);
}
const Hs = {
  aliceblue: [240, 248, 255],
  antiquewhite: [250, 235, 215],
  aqua: [0, 255, 255],
  aquamarine: [127, 255, 212],
  azure: [240, 255, 255],
  beige: [245, 245, 220],
  bisque: [255, 228, 196],
  black: [0, 0, 0],
  blanchedalmond: [255, 235, 205],
  blue: [0, 0, 255],
  blueviolet: [138, 43, 226],
  brown: [165, 42, 42],
  burlywood: [222, 184, 135],
  cadetblue: [95, 158, 160],
  chartreuse: [127, 255, 0],
  chocolate: [210, 105, 30],
  coral: [255, 127, 80],
  cornflowerblue: [100, 149, 237],
  cornsilk: [255, 248, 220],
  crimson: [220, 20, 60],
  cyan: [0, 255, 255],
  darkblue: [0, 0, 139],
  darkcyan: [0, 139, 139],
  darkgoldenrod: [184, 134, 11],
  darkgray: [169, 169, 169],
  darkgreen: [0, 100, 0],
  darkgrey: [169, 169, 169],
  darkkhaki: [189, 183, 107],
  darkmagenta: [139, 0, 139],
  darkolivegreen: [85, 107, 47],
  darkorange: [255, 140, 0],
  darkorchid: [153, 50, 204],
  darkred: [139, 0, 0],
  darksalmon: [233, 150, 122],
  darkseagreen: [143, 188, 143],
  darkslateblue: [72, 61, 139],
  darkslategray: [47, 79, 79],
  darkslategrey: [47, 79, 79],
  darkturquoise: [0, 206, 209],
  darkviolet: [148, 0, 211],
  deeppink: [255, 20, 147],
  deepskyblue: [0, 191, 255],
  dimgray: [105, 105, 105],
  dimgrey: [105, 105, 105],
  dodgerblue: [30, 144, 255],
  firebrick: [178, 34, 34],
  floralwhite: [255, 250, 240],
  forestgreen: [34, 139, 34],
  fuchsia: [255, 0, 255],
  gainsboro: [220, 220, 220],
  ghostwhite: [248, 248, 255],
  gold: [255, 215, 0],
  goldenrod: [218, 165, 32],
  gray: [128, 128, 128],
  green: [0, 128, 0],
  greenyellow: [173, 255, 47],
  grey: [128, 128, 128],
  honeydew: [240, 255, 240],
  hotpink: [255, 105, 180],
  indianred: [205, 92, 92],
  indigo: [75, 0, 130],
  ivory: [255, 255, 240],
  khaki: [240, 230, 140],
  lavender: [230, 230, 250],
  lavenderblush: [255, 240, 245],
  lawngreen: [124, 252, 0],
  lemonchiffon: [255, 250, 205],
  lightblue: [173, 216, 230],
  lightcoral: [240, 128, 128],
  lightcyan: [224, 255, 255],
  lightgoldenrodyellow: [250, 250, 210],
  lightgray: [211, 211, 211],
  lightgreen: [144, 238, 144],
  lightgrey: [211, 211, 211],
  lightpink: [255, 182, 193],
  lightsalmon: [255, 160, 122],
  lightseagreen: [32, 178, 170],
  lightskyblue: [135, 206, 250],
  lightslategray: [119, 136, 153],
  lightslategrey: [119, 136, 153],
  lightsteelblue: [176, 196, 222],
  lightyellow: [255, 255, 224],
  lime: [0, 255, 0],
  limegreen: [50, 205, 50],
  linen: [250, 240, 230],
  magenta: [255, 0, 255],
  maroon: [128, 0, 0],
  mediumaquamarine: [102, 205, 170],
  mediumblue: [0, 0, 205],
  mediumorchid: [186, 85, 211],
  mediumpurple: [147, 112, 219],
  mediumseagreen: [60, 179, 113],
  mediumslateblue: [123, 104, 238],
  mediumspringgreen: [0, 250, 154],
  mediumturquoise: [72, 209, 204],
  mediumvioletred: [199, 21, 133],
  midnightblue: [25, 25, 112],
  mintcream: [245, 255, 250],
  mistyrose: [255, 228, 225],
  moccasin: [255, 228, 181],
  navajowhite: [255, 222, 173],
  navy: [0, 0, 128],
  oldlace: [253, 245, 230],
  olive: [128, 128, 0],
  olivedrab: [107, 142, 35],
  orange: [255, 165, 0],
  orangered: [255, 69, 0],
  orchid: [218, 112, 214],
  palegoldenrod: [238, 232, 170],
  palegreen: [152, 251, 152],
  paleturquoise: [175, 238, 238],
  palevioletred: [219, 112, 147],
  papayawhip: [255, 239, 213],
  peachpuff: [255, 218, 185],
  peru: [205, 133, 63],
  pink: [255, 192, 203],
  plum: [221, 160, 221],
  powderblue: [176, 224, 230],
  purple: [128, 0, 128],
  rebeccapurple: [102, 51, 153],
  red: [255, 0, 0],
  rosybrown: [188, 143, 143],
  royalblue: [65, 105, 225],
  saddlebrown: [139, 69, 19],
  salmon: [250, 128, 114],
  sandybrown: [244, 164, 96],
  seagreen: [46, 139, 87],
  seashell: [255, 245, 238],
  sienna: [160, 82, 45],
  silver: [192, 192, 192],
  skyblue: [135, 206, 235],
  slateblue: [106, 90, 205],
  slategray: [112, 128, 144],
  slategrey: [112, 128, 144],
  snow: [255, 250, 250],
  springgreen: [0, 255, 127],
  steelblue: [70, 130, 180],
  tan: [210, 180, 140],
  teal: [0, 128, 128],
  thistle: [216, 191, 216],
  tomato: [255, 99, 71],
  turquoise: [64, 224, 208],
  violet: [238, 130, 238],
  wheat: [245, 222, 179],
  white: [255, 255, 255],
  whitesmoke: [245, 245, 245],
  yellow: [255, 255, 0],
  yellowgreen: [154, 205, 50]
};
function Be(r, e, t) {
  return r + t * (e - r);
}
function vt(r, e, t) {
  return r.map((n, a) => Be(n, e[a], t));
}
class $ {
  /**
   * @param r Red component premultiplied by `alpha` 0..1
   * @param g Green component premultiplied by `alpha` 0..1
   * @param b Blue component premultiplied by `alpha` 0..1
   * @param [alpha=1] Alpha component 0..1
   * @param [premultiplied=true] Whether the `r`, `g` and `b` values have already
   * been multiplied by alpha. If `true` nothing happens if `false` then they will
   * be multiplied automatically.
   */
  constructor(e, t, n, a = 1, o = !0) {
    this.r = e, this.g = t, this.b = n, this.a = a, o || (this.r *= a, this.g *= a, this.b *= a, a || this.overwriteGetter("rgb", [e, t, n, a]));
  }
  /**
   * Parses CSS color strings and converts colors to sRGB color space if needed.
   * Officially supported color formats:
   * - keyword, e.g. 'aquamarine' or 'steelblue'
   * - hex (with 3, 4, 6 or 8 digits), e.g. '#f0f' or '#e9bebea9'
   * - rgb and rgba, e.g. 'rgb(0,240,120)' or 'rgba(0%,94%,47%,0.1)' or 'rgb(0 240 120 / .3)'
   * - hsl and hsla, e.g. 'hsl(0,0%,83%)' or 'hsla(0,0%,83%,.5)' or 'hsl(0 0% 83% / 20%)'
   *
   * @param input CSS color string to parse.
   * @returns A `Color` instance, or `undefined` if the input is not a valid color string.
   */
  static parse(e) {
    if (e instanceof $)
      return e;
    if (typeof e != "string")
      return;
    const t = Gs(e);
    if (t)
      return new $(...t, !1);
  }
  /**
   * Used in color interpolation and by 'to-rgba' expression.
   *
   * @returns Gien color, with reversed alpha blending, in sRGB color space.
   */
  get rgb() {
    const { r: e, g: t, b: n, a } = this, o = a || 1 / 0;
    return this.overwriteGetter("rgb", [e / o, t / o, n / o, a]);
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in HCL color space.
   */
  get hcl() {
    return this.overwriteGetter("hcl", Us(this.rgb));
  }
  /**
   * Used in color interpolation.
   *
   * @returns Gien color, with reversed alpha blending, in LAB color space.
   */
  get lab() {
    return this.overwriteGetter("lab", Za(this.rgb));
  }
  /**
   * Lazy getter pattern. When getter is called for the first time lazy value
   * is calculated and then overwrites getter function in given object instance.
   *
   * @example:
   * const redColor = Color.parse('red');
   * let x = redColor.hcl; // this will invoke `get hcl()`, which will calculate
   * // the value of red in HCL space and invoke this `overwriteGetter` function
   * // which in turn will set a field with a key 'hcl' in the `redColor` object.
   * // In other words it will override `get hcl()` from its `Color` prototype
   * // with its own property: hcl = [calculated red value in hcl].
   * let y = redColor.hcl; // next call will no longer invoke getter but simply
   * // return the previously calculated value
   * x === y; // true - `x` is exactly the same object as `y`
   *
   * @param getterKey Getter key
   * @param lazyValue Lazily calculated value to be memoized by current instance
   * @private
   */
  overwriteGetter(e, t) {
    return Object.defineProperty(this, e, { value: t }), t;
  }
  /**
   * Used by 'to-string' expression.
   *
   * @returns Serialized color in format `rgba(r,g,b,a)`
   * where r,g,b are numbers within 0..255 and alpha is number within 1..0
   *
   * @example
   * var purple = new Color.parse('purple');
   * purple.toString; // = "rgba(128,0,128,1)"
   * var translucentGreen = new Color.parse('rgba(26, 207, 26, .73)');
   * translucentGreen.toString(); // = "rgba(26,207,26,0.73)"
   */
  toString() {
    const [e, t, n, a] = this.rgb;
    return `rgba(${[e, t, n].map((o) => Math.round(o * 255)).join(",")},${a})`;
  }
  static interpolate(e, t, n, a = "rgb") {
    switch (a) {
      case "rgb": {
        const [o, i, s, l] = vt(e.rgb, t.rgb, n);
        return new $(o, i, s, l, !1);
      }
      case "hcl": {
        const [o, i, s, l] = e.hcl, [u, c, p, d] = t.hcl;
        let f, h;
        if (!isNaN(o) && !isNaN(u)) {
          let x = u - o;
          u > o && x > 180 ? x -= 360 : u < o && o - u > 180 && (x += 360), f = o + n * x;
        } else isNaN(o) ? isNaN(u) ? f = NaN : (f = u, (s === 1 || s === 0) && (h = c)) : (f = o, (p === 1 || p === 0) && (h = i));
        const [m, y, b, v] = Bs([
          f,
          h ?? Be(i, c, n),
          Be(s, p, n),
          Be(l, d, n)
        ]);
        return new $(m, y, b, v, !1);
      }
      case "lab": {
        const [o, i, s, l] = Ka(vt(e.lab, t.lab, n));
        return new $(o, i, s, l, !1);
      }
    }
  }
}
$.black = new $(0, 0, 0, 1);
$.white = new $(1, 1, 1, 1);
$.transparent = new $(0, 0, 0, 0);
$.red = new $(1, 0, 0, 1);
class un {
  constructor(e, t, n) {
    e ? this.sensitivity = t ? "variant" : "case" : this.sensitivity = t ? "accent" : "base", this.locale = n, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
  }
  compare(e, t) {
    return this.collator.compare(e, t);
  }
  resolvedLocale() {
    return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
  }
}
const Zs = ["bottom", "center", "top"];
class Dr {
  constructor(e, t, n, a, o, i) {
    this.text = e, this.image = t, this.scale = n, this.fontStack = a, this.textColor = o, this.verticalAlign = i;
  }
}
class Le {
  constructor(e) {
    this.sections = e;
  }
  static fromString(e) {
    return new Le([new Dr(e, null, null, null, null, null)]);
  }
  isEmpty() {
    return this.sections.length === 0 ? !0 : !this.sections.some((e) => e.text.length !== 0 || e.image && e.image.name.length !== 0);
  }
  static factory(e) {
    return e instanceof Le ? e : Le.fromString(e);
  }
  toString() {
    return this.sections.length === 0 ? "" : this.sections.map((e) => e.text).join("");
  }
}
class fe {
  constructor(e) {
    this.values = e.slice();
  }
  /**
   * Numeric padding values
   * @param input A padding value
   * @returns A `Padding` instance, or `undefined` if the input is not a valid padding value.
   */
  static parse(e) {
    if (e instanceof fe)
      return e;
    if (typeof e == "number")
      return new fe([e, e, e, e]);
    if (Array.isArray(e) && !(e.length < 1 || e.length > 4)) {
      for (const t of e)
        if (typeof t != "number")
          return;
      switch (e.length) {
        case 1:
          e = [e[0], e[0], e[0], e[0]];
          break;
        case 2:
          e = [e[0], e[1], e[0], e[1]];
          break;
        case 3:
          e = [e[0], e[1], e[2], e[1]];
          break;
      }
      return new fe(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n) {
    return new fe(vt(e.values, t.values, n));
  }
}
class de {
  constructor(e) {
    this.values = e.slice();
  }
  /**
   * Numeric NumberArray values
   * @param input A NumberArray value
   * @returns A `NumberArray` instance, or `undefined` if the input is not a valid NumberArray value.
   */
  static parse(e) {
    if (e instanceof de)
      return e;
    if (typeof e == "number")
      return new de([e]);
    if (Array.isArray(e)) {
      for (const t of e)
        if (typeof t != "number")
          return;
      return new de(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n) {
    return new de(vt(e.values, t.values, n));
  }
}
class oe {
  constructor(e) {
    this.values = e.slice();
  }
  /**
   * ColorArray values
   * @param input A ColorArray value
   * @returns A `ColorArray` instance, or `undefined` if the input is not a valid ColorArray value.
   */
  static parse(e) {
    if (e instanceof oe)
      return e;
    if (typeof e == "string") {
      const n = $.parse(e);
      return n ? new oe([n]) : void 0;
    }
    if (!Array.isArray(e))
      return;
    const t = [];
    for (const n of e) {
      if (typeof n != "string")
        return;
      const a = $.parse(n);
      if (!a)
        return;
      t.push(a);
    }
    return new oe(t);
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n, a = "rgb") {
    const o = [];
    if (e.values.length != t.values.length)
      throw new Error(`colorArray: Arrays have mismatched length (${e.values.length} vs. ${t.values.length}), cannot interpolate.`);
    for (let i = 0; i < e.values.length; i++)
      o.push($.interpolate(e.values[i], t.values[i], n, a));
    return new oe(o);
  }
}
class V extends Error {
  constructor(e) {
    super(e), this.name = "RuntimeError";
  }
  toJSON() {
    return this.message;
  }
}
const Ks = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
class we {
  constructor(e) {
    this.values = e.slice();
  }
  static parse(e) {
    if (e instanceof we)
      return e;
    if (!(!Array.isArray(e) || e.length < 1 || e.length % 2 !== 0)) {
      for (let t = 0; t < e.length; t += 2) {
        const n = e[t], a = e[t + 1];
        if (typeof n != "string" || !Ks.has(n) || !Array.isArray(a) || a.length !== 2 || typeof a[0] != "number" || typeof a[1] != "number")
          return;
      }
      return new we(e);
    }
  }
  toString() {
    return JSON.stringify(this.values);
  }
  static interpolate(e, t, n) {
    const a = e.values, o = t.values;
    if (a.length !== o.length)
      throw new V(`Cannot interpolate values of different length. from: ${e.toString()}, to: ${t.toString()}`);
    const i = [];
    for (let s = 0; s < a.length; s += 2) {
      if (a[s] !== o[s])
        throw new V(`Cannot interpolate values containing mismatched anchors. from[${s}]: ${a[s]}, to[${s}]: ${o[s]}`);
      i.push(a[s]);
      const [l, u] = a[s + 1], [c, p] = o[s + 1];
      i.push([Be(l, c, n), Be(u, p, n)]);
    }
    return new we(i);
  }
}
class Fe {
  constructor(e) {
    this.name = e.name, this.available = e.available;
  }
  toString() {
    return this.name;
  }
  static fromString(e) {
    return e ? new Fe({ name: e, available: !1 }) : null;
  }
}
class ce {
  constructor(e, t, n) {
    this.from = e, this.to = t, this.transition = n;
  }
  static interpolate(e, t, n) {
    return new ce(e, t, n);
  }
  static parse(e) {
    if (e instanceof ce)
      return e;
    if (Array.isArray(e) && e.length === 3 && typeof e[0] == "string" && typeof e[1] == "string" && typeof e[2] == "number")
      return new ce(e[0], e[1], e[2]);
    if (typeof e == "object" && typeof e.from == "string" && typeof e.to == "string" && typeof e.transition == "number")
      return new ce(e.from, e.to, e.transition);
    if (typeof e == "string")
      return new ce(e, e, 1);
  }
}
function Xa(r, e, t, n) {
  return typeof r == "number" && r >= 0 && r <= 255 && typeof e == "number" && e >= 0 && e <= 255 && typeof t == "number" && t >= 0 && t <= 255 ? typeof n > "u" || typeof n == "number" && n >= 0 && n <= 1 ? null : `Invalid rgba value [${[r, e, t, n].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof n == "number" ? [r, e, t, n] : [r, e, t]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
}
function bt(r) {
  if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof ce || r instanceof $ || r instanceof un || r instanceof Le || r instanceof fe || r instanceof de || r instanceof oe || r instanceof we || r instanceof Fe)
    return !0;
  if (Array.isArray(r)) {
    for (const e of r)
      if (!bt(e))
        return !1;
    return !0;
  } else if (typeof r == "object") {
    for (const e in r)
      if (!bt(r[e]))
        return !1;
    return !0;
  } else
    return !1;
}
function H(r) {
  if (r === null)
    return er;
  if (typeof r == "string")
    return P;
  if (typeof r == "boolean")
    return M;
  if (typeof r == "number")
    return S;
  if (r instanceof $)
    return be;
  if (r instanceof ce)
    return tr;
  if (r instanceof un)
    return rr;
  if (r instanceof Le)
    return nr;
  if (r instanceof fe)
    return ar;
  if (r instanceof de)
    return or;
  if (r instanceof oe)
    return yt;
  if (r instanceof we)
    return ir;
  if (r instanceof Fe)
    return Tt;
  if (Array.isArray(r)) {
    const e = r.length;
    let t;
    for (const n of r) {
      const a = H(n);
      if (!t)
        t = a;
      else {
        if (t === a)
          continue;
        t = I;
        break;
      }
    }
    return ae(t || I, e);
  } else
    return De;
}
function ht(r) {
  const e = typeof r;
  return r === null ? "" : e === "string" || e === "number" || e === "boolean" ? String(r) : r instanceof $ || r instanceof ce || r instanceof Le || r instanceof fe || r instanceof de || r instanceof oe || r instanceof we || r instanceof Fe ? r.toString() : JSON.stringify(r);
}
class ot {
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`'literal' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (!bt(e[1]))
      return t.error("invalid value");
    const n = e[1];
    let a = H(n);
    const o = t.expectedType;
    return a.kind === "array" && a.N === 0 && o && o.kind === "array" && (typeof o.N != "number" || o.N === 0) && (a = o), new ot(a, n);
  }
  evaluate() {
    return this.value;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
}
const zt = {
  string: P,
  number: S,
  boolean: M,
  object: De
};
class pe {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    let n = 1, a;
    const o = e[0];
    if (o === "array") {
      let s;
      if (e.length > 2) {
        const u = e[1];
        if (typeof u != "string" || !(u in zt) || u === "object")
          return t.error('The item type argument of "array" must be one of string, number, boolean', 1);
        s = zt[u], n++;
      } else
        s = I;
      let l;
      if (e.length > 3) {
        if (e[2] !== null && (typeof e[2] != "number" || e[2] < 0 || e[2] !== Math.floor(e[2])))
          return t.error('The length argument to "array" must be a positive integer literal', 2);
        l = e[2], n++;
      }
      a = ae(s, l);
    } else {
      if (!zt[o])
        throw new Error(`Types doesn't contain name = ${o}`);
      a = zt[o];
    }
    const i = [];
    for (; n < e.length; n++) {
      const s = t.parse(e[n], n, I);
      if (!s)
        return null;
      i.push(s);
    }
    return new pe(a, i);
  }
  evaluate(e) {
    for (let t = 0; t < this.args.length; t++) {
      const n = this.args[t].evaluate(e);
      if (gt(this.type, H(n))) {
        if (t === this.args.length - 1)
          throw new V(`Expected value to be of type ${D(this.type)}, but found ${D(H(n))} instead.`);
      } else return n;
    }
    throw new Error();
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
}
const Gn = {
  "to-boolean": M,
  "to-color": be,
  "to-number": S,
  "to-string": P
};
class Re {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    const n = e[0];
    if (!Gn[n])
      throw new Error(`Can't parse ${n} as it is not part of the known types`);
    if ((n === "to-boolean" || n === "to-string") && e.length !== 2)
      return t.error("Expected one argument.");
    const a = Gn[n], o = [];
    for (let i = 1; i < e.length; i++) {
      const s = t.parse(e[i], i, I);
      if (!s)
        return null;
      o.push(s);
    }
    return new Re(a, o);
  }
  evaluate(e) {
    switch (this.type.kind) {
      case "boolean":
        return !!this.args[0].evaluate(e);
      case "color": {
        let t, n;
        for (const a of this.args) {
          if (t = a.evaluate(e), n = null, t instanceof $)
            return t;
          if (typeof t == "string") {
            const o = e.parseColor(t);
            if (o)
              return o;
          } else if (Array.isArray(t) && (t.length < 3 || t.length > 4 ? n = `Invalid rgba value ${JSON.stringify(t)}: expected an array containing either three or four numeric values.` : n = Xa(t[0], t[1], t[2], t[3]), !n))
            return new $(t[0] / 255, t[1] / 255, t[2] / 255, t[3]);
        }
        throw new V(n || `Could not parse color from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "padding": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const a = fe.parse(t);
          if (a)
            return a;
        }
        throw new V(`Could not parse padding from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "numberArray": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const a = de.parse(t);
          if (a)
            return a;
        }
        throw new V(`Could not parse numberArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "colorArray": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const a = oe.parse(t);
          if (a)
            return a;
        }
        throw new V(`Could not parse colorArray from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "variableAnchorOffsetCollection": {
        let t;
        for (const n of this.args) {
          t = n.evaluate(e);
          const a = we.parse(t);
          if (a)
            return a;
        }
        throw new V(`Could not parse variableAnchorOffsetCollection from value '${typeof t == "string" ? t : JSON.stringify(t)}'`);
      }
      case "number": {
        let t = null;
        for (const n of this.args) {
          if (t = n.evaluate(e), t === null)
            return 0;
          const a = Number(t);
          if (!isNaN(a))
            return a;
        }
        throw new V(`Could not convert ${JSON.stringify(t)} to number.`);
      }
      case "formatted":
        return Le.fromString(ht(this.args[0].evaluate(e)));
      case "resolvedImage":
        return Fe.fromString(ht(this.args[0].evaluate(e)));
      case "projectionDefinition":
        return this.args[0].evaluate(e);
      default:
        return ht(this.args[0].evaluate(e));
    }
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
}
const Xs = ["Unknown", "Point", "LineString", "Polygon"];
class Ya {
  constructor() {
    this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = /* @__PURE__ */ new Map(), this.availableImages = null, this.canonical = null;
  }
  id() {
    return this.feature && "id" in this.feature ? this.feature.id : null;
  }
  geometryType() {
    return this.feature ? typeof this.feature.type == "number" ? Xs[this.feature.type] : this.feature.type : null;
  }
  geometry() {
    return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
  }
  canonicalID() {
    return this.canonical;
  }
  properties() {
    return this.feature && this.feature.properties || {};
  }
  parseColor(e) {
    let t = this._parseColorCache.get(e);
    return t || (t = $.parse(e), this._parseColorCache.set(e, t)), t;
  }
}
class sr {
  constructor(e, t, n = [], a, o = new sn(), i = []) {
    this.registry = e, this.path = n, this.key = n.map((s) => `[${s}]`).join(""), this.scope = o, this.errors = i, this.expectedType = a, this._isConstant = t;
  }
  /**
   * @param expr the JSON expression to parse
   * @param index the optional argument index if this expression is an argument of a parent expression that's being parsed
   * @param options
   * @param options.omitTypeAnnotations set true to omit inferred type annotations.  Caller beware: with this option set, the parsed expression's type will NOT satisfy `expectedType` if it would normally be wrapped in an inferred annotation.
   * @private
   */
  parse(e, t, n, a, o = {}) {
    return t ? this.concat(t, n, a)._parse(e, o) : this._parse(e, o);
  }
  _parse(e, t) {
    (e === null || typeof e == "string" || typeof e == "boolean" || typeof e == "number") && (e = ["literal", e]);
    function n(a, o, i) {
      return i === "assert" ? new pe(o, [a]) : i === "coerce" ? new Re(o, [a]) : a;
    }
    if (Array.isArray(e)) {
      if (e.length === 0)
        return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
      const a = e[0];
      if (typeof a != "string")
        return this.error(`Expression name must be a string, but found ${typeof a} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
      const o = this.registry[a];
      if (o) {
        let i = o.parse(e, this);
        if (!i)
          return null;
        if (this.expectedType) {
          const s = this.expectedType, l = i.type;
          if ((s.kind === "string" || s.kind === "number" || s.kind === "boolean" || s.kind === "object" || s.kind === "array") && l.kind === "value")
            i = n(i, s, t.typeAnnotation || "assert");
          else if (s.kind === "projectionDefinition" && ["string", "array"].includes(l.kind) || ["color", "formatted", "resolvedImage"].includes(s.kind) && ["value", "string"].includes(l.kind) || ["padding", "numberArray"].includes(s.kind) && ["value", "number", "array"].includes(l.kind) || s.kind === "colorArray" && ["value", "string", "array"].includes(l.kind) || s.kind === "variableAnchorOffsetCollection" && ["value", "array"].includes(l.kind))
            i = n(i, s, t.typeAnnotation || "coerce");
          else if (this.checkSubtype(s, l))
            return null;
        }
        if (!(i instanceof ot) && i.type.kind !== "resolvedImage" && this._isConstant(i)) {
          const s = new Ya();
          try {
            i = new ot(i.type, i.evaluate(s));
          } catch (l) {
            return this.error(l.message), null;
          }
        }
        return i;
      }
      return this.error(`Unknown expression "${a}". If you wanted a literal array, use ["literal", [...]].`, 0);
    } else return typeof e > "u" ? this.error("'undefined' value invalid. Use null instead.") : typeof e == "object" ? this.error('Bare objects invalid. Use ["literal", {...}] instead.') : this.error(`Expected an array, but found ${typeof e} instead.`);
  }
  /**
   * Returns a copy of this context suitable for parsing the subexpression at
   * index `index`, optionally appending to 'let' binding map.
   *
   * Note that `errors` property, intended for collecting errors while
   * parsing, is copied by reference rather than cloned.
   * @private
   */
  concat(e, t, n) {
    const a = typeof e == "number" ? this.path.concat(e) : this.path, o = n ? this.scope.concat(n) : this.scope;
    return new sr(this.registry, this._isConstant, a, t || null, o, this.errors);
  }
  /**
   * Push a parsing (or type checking) error into the `this.errors`
   * @param error The message
   * @param keys Optionally specify the source of the error at a child
   * of the current expression at `this.key`.
   * @private
   */
  error(e, ...t) {
    const n = `${this.key}${t.map((a) => `[${a}]`).join("")}`;
    this.errors.push(new ve(n, e));
  }
  /**
   * Returns null if `t` is a subtype of `expected`; otherwise returns an
   * error message and also pushes it to `this.errors`.
   * @param expected The expected type
   * @param t The actual type
   * @returns null if `t` is a subtype of `expected`; otherwise returns an error message
   */
  checkSubtype(e, t) {
    const n = gt(e, t);
    return n && this.error(n), n;
  }
}
class lr {
  constructor(e, t) {
    this.type = t.type, this.bindings = [].concat(e), this.result = t;
  }
  evaluate(e) {
    return this.result.evaluate(e);
  }
  eachChild(e) {
    for (const t of this.bindings)
      e(t[1]);
    e(this.result);
  }
  static parse(e, t) {
    if (e.length < 4)
      return t.error(`Expected at least 3 arguments, but found ${e.length - 1} instead.`);
    const n = [];
    for (let o = 1; o < e.length - 1; o += 2) {
      const i = e[o];
      if (typeof i != "string")
        return t.error(`Expected string, but found ${typeof i} instead.`, o);
      if (/[^a-zA-Z0-9_]/.test(i))
        return t.error("Variable names must contain only alphanumeric characters or '_'.", o);
      const s = t.parse(e[o + 1], o + 1);
      if (!s)
        return null;
      n.push([i, s]);
    }
    const a = t.parse(e[e.length - 1], e.length - 1, t.expectedType, n);
    return a ? new lr(n, a) : null;
  }
  outputDefined() {
    return this.result.outputDefined();
  }
}
class ur {
  constructor(e, t) {
    this.type = t.type, this.name = e, this.boundExpression = t;
  }
  static parse(e, t) {
    if (e.length !== 2 || typeof e[1] != "string")
      return t.error("'var' expression requires exactly one string literal argument.");
    const n = e[1];
    return t.scope.has(n) ? new ur(n, t.scope.get(n)) : t.error(`Unknown variable "${n}". Make sure "${n}" has been bound in an enclosing "let" expression before using it.`, 1);
  }
  evaluate(e) {
    return this.boundExpression.evaluate(e);
  }
  eachChild() {
  }
  outputDefined() {
    return !1;
  }
}
class cn {
  constructor(e, t, n) {
    this.type = e, this.index = t, this.input = n;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, S), a = t.parse(e[2], 2, ae(t.expectedType || I));
    if (!n || !a)
      return null;
    const o = a.type;
    return new cn(o.itemType, n, a);
  }
  evaluate(e) {
    const t = this.index.evaluate(e), n = this.input.evaluate(e);
    if (t < 0)
      throw new V(`Array index out of bounds: ${t} < 0.`);
    if (t >= n.length)
      throw new V(`Array index out of bounds: ${t} > ${n.length - 1}.`);
    if (t !== Math.floor(t))
      throw new V(`Array index must be an integer, but found ${t} instead.`);
    return n[t];
  }
  eachChild(e) {
    e(this.index), e(this.input);
  }
  outputDefined() {
    return !1;
  }
}
class pn {
  constructor(e, t) {
    this.type = M, this.needle = e, this.haystack = t;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error(`Expected 2 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);
    return !n || !a ? null : ln(n.type, [M, P, S, er, I]) ? new pn(n, a) : t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);
  }
  evaluate(e) {
    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (!n)
      return !1;
    if (!Ue(t, ["boolean", "string", "number", "null"]))
      throw new V(`Expected first argument to be of type boolean, string, number or null, but found ${D(H(t))} instead.`);
    if (!Ue(n, ["string", "array"]))
      throw new V(`Expected second argument to be of type array or string, but found ${D(H(n))} instead.`);
    return n.indexOf(t) >= 0;
  }
  eachChild(e) {
    e(this.needle), e(this.haystack);
  }
  outputDefined() {
    return !0;
  }
}
class Vt {
  constructor(e, t, n) {
    this.type = S, this.needle = e, this.haystack = t, this.fromIndex = n;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5)
      return t.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, I);
    if (!n || !a)
      return null;
    if (!ln(n.type, [M, P, S, er, I]))
      return t.error(`Expected first argument to be of type boolean, string, number or null, but found ${D(n.type)} instead`);
    if (e.length === 4) {
      const o = t.parse(e[3], 3, S);
      return o ? new Vt(n, a, o) : null;
    } else
      return new Vt(n, a);
  }
  evaluate(e) {
    const t = this.needle.evaluate(e), n = this.haystack.evaluate(e);
    if (!Ue(t, ["boolean", "string", "number", "null"]))
      throw new V(`Expected first argument to be of type boolean, string, number or null, but found ${D(H(t))} instead.`);
    let a;
    if (this.fromIndex && (a = this.fromIndex.evaluate(e)), Ue(n, ["string"])) {
      const o = n.indexOf(t, a);
      return o === -1 ? -1 : [...n.slice(0, o)].length;
    } else {
      if (Ue(n, ["array"]))
        return n.indexOf(t, a);
      throw new V(`Expected second argument to be of type array or string, but found ${D(H(n))} instead.`);
    }
  }
  eachChild(e) {
    e(this.needle), e(this.haystack), this.fromIndex && e(this.fromIndex);
  }
  outputDefined() {
    return !1;
  }
}
class fn {
  constructor(e, t, n, a, o, i) {
    this.inputType = e, this.type = t, this.input = n, this.cases = a, this.outputs = o, this.otherwise = i;
  }
  static parse(e, t) {
    if (e.length < 5)
      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 1)
      return t.error("Expected an even number of arguments.");
    let n, a;
    t.expectedType && t.expectedType.kind !== "value" && (a = t.expectedType);
    const o = {}, i = [];
    for (let u = 2; u < e.length - 1; u += 2) {
      let c = e[u];
      const p = e[u + 1];
      Array.isArray(c) || (c = [c]);
      const d = t.concat(u);
      if (c.length === 0)
        return d.error("Expected at least one branch label.");
      for (const h of c) {
        if (typeof h != "number" && typeof h != "string")
          return d.error("Branch labels must be numbers or strings.");
        if (typeof h == "number" && Math.abs(h) > Number.MAX_SAFE_INTEGER)
          return d.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
        if (typeof h == "number" && Math.floor(h) !== h)
          return d.error("Numeric branch labels must be integer values.");
        if (!n)
          n = H(h);
        else if (d.checkSubtype(n, H(h)))
          return null;
        if (typeof o[String(h)] < "u")
          return d.error("Branch labels must be unique.");
        o[String(h)] = i.length;
      }
      const f = t.parse(p, u, a);
      if (!f)
        return null;
      a = a || f.type, i.push(f);
    }
    const s = t.parse(e[1], 1, I);
    if (!s)
      return null;
    const l = t.parse(e[e.length - 1], e.length - 1, a);
    return !l || s.type.kind !== "value" && t.concat(1).checkSubtype(n, s.type) ? null : new fn(n, a, s, o, i, l);
  }
  evaluate(e) {
    const t = this.input.evaluate(e);
    return (H(t) === this.inputType && this.outputs[this.cases[t]] || this.otherwise).evaluate(e);
  }
  eachChild(e) {
    e(this.input), this.outputs.forEach(e), e(this.otherwise);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined()) && this.otherwise.outputDefined();
  }
}
class dn {
  constructor(e, t, n) {
    this.type = e, this.branches = t, this.otherwise = n;
  }
  static parse(e, t) {
    if (e.length < 4)
      return t.error(`Expected at least 3 arguments, but found only ${e.length - 1}.`);
    if (e.length % 2 !== 0)
      return t.error("Expected an odd number of arguments.");
    let n;
    t.expectedType && t.expectedType.kind !== "value" && (n = t.expectedType);
    const a = [];
    for (let i = 1; i < e.length - 1; i += 2) {
      const s = t.parse(e[i], i, M);
      if (!s)
        return null;
      const l = t.parse(e[i + 1], i + 1, n);
      if (!l)
        return null;
      a.push([s, l]), n = n || l.type;
    }
    const o = t.parse(e[e.length - 1], e.length - 1, n);
    if (!o)
      return null;
    if (!n)
      throw new Error("Can't infer output type");
    return new dn(n, a, o);
  }
  evaluate(e) {
    for (const [t, n] of this.branches)
      if (t.evaluate(e))
        return n.evaluate(e);
    return this.otherwise.evaluate(e);
  }
  eachChild(e) {
    for (const [t, n] of this.branches)
      e(t), e(n);
    e(this.otherwise);
  }
  outputDefined() {
    return this.branches.every(([e, t]) => t.outputDefined()) && this.otherwise.outputDefined();
  }
}
class Gt {
  constructor(e, t, n, a) {
    this.type = e, this.input = t, this.beginIndex = n, this.endIndex = a;
  }
  static parse(e, t) {
    if (e.length <= 2 || e.length >= 5)
      return t.error(`Expected 2 or 3 arguments, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1, I), a = t.parse(e[2], 2, S);
    if (!n || !a)
      return null;
    if (!ln(n.type, [ae(I), P, I]))
      return t.error(`Expected first argument to be of type array or string, but found ${D(n.type)} instead`);
    if (e.length === 4) {
      const o = t.parse(e[3], 3, S);
      return o ? new Gt(n.type, n, a, o) : null;
    } else
      return new Gt(n.type, n, a);
  }
  evaluate(e) {
    const t = this.input.evaluate(e), n = this.beginIndex.evaluate(e);
    let a;
    if (this.endIndex && (a = this.endIndex.evaluate(e)), Ue(t, ["string"]))
      return [...t].slice(n, a).join("");
    if (Ue(t, ["array"]))
      return t.slice(n, a);
    throw new V(`Expected first argument to be of type array or string, but found ${D(H(t))} instead.`);
  }
  eachChild(e) {
    e(this.input), e(this.beginIndex), this.endIndex && e(this.endIndex);
  }
  outputDefined() {
    return !1;
  }
}
function Wa(r, e) {
  const t = r.length - 1;
  let n = 0, a = t, o = 0, i, s;
  for (; n <= a; )
    if (o = Math.floor((n + a) / 2), i = r[o], s = r[o + 1], i <= e) {
      if (o === t || e < s)
        return o;
      n = o + 1;
    } else if (i > e)
      a = o - 1;
    else
      throw new V("Input is not a number.");
  return 0;
}
class cr {
  constructor(e, t, n) {
    this.type = e, this.input = t, this.labels = [], this.outputs = [];
    for (const [a, o] of n)
      this.labels.push(a), this.outputs.push(o);
  }
  static parse(e, t) {
    if (e.length - 1 < 4)
      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0)
      return t.error("Expected an even number of arguments.");
    const n = t.parse(e[1], 1, S);
    if (!n)
      return null;
    const a = [];
    let o = null;
    t.expectedType && t.expectedType.kind !== "value" && (o = t.expectedType);
    for (let i = 1; i < e.length; i += 2) {
      const s = i === 1 ? -1 / 0 : e[i], l = e[i + 1], u = i, c = i + 1;
      if (typeof s != "number")
        return t.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', u);
      if (a.length && a[a.length - 1][0] >= s)
        return t.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', u);
      const p = t.parse(l, c, o);
      if (!p)
        return null;
      o = o || p.type, a.push([s, p]);
    }
    return new cr(o, n, a);
  }
  evaluate(e) {
    const t = this.labels, n = this.outputs;
    if (t.length === 1)
      return n[0].evaluate(e);
    const a = this.input.evaluate(e);
    if (a <= t[0])
      return n[0].evaluate(e);
    const o = t.length;
    if (a >= t[o - 1])
      return n[o - 1].evaluate(e);
    const i = Wa(t, a);
    return n[i].evaluate(e);
  }
  eachChild(e) {
    e(this.input);
    for (const t of this.outputs)
      e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
}
function Ys(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Cr, Hn;
function Ws() {
  if (Hn) return Cr;
  Hn = 1, Cr = r;
  function r(e, t, n, a) {
    this.cx = 3 * e, this.bx = 3 * (n - e) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * t, this.by = 3 * (a - t) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = e, this.p1y = t, this.p2x = n, this.p2y = a;
  }
  return r.prototype = {
    sampleCurveX: function(e) {
      return ((this.ax * e + this.bx) * e + this.cx) * e;
    },
    sampleCurveY: function(e) {
      return ((this.ay * e + this.by) * e + this.cy) * e;
    },
    sampleCurveDerivativeX: function(e) {
      return (3 * this.ax * e + 2 * this.bx) * e + this.cx;
    },
    solveCurveX: function(e, t) {
      if (t === void 0 && (t = 1e-6), e < 0) return 0;
      if (e > 1) return 1;
      for (var n = e, a = 0; a < 8; a++) {
        var o = this.sampleCurveX(n) - e;
        if (Math.abs(o) < t) return n;
        var i = this.sampleCurveDerivativeX(n);
        if (Math.abs(i) < 1e-6) break;
        n = n - o / i;
      }
      var s = 0, l = 1;
      for (n = e, a = 0; a < 20 && (o = this.sampleCurveX(n), !(Math.abs(o - e) < t)); a++)
        e > o ? s = n : l = n, n = (l - s) * 0.5 + s;
      return n;
    },
    solve: function(e, t) {
      return this.sampleCurveY(this.solveCurveX(e, t));
    }
  }, Cr;
}
var Js = Ws(), Qs = /* @__PURE__ */ Ys(Js);
class Se {
  constructor(e, t, n, a, o) {
    this.type = e, this.operator = t, this.interpolation = n, this.input = a, this.labels = [], this.outputs = [];
    for (const [i, s] of o)
      this.labels.push(i), this.outputs.push(s);
  }
  static interpolationFactor(e, t, n, a) {
    let o = 0;
    if (e.name === "exponential")
      o = Er(t, e.base, n, a);
    else if (e.name === "linear")
      o = Er(t, 1, n, a);
    else if (e.name === "cubic-bezier") {
      const i = e.controlPoints;
      o = new Qs(i[0], i[1], i[2], i[3]).solve(Er(t, 1, n, a));
    }
    return o;
  }
  static parse(e, t) {
    let [n, a, o, ...i] = e;
    if (!Array.isArray(a) || a.length === 0)
      return t.error("Expected an interpolation type expression.", 1);
    if (a[0] === "linear")
      a = { name: "linear" };
    else if (a[0] === "exponential") {
      const u = a[1];
      if (typeof u != "number")
        return t.error("Exponential interpolation requires a numeric base.", 1, 1);
      a = {
        name: "exponential",
        base: u
      };
    } else if (a[0] === "cubic-bezier") {
      const u = a.slice(1);
      if (u.length !== 4 || u.some((c) => typeof c != "number" || c < 0 || c > 1))
        return t.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
      a = {
        name: "cubic-bezier",
        controlPoints: u
      };
    } else
      return t.error(`Unknown interpolation type ${String(a[0])}`, 1, 0);
    if (e.length - 1 < 4)
      return t.error(`Expected at least 4 arguments, but found only ${e.length - 1}.`);
    if ((e.length - 1) % 2 !== 0)
      return t.error("Expected an even number of arguments.");
    if (o = t.parse(o, 2, S), !o)
      return null;
    const s = [];
    let l = null;
    (n === "interpolate-hcl" || n === "interpolate-lab") && t.expectedType != yt ? l = be : t.expectedType && t.expectedType.kind !== "value" && (l = t.expectedType);
    for (let u = 0; u < i.length; u += 2) {
      const c = i[u], p = i[u + 1], d = u + 3, f = u + 4;
      if (typeof c != "number")
        return t.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', d);
      if (s.length && s[s.length - 1][0] >= c)
        return t.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', d);
      const h = t.parse(p, f, l);
      if (!h)
        return null;
      l = l || h.type, s.push([c, h]);
    }
    return !Ae(l, S) && !Ae(l, tr) && !Ae(l, be) && !Ae(l, ar) && !Ae(l, or) && !Ae(l, yt) && !Ae(l, ir) && !Ae(l, ae(S)) ? t.error(`Type ${D(l)} is not interpolatable.`) : new Se(l, n, a, o, s);
  }
  evaluate(e) {
    const t = this.labels, n = this.outputs;
    if (t.length === 1)
      return n[0].evaluate(e);
    const a = this.input.evaluate(e);
    if (a <= t[0])
      return n[0].evaluate(e);
    const o = t.length;
    if (a >= t[o - 1])
      return n[o - 1].evaluate(e);
    const i = Wa(t, a), s = t[i], l = t[i + 1], u = Se.interpolationFactor(this.interpolation, a, s, l), c = n[i].evaluate(e), p = n[i + 1].evaluate(e);
    switch (this.operator) {
      case "interpolate":
        switch (this.type.kind) {
          case "number":
            return Be(c, p, u);
          case "color":
            return $.interpolate(c, p, u);
          case "padding":
            return fe.interpolate(c, p, u);
          case "colorArray":
            return oe.interpolate(c, p, u);
          case "numberArray":
            return de.interpolate(c, p, u);
          case "variableAnchorOffsetCollection":
            return we.interpolate(c, p, u);
          case "array":
            return vt(c, p, u);
          case "projectionDefinition":
            return ce.interpolate(c, p, u);
        }
      case "interpolate-hcl":
        switch (this.type.kind) {
          case "color":
            return $.interpolate(c, p, u, "hcl");
          case "colorArray":
            return oe.interpolate(c, p, u, "hcl");
        }
      case "interpolate-lab":
        switch (this.type.kind) {
          case "color":
            return $.interpolate(c, p, u, "lab");
          case "colorArray":
            return oe.interpolate(c, p, u, "lab");
        }
    }
  }
  eachChild(e) {
    e(this.input);
    for (const t of this.outputs)
      e(t);
  }
  outputDefined() {
    return this.outputs.every((e) => e.outputDefined());
  }
}
function Er(r, e, t, n) {
  const a = n - t, o = r - t;
  return a === 0 ? 0 : e === 1 ? o / a : (Math.pow(e, o) - 1) / (Math.pow(e, a) - 1);
}
class wt {
  constructor(e, t) {
    this.type = e, this.args = t;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    let n = null;
    const a = t.expectedType;
    a && a.kind !== "value" && (n = a);
    const o = [];
    for (const s of e.slice(1)) {
      const l = t.parse(s, 1 + o.length, n, void 0, { typeAnnotation: "omit" });
      if (!l)
        return null;
      n = n || l.type, o.push(l);
    }
    if (!n)
      throw new Error("No output type");
    return a && o.some((s) => gt(a, s.type)) ? new wt(I, o) : new wt(n, o);
  }
  evaluate(e) {
    let t = null, n = 0, a;
    for (const o of this.args)
      if (n++, t = o.evaluate(e), t && t instanceof Fe && !t.available && (a || (a = t.name), t = null, n === this.args.length && (t = a)), t !== null)
        break;
    return t;
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return this.args.every((e) => e.outputDefined());
  }
}
function Zn(r, e) {
  return r === "==" || r === "!=" ? e.kind === "boolean" || e.kind === "string" || e.kind === "number" || e.kind === "null" || e.kind === "value" : e.kind === "string" || e.kind === "number" || e.kind === "value";
}
function el(r, e, t) {
  return e === t;
}
function tl(r, e, t) {
  return e !== t;
}
function rl(r, e, t) {
  return e < t;
}
function nl(r, e, t) {
  return e > t;
}
function al(r, e, t) {
  return e <= t;
}
function ol(r, e, t) {
  return e >= t;
}
function Ja(r, e, t, n) {
  return n.compare(e, t) === 0;
}
function il(r, e, t, n) {
  return !Ja(r, e, t, n);
}
function sl(r, e, t, n) {
  return n.compare(e, t) < 0;
}
function ll(r, e, t, n) {
  return n.compare(e, t) > 0;
}
function ul(r, e, t, n) {
  return n.compare(e, t) <= 0;
}
function cl(r, e, t, n) {
  return n.compare(e, t) >= 0;
}
function lt(r, e, t) {
  const n = r !== "==" && r !== "!=";
  return class Qa {
    constructor(o, i, s) {
      this.type = M, this.lhs = o, this.rhs = i, this.collator = s, this.hasUntypedArgument = o.type.kind === "value" || i.type.kind === "value";
    }
    static parse(o, i) {
      if (o.length !== 3 && o.length !== 4)
        return i.error("Expected two or three arguments.");
      const s = o[0];
      let l = i.parse(o[1], 1, I);
      if (!l)
        return null;
      if (!Zn(s, l.type))
        return i.concat(1).error(`"${s}" comparisons are not supported for type '${D(l.type)}'.`);
      let u = i.parse(o[2], 2, I);
      if (!u)
        return null;
      if (!Zn(s, u.type))
        return i.concat(2).error(`"${s}" comparisons are not supported for type '${D(u.type)}'.`);
      if (l.type.kind !== u.type.kind && l.type.kind !== "value" && u.type.kind !== "value")
        return i.error(`Cannot compare types '${D(l.type)}' and '${D(u.type)}'.`);
      n && (l.type.kind === "value" && u.type.kind !== "value" ? l = new pe(u.type, [l]) : l.type.kind !== "value" && u.type.kind === "value" && (u = new pe(l.type, [u])));
      let c = null;
      if (o.length === 4) {
        if (l.type.kind !== "string" && u.type.kind !== "string" && l.type.kind !== "value" && u.type.kind !== "value")
          return i.error("Cannot use collator to compare non-string types.");
        if (c = i.parse(o[3], 3, rr), !c)
          return null;
      }
      return new Qa(l, u, c);
    }
    evaluate(o) {
      const i = this.lhs.evaluate(o), s = this.rhs.evaluate(o);
      if (n && this.hasUntypedArgument) {
        const l = H(i), u = H(s);
        if (l.kind !== u.kind || !(l.kind === "string" || l.kind === "number"))
          throw new V(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${l.kind}, ${u.kind}) instead.`);
      }
      if (this.collator && !n && this.hasUntypedArgument) {
        const l = H(i), u = H(s);
        if (l.kind !== "string" || u.kind !== "string")
          return e(o, i, s);
      }
      return this.collator ? t(o, i, s, this.collator.evaluate(o)) : e(o, i, s);
    }
    eachChild(o) {
      o(this.lhs), o(this.rhs), this.collator && o(this.collator);
    }
    outputDefined() {
      return !0;
    }
  };
}
const pl = lt("==", el, Ja), fl = lt("!=", tl, il), dl = lt("<", rl, sl), hl = lt(">", nl, ll), ml = lt("<=", al, ul), yl = lt(">=", ol, cl);
class pr {
  constructor(e, t, n) {
    this.type = rr, this.locale = n, this.caseSensitive = e, this.diacriticSensitive = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("Expected one argument.");
    const n = e[1];
    if (typeof n != "object" || Array.isArray(n))
      return t.error("Collator options argument must be an object.");
    const a = t.parse(n["case-sensitive"] === void 0 ? !1 : n["case-sensitive"], 1, M);
    if (!a)
      return null;
    const o = t.parse(n["diacritic-sensitive"] === void 0 ? !1 : n["diacritic-sensitive"], 1, M);
    if (!o)
      return null;
    let i = null;
    return n.locale && (i = t.parse(n.locale, 1, P), !i) ? null : new pr(a, o, i);
  }
  evaluate(e) {
    return new un(this.caseSensitive.evaluate(e), this.diacriticSensitive.evaluate(e), this.locale ? this.locale.evaluate(e) : null);
  }
  eachChild(e) {
    e(this.caseSensitive), e(this.diacriticSensitive), this.locale && e(this.locale);
  }
  outputDefined() {
    return !1;
  }
}
class hn {
  constructor(e, t, n, a, o) {
    this.type = P, this.number = e, this.locale = t, this.currency = n, this.minFractionDigits = a, this.maxFractionDigits = o;
  }
  static parse(e, t) {
    if (e.length !== 3)
      return t.error("Expected two arguments.");
    const n = t.parse(e[1], 1, S);
    if (!n)
      return null;
    const a = e[2];
    if (typeof a != "object" || Array.isArray(a))
      return t.error("NumberFormat options argument must be an object.");
    let o = null;
    if (a.locale && (o = t.parse(a.locale, 1, P), !o))
      return null;
    let i = null;
    if (a.currency && (i = t.parse(a.currency, 1, P), !i))
      return null;
    let s = null;
    if (a["min-fraction-digits"] && (s = t.parse(a["min-fraction-digits"], 1, S), !s))
      return null;
    let l = null;
    return a["max-fraction-digits"] && (l = t.parse(a["max-fraction-digits"], 1, S), !l) ? null : new hn(n, o, i, s, l);
  }
  evaluate(e) {
    return new Intl.NumberFormat(this.locale ? this.locale.evaluate(e) : [], {
      style: this.currency ? "currency" : "decimal",
      currency: this.currency ? this.currency.evaluate(e) : void 0,
      minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(e) : void 0,
      maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(e) : void 0
    }).format(this.number.evaluate(e));
  }
  eachChild(e) {
    e(this.number), this.locale && e(this.locale), this.currency && e(this.currency), this.minFractionDigits && e(this.minFractionDigits), this.maxFractionDigits && e(this.maxFractionDigits);
  }
  outputDefined() {
    return !1;
  }
}
class mn {
  constructor(e) {
    this.type = nr, this.sections = e;
  }
  static parse(e, t) {
    if (e.length < 2)
      return t.error("Expected at least one argument.");
    const n = e[1];
    if (!Array.isArray(n) && typeof n == "object")
      return t.error("First argument must be an image or text section.");
    const a = [];
    let o = !1;
    for (let i = 1; i <= e.length - 1; ++i) {
      const s = e[i];
      if (o && typeof s == "object" && !Array.isArray(s)) {
        o = !1;
        let l = null;
        if (s["font-scale"] && (l = t.parse(s["font-scale"], 1, S), !l))
          return null;
        let u = null;
        if (s["text-font"] && (u = t.parse(s["text-font"], 1, ae(P)), !u))
          return null;
        let c = null;
        if (s["text-color"] && (c = t.parse(s["text-color"], 1, be), !c))
          return null;
        let p = null;
        if (s["vertical-align"]) {
          if (typeof s["vertical-align"] == "string" && !Zs.includes(s["vertical-align"]))
            return t.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${s["vertical-align"]}' instead.`);
          if (p = t.parse(s["vertical-align"], 1, P), !p)
            return null;
        }
        const d = a[a.length - 1];
        d.scale = l, d.font = u, d.textColor = c, d.verticalAlign = p;
      } else {
        const l = t.parse(e[i], 1, I);
        if (!l)
          return null;
        const u = l.type.kind;
        if (u !== "string" && u !== "value" && u !== "null" && u !== "resolvedImage")
          return t.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
        o = !0, a.push({ content: l, scale: null, font: null, textColor: null, verticalAlign: null });
      }
    }
    return new mn(a);
  }
  evaluate(e) {
    const t = (n) => {
      const a = n.content.evaluate(e);
      return H(a) === Tt ? new Dr("", a, null, null, null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null) : new Dr(ht(a), null, n.scale ? n.scale.evaluate(e) : null, n.font ? n.font.evaluate(e).join(",") : null, n.textColor ? n.textColor.evaluate(e) : null, n.verticalAlign ? n.verticalAlign.evaluate(e) : null);
    };
    return new Le(this.sections.map(t));
  }
  eachChild(e) {
    for (const t of this.sections)
      e(t.content), t.scale && e(t.scale), t.font && e(t.font), t.textColor && e(t.textColor), t.verticalAlign && e(t.verticalAlign);
  }
  outputDefined() {
    return !1;
  }
}
class yn {
  constructor(e) {
    this.type = Tt, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error("Expected two arguments.");
    const n = t.parse(e[1], 1, P);
    return n ? new yn(n) : t.error("No image name provided.");
  }
  evaluate(e) {
    const t = this.input.evaluate(e), n = Fe.fromString(t);
    return n && e.availableImages && (n.available = e.availableImages.indexOf(t) > -1), n;
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return !1;
  }
}
class gn {
  constructor(e) {
    this.type = S, this.input = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
    const n = t.parse(e[1], 1);
    return n ? n.type.kind !== "array" && n.type.kind !== "string" && n.type.kind !== "value" ? t.error(`Expected argument of type string or array, but found ${D(n.type)} instead.`) : new gn(n) : null;
  }
  evaluate(e) {
    const t = this.input.evaluate(e);
    if (typeof t == "string")
      return [...t].length;
    if (Array.isArray(t))
      return t.length;
    throw new V(`Expected value to be of type string or array, but found ${D(H(t))} instead.`);
  }
  eachChild(e) {
    e(this.input);
  }
  outputDefined() {
    return !1;
  }
}
const xe = 8192;
function gl(r, e) {
  const t = vl(r[0]), n = wl(r[1]), a = Math.pow(2, e.z);
  return [Math.round(t * a * xe), Math.round(n * a * xe)];
}
function vn(r, e) {
  const t = Math.pow(2, e.z), n = (r[0] / xe + e.x) / t, a = (r[1] / xe + e.y) / t;
  return [bl(n), Sl(a)];
}
function vl(r) {
  return (180 + r) / 360;
}
function bl(r) {
  return r * 360 - 180;
}
function wl(r) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
}
function Sl(r) {
  return 360 / Math.PI * Math.atan(Math.exp((180 - r * 360) * Math.PI / 180)) - 90;
}
function _t(r, e) {
  r[0] = Math.min(r[0], e[0]), r[1] = Math.min(r[1], e[1]), r[2] = Math.max(r[2], e[0]), r[3] = Math.max(r[3], e[1]);
}
function St(r, e) {
  return !(r[0] <= e[0] || r[2] >= e[2] || r[1] <= e[1] || r[3] >= e[3]);
}
function xl(r, e, t) {
  return e[1] > r[1] != t[1] > r[1] && r[0] < (t[0] - e[0]) * (r[1] - e[1]) / (t[1] - e[1]) + e[0];
}
function kl(r, e, t) {
  const n = r[0] - e[0], a = r[1] - e[1], o = r[0] - t[0], i = r[1] - t[1];
  return n * i - o * a === 0 && n * o <= 0 && a * i <= 0;
}
function fr(r, e, t, n) {
  const a = [e[0] - r[0], e[1] - r[1]], o = [n[0] - t[0], n[1] - t[1]];
  return Al(o, a) === 0 ? !1 : !!(Kn(r, e, t, n) && Kn(t, n, r, e));
}
function Ll(r, e, t) {
  for (const n of t)
    for (let a = 0; a < n.length - 1; ++a)
      if (fr(r, e, n[a], n[a + 1]))
        return !0;
  return !1;
}
function ut(r, e, t = !1) {
  let n = !1;
  for (const a of e)
    for (let o = 0; o < a.length - 1; o++) {
      if (kl(r, a[o], a[o + 1]))
        return t;
      xl(r, a[o], a[o + 1]) && (n = !n);
    }
  return n;
}
function Cl(r, e) {
  for (const t of e)
    if (ut(r, t))
      return !0;
  return !1;
}
function eo(r, e) {
  for (const t of r)
    if (!ut(t, e))
      return !1;
  for (let t = 0; t < r.length - 1; ++t)
    if (Ll(r[t], r[t + 1], e))
      return !1;
  return !0;
}
function El(r, e) {
  for (const t of e)
    if (eo(r, t))
      return !0;
  return !1;
}
function Al(r, e) {
  return r[0] * e[1] - r[1] * e[0];
}
function Kn(r, e, t, n) {
  const a = r[0] - t[0], o = r[1] - t[1], i = e[0] - t[0], s = e[1] - t[1], l = n[0] - t[0], u = n[1] - t[1], c = a * u - l * o, p = i * u - l * s;
  return c > 0 && p < 0 || c < 0 && p > 0;
}
function bn(r, e, t) {
  const n = [];
  for (let a = 0; a < r.length; a++) {
    const o = [];
    for (let i = 0; i < r[a].length; i++) {
      const s = gl(r[a][i], t);
      _t(e, s), o.push(s);
    }
    n.push(o);
  }
  return n;
}
function to(r, e, t) {
  const n = [];
  for (let a = 0; a < r.length; a++) {
    const o = bn(r[a], e, t);
    n.push(o);
  }
  return n;
}
function ro(r, e, t, n) {
  if (r[0] < t[0] || r[0] > t[2]) {
    const a = n * 0.5;
    let o = r[0] - t[0] > a ? -n : t[0] - r[0] > a ? n : 0;
    o === 0 && (o = r[0] - t[2] > a ? -n : t[2] - r[0] > a ? n : 0), r[0] += o;
  }
  _t(e, r);
}
function Tl(r) {
  r[0] = r[1] = 1 / 0, r[2] = r[3] = -1 / 0;
}
function Xn(r, e, t, n) {
  const a = Math.pow(2, n.z) * xe, o = [n.x * xe, n.y * xe], i = [];
  for (const s of r)
    for (const l of s) {
      const u = [l.x + o[0], l.y + o[1]];
      ro(u, e, t, a), i.push(u);
    }
  return i;
}
function Yn(r, e, t, n) {
  const a = Math.pow(2, n.z) * xe, o = [n.x * xe, n.y * xe], i = [];
  for (const s of r) {
    const l = [];
    for (const u of s) {
      const c = [u.x + o[0], u.y + o[1]];
      _t(e, c), l.push(c);
    }
    i.push(l);
  }
  if (e[2] - e[0] <= a / 2) {
    Tl(e);
    for (const s of i)
      for (const l of s)
        ro(l, e, t, a);
  }
  return i;
}
function _l(r, e) {
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();
  if (e.type === "Polygon") {
    const o = bn(e.coordinates, n, a), i = Xn(r.geometry(), t, n, a);
    if (!St(t, n))
      return !1;
    for (const s of i)
      if (!ut(s, o))
        return !1;
  }
  if (e.type === "MultiPolygon") {
    const o = to(e.coordinates, n, a), i = Xn(r.geometry(), t, n, a);
    if (!St(t, n))
      return !1;
    for (const s of i)
      if (!Cl(s, o))
        return !1;
  }
  return !0;
}
function Il(r, e) {
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n = [1 / 0, 1 / 0, -1 / 0, -1 / 0], a = r.canonicalID();
  if (e.type === "Polygon") {
    const o = bn(e.coordinates, n, a), i = Yn(r.geometry(), t, n, a);
    if (!St(t, n))
      return !1;
    for (const s of i)
      if (!eo(s, o))
        return !1;
  }
  if (e.type === "MultiPolygon") {
    const o = to(e.coordinates, n, a), i = Yn(r.geometry(), t, n, a);
    if (!St(t, n))
      return !1;
    for (const s of i)
      if (!El(s, o))
        return !1;
  }
  return !0;
}
class qe {
  constructor(e, t) {
    this.type = M, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`'within' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (bt(e[1])) {
      const n = e[1];
      if (n.type === "FeatureCollection") {
        const a = [];
        for (const o of n.features) {
          const { type: i, coordinates: s } = o.geometry;
          i === "Polygon" && a.push(s), i === "MultiPolygon" && a.push(...s);
        }
        if (a.length) {
          const o = {
            type: "MultiPolygon",
            coordinates: a
          };
          return new qe(n, o);
        }
      } else if (n.type === "Feature") {
        const a = n.geometry.type;
        if (a === "Polygon" || a === "MultiPolygon")
          return new qe(n, n.geometry);
      } else if (n.type === "Polygon" || n.type === "MultiPolygon")
        return new qe(n, n);
    }
    return t.error("'within' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point")
        return _l(e, this.geometries);
      if (e.geometryType() === "LineString")
        return Il(e, this.geometries);
    }
    return !1;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
}
class no {
  constructor(e = [], t = (n, a) => n < a ? -1 : n > a ? 1 : 0) {
    if (this.data = e, this.length = this.data.length, this.compare = t, this.length > 0)
      for (let n = (this.length >> 1) - 1; n >= 0; n--) this._down(n);
  }
  push(e) {
    this.data.push(e), this._up(this.length++);
  }
  pop() {
    if (this.length === 0) return;
    const e = this.data[0], t = this.data.pop();
    return --this.length > 0 && (this.data[0] = t, this._down(0)), e;
  }
  peek() {
    return this.data[0];
  }
  _up(e) {
    const { data: t, compare: n } = this, a = t[e];
    for (; e > 0; ) {
      const o = e - 1 >> 1, i = t[o];
      if (n(a, i) >= 0) break;
      t[e] = i, e = o;
    }
    t[e] = a;
  }
  _down(e) {
    const { data: t, compare: n } = this, a = this.length >> 1, o = t[e];
    for (; e < a; ) {
      let i = (e << 1) + 1;
      const s = i + 1;
      if (s < this.length && n(t[s], t[i]) < 0 && (i = s), n(t[i], o) >= 0) break;
      t[e] = t[i], e = i;
    }
    t[e] = o;
  }
}
function Ml(r, e) {
  if (r.length <= 1)
    return [r];
  const n = [];
  let a, o;
  for (const i of r) {
    const s = Pl(i);
    s !== 0 && (i.area = Math.abs(s), o === void 0 && (o = s < 0), o === s < 0 ? (a && n.push(a), a = [i]) : a.push(i));
  }
  return a && n.push(a), n;
}
function Pl(r) {
  let e = 0;
  for (let t = 0, n = r.length, a = n - 1, o, i; t < n; a = t++)
    o = r[t], i = r[a], e += (i.x - o.x) * (o.y + i.y);
  return e;
}
const Rl = 6378.137, Wn = 1 / 298.257223563, Jn = Wn * (2 - Wn), Qn = Math.PI / 180;
class wn {
  constructor(e) {
    const t = Qn * Rl * 1e3, n = Math.cos(e * Qn), a = 1 / (1 - Jn * (1 - n * n)), o = Math.sqrt(a);
    this.kx = t * o * n, this.ky = t * o * a * (1 - Jn);
  }
  /**
   * Given two points of the form [longitude, latitude], returns the distance.
   *
   * @param a - point [longitude, latitude]
   * @param b - point [longitude, latitude]
   * @returns distance
   * @example
   * const distance = ruler.distance([30.5, 50.5], [30.51, 50.49]);
   * //=distance
   */
  distance(e, t) {
    const n = this.wrap(e[0] - t[0]) * this.kx, a = (e[1] - t[1]) * this.ky;
    return Math.sqrt(n * n + a * a);
  }
  /**
   * Returns an object of the form {point, index, t}, where point is closest point on the line
   * from the given point, index is the start index of the segment with the closest point,
   * and t is a parameter from 0 to 1 that indicates where the closest point is on that segment.
   *
   * @param line - an array of points that form the line
   * @param p - point [longitude, latitude]
   * @returns the nearest point, its index in the array and the proportion along the line
   * @example
   * const point = ruler.pointOnLine(line, [-67.04, 50.5]).point;
   * //=point
   */
  pointOnLine(e, t) {
    let n = 1 / 0, a, o, i, s;
    for (let l = 0; l < e.length - 1; l++) {
      let u = e[l][0], c = e[l][1], p = this.wrap(e[l + 1][0] - u) * this.kx, d = (e[l + 1][1] - c) * this.ky, f = 0;
      (p !== 0 || d !== 0) && (f = (this.wrap(t[0] - u) * this.kx * p + (t[1] - c) * this.ky * d) / (p * p + d * d), f > 1 ? (u = e[l + 1][0], c = e[l + 1][1]) : f > 0 && (u += p / this.kx * f, c += d / this.ky * f)), p = this.wrap(t[0] - u) * this.kx, d = (t[1] - c) * this.ky;
      const h = p * p + d * d;
      h < n && (n = h, a = u, o = c, i = l, s = f);
    }
    return {
      point: [a, o],
      index: i,
      t: Math.max(0, Math.min(1, s))
    };
  }
  wrap(e) {
    for (; e < -180; )
      e += 360;
    for (; e > 180; )
      e -= 360;
    return e;
  }
}
const Ur = 100, Br = 50;
function ao(r, e) {
  return e[0] - r[0];
}
function Ht(r) {
  return r[1] - r[0] + 1;
}
function Ee(r, e) {
  return r[1] >= r[0] && r[1] < e;
}
function qr(r, e) {
  if (r[0] > r[1])
    return [null, null];
  const t = Ht(r);
  if (e) {
    if (t === 2)
      return [r, null];
    const a = Math.floor(t / 2);
    return [
      [r[0], r[0] + a],
      [r[0] + a, r[1]]
    ];
  }
  if (t === 1)
    return [r, null];
  const n = Math.floor(t / 2) - 1;
  return [
    [r[0], r[0] + n],
    [r[0] + n + 1, r[1]]
  ];
}
function Vr(r, e) {
  if (!Ee(e, r.length))
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (let n = e[0]; n <= e[1]; ++n)
    _t(t, r[n]);
  return t;
}
function Gr(r) {
  const e = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  for (const t of r)
    for (const n of t)
      _t(e, n);
  return e;
}
function ea(r) {
  return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0;
}
function Sn(r, e, t) {
  if (!ea(r) || !ea(e))
    return NaN;
  let n = 0, a = 0;
  return r[2] < e[0] && (n = e[0] - r[2]), r[0] > e[2] && (n = r[0] - e[2]), r[1] > e[3] && (a = r[1] - e[3]), r[3] < e[1] && (a = e[1] - r[3]), t.distance([0, 0], [n, a]);
}
function je(r, e, t) {
  const n = t.pointOnLine(e, r);
  return t.distance(r, n.point);
}
function xn(r, e, t, n, a) {
  const o = Math.min(je(r, [t, n], a), je(e, [t, n], a)), i = Math.min(je(t, [r, e], a), je(n, [r, e], a));
  return Math.min(o, i);
}
function zl(r, e, t, n, a) {
  if (!(Ee(e, r.length) && Ee(n, t.length)))
    return 1 / 0;
  let i = 1 / 0;
  for (let s = e[0]; s < e[1]; ++s) {
    const l = r[s], u = r[s + 1];
    for (let c = n[0]; c < n[1]; ++c) {
      const p = t[c], d = t[c + 1];
      if (fr(l, u, p, d))
        return 0;
      i = Math.min(i, xn(l, u, p, d, a));
    }
  }
  return i;
}
function Ol(r, e, t, n, a) {
  if (!(Ee(e, r.length) && Ee(n, t.length)))
    return NaN;
  let i = 1 / 0;
  for (let s = e[0]; s <= e[1]; ++s)
    for (let l = n[0]; l <= n[1]; ++l)
      if (i = Math.min(i, a.distance(r[s], t[l])), i === 0)
        return i;
  return i;
}
function Fl(r, e, t) {
  if (ut(r, e, !0))
    return 0;
  let n = 1 / 0;
  for (const a of e) {
    const o = a[0], i = a[a.length - 1];
    if (o !== i && (n = Math.min(n, je(r, [i, o], t)), n === 0))
      return n;
    const s = t.pointOnLine(a, r);
    if (n = Math.min(n, t.distance(r, s.point)), n === 0)
      return n;
  }
  return n;
}
function $l(r, e, t, n) {
  if (!Ee(e, r.length))
    return NaN;
  for (let o = e[0]; o <= e[1]; ++o)
    if (ut(r[o], t, !0))
      return 0;
  let a = 1 / 0;
  for (let o = e[0]; o < e[1]; ++o) {
    const i = r[o], s = r[o + 1];
    for (const l of t)
      for (let u = 0, c = l.length, p = c - 1; u < c; p = u++) {
        const d = l[p], f = l[u];
        if (fr(i, s, d, f))
          return 0;
        a = Math.min(a, xn(i, s, d, f, n));
      }
  }
  return a;
}
function ta(r, e) {
  for (const t of r)
    for (const n of t)
      if (ut(n, e, !0))
        return !0;
  return !1;
}
function Nl(r, e, t, n = 1 / 0) {
  const a = Gr(r), o = Gr(e);
  if (n !== 1 / 0 && Sn(a, o, t) >= n)
    return n;
  if (St(a, o)) {
    if (ta(r, e))
      return 0;
  } else if (ta(e, r))
    return 0;
  let i = 1 / 0;
  for (const s of r)
    for (let l = 0, u = s.length, c = u - 1; l < u; c = l++) {
      const p = s[c], d = s[l];
      for (const f of e)
        for (let h = 0, m = f.length, y = m - 1; h < m; y = h++) {
          const b = f[y], v = f[h];
          if (fr(p, d, b, v))
            return 0;
          i = Math.min(i, xn(p, d, b, v, t));
        }
    }
  return i;
}
function ra(r, e, t, n, a, o) {
  if (!o)
    return;
  const i = Sn(Vr(n, o), a, t);
  i < e && r.push([i, o, [0, 0]]);
}
function Ot(r, e, t, n, a, o, i) {
  if (!o || !i)
    return;
  const s = Sn(Vr(n, o), Vr(a, i), t);
  s < e && r.push([s, o, i]);
}
function Zt(r, e, t, n, a = 1 / 0) {
  let o = Math.min(n.distance(r[0], t[0][0]), a);
  if (o === 0)
    return o;
  const i = new no([[0, [0, r.length - 1], [0, 0]]], ao), s = Gr(t);
  for (; i.length > 0; ) {
    const l = i.pop();
    if (l[0] >= o)
      continue;
    const u = l[1], c = e ? Br : Ur;
    if (Ht(u) <= c) {
      if (!Ee(u, r.length))
        return NaN;
      if (e) {
        const p = $l(r, u, t, n);
        if (isNaN(p) || p === 0)
          return p;
        o = Math.min(o, p);
      } else
        for (let p = u[0]; p <= u[1]; ++p) {
          const d = Fl(r[p], t, n);
          if (o = Math.min(o, d), o === 0)
            return 0;
        }
    } else {
      const p = qr(u, e);
      ra(i, o, n, r, s, p[0]), ra(i, o, n, r, s, p[1]);
    }
  }
  return o;
}
function Kt(r, e, t, n, a, o = 1 / 0) {
  let i = Math.min(o, a.distance(r[0], t[0]));
  if (i === 0)
    return i;
  const s = new no([[0, [0, r.length - 1], [0, t.length - 1]]], ao);
  for (; s.length > 0; ) {
    const l = s.pop();
    if (l[0] >= i)
      continue;
    const u = l[1], c = l[2], p = e ? Br : Ur, d = n ? Br : Ur;
    if (Ht(u) <= p && Ht(c) <= d) {
      if (!Ee(u, r.length) && Ee(c, t.length))
        return NaN;
      let f;
      if (e && n)
        f = zl(r, u, t, c, a), i = Math.min(i, f);
      else if (e && !n) {
        const h = r.slice(u[0], u[1] + 1);
        for (let m = c[0]; m <= c[1]; ++m)
          if (f = je(t[m], h, a), i = Math.min(i, f), i === 0)
            return i;
      } else if (!e && n) {
        const h = t.slice(c[0], c[1] + 1);
        for (let m = u[0]; m <= u[1]; ++m)
          if (f = je(r[m], h, a), i = Math.min(i, f), i === 0)
            return i;
      } else
        f = Ol(r, u, t, c, a), i = Math.min(i, f);
    } else {
      const f = qr(u, e), h = qr(c, n);
      Ot(s, i, a, r, t, f[0], h[0]), Ot(s, i, a, r, t, f[0], h[1]), Ot(s, i, a, r, t, f[1], h[0]), Ot(s, i, a, r, t, f[1], h[1]);
    }
  }
  return i;
}
function jl(r, e) {
  const t = r.geometry(), n = t.flat().map((i) => vn([i.x, i.y], r.canonical));
  if (t.length === 0)
    return NaN;
  const a = new wn(n[0][1]);
  let o = 1 / 0;
  for (const i of e) {
    switch (i.type) {
      case "Point":
        o = Math.min(o, Kt(n, !1, [i.coordinates], !1, a, o));
        break;
      case "LineString":
        o = Math.min(o, Kt(n, !1, i.coordinates, !0, a, o));
        break;
      case "Polygon":
        o = Math.min(o, Zt(n, !1, i.coordinates, a, o));
        break;
    }
    if (o === 0)
      return o;
  }
  return o;
}
function Dl(r, e) {
  const t = r.geometry(), n = t.flat().map((i) => vn([i.x, i.y], r.canonical));
  if (t.length === 0)
    return NaN;
  const a = new wn(n[0][1]);
  let o = 1 / 0;
  for (const i of e) {
    switch (i.type) {
      case "Point":
        o = Math.min(o, Kt(n, !0, [i.coordinates], !1, a, o));
        break;
      case "LineString":
        o = Math.min(o, Kt(n, !0, i.coordinates, !0, a, o));
        break;
      case "Polygon":
        o = Math.min(o, Zt(n, !0, i.coordinates, a, o));
        break;
    }
    if (o === 0)
      return o;
  }
  return o;
}
function Ul(r, e) {
  const t = r.geometry();
  if (t.length === 0 || t[0].length === 0)
    return NaN;
  const n = Ml(t).map((i) => i.map((s) => s.map((l) => vn([l.x, l.y], r.canonical)))), a = new wn(n[0][0][0][1]);
  let o = 1 / 0;
  for (const i of e)
    for (const s of n) {
      switch (i.type) {
        case "Point":
          o = Math.min(o, Zt([i.coordinates], !1, s, a, o));
          break;
        case "LineString":
          o = Math.min(o, Zt(i.coordinates, !0, s, a, o));
          break;
        case "Polygon":
          o = Math.min(o, Nl(s, i.coordinates, a, o));
          break;
      }
      if (o === 0)
        return o;
    }
  return o;
}
function Ar(r) {
  return r.type === "MultiPolygon" ? r.coordinates.map((e) => ({
    type: "Polygon",
    coordinates: e
  })) : r.type === "MultiLineString" ? r.coordinates.map((e) => ({
    type: "LineString",
    coordinates: e
  })) : r.type === "MultiPoint" ? r.coordinates.map((e) => ({
    type: "Point",
    coordinates: e
  })) : [r];
}
class Ve {
  constructor(e, t) {
    this.type = S, this.geojson = e, this.geometries = t;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`'distance' expression requires exactly one argument, but found ${e.length - 1} instead.`);
    if (bt(e[1])) {
      const n = e[1];
      if (n.type === "FeatureCollection")
        return new Ve(n, n.features.map((a) => Ar(a.geometry)).flat());
      if (n.type === "Feature")
        return new Ve(n, Ar(n.geometry));
      if ("type" in n && "coordinates" in n)
        return new Ve(n, Ar(n));
    }
    return t.error("'distance' expression requires valid geojson object that contains polygon geometry type.");
  }
  evaluate(e) {
    if (e.geometry() != null && e.canonicalID() != null) {
      if (e.geometryType() === "Point")
        return jl(e, this.geometries);
      if (e.geometryType() === "LineString")
        return Dl(e, this.geometries);
      if (e.geometryType() === "Polygon")
        return Ul(e, this.geometries);
    }
    return NaN;
  }
  eachChild() {
  }
  outputDefined() {
    return !0;
  }
}
class It {
  constructor(e) {
    this.type = I, this.key = e;
  }
  static parse(e, t) {
    if (e.length !== 2)
      return t.error(`Expected 1 argument, but found ${e.length - 1} instead.`);
    const n = e[1];
    return n == null ? t.error("Global state property must be defined.") : typeof n != "string" ? t.error(`Global state property must be string, but found ${typeof e[1]} instead.`) : new It(n);
  }
  evaluate(e) {
    var t;
    const n = (t = e.globals) === null || t === void 0 ? void 0 : t.globalState;
    return !n || Object.keys(n).length === 0 ? null : dt(n, this.key);
  }
  eachChild() {
  }
  outputDefined() {
    return !1;
  }
}
const kn = {
  // special forms
  "==": pl,
  "!=": fl,
  ">": hl,
  "<": dl,
  ">=": yl,
  "<=": ml,
  array: pe,
  at: cn,
  boolean: pe,
  case: dn,
  coalesce: wt,
  collator: pr,
  format: mn,
  image: yn,
  in: pn,
  "index-of": Vt,
  interpolate: Se,
  "interpolate-hcl": Se,
  "interpolate-lab": Se,
  length: gn,
  let: lr,
  literal: ot,
  match: fn,
  number: pe,
  "number-format": hn,
  object: pe,
  slice: Gt,
  step: cr,
  string: pe,
  "to-boolean": Re,
  "to-color": Re,
  "to-number": Re,
  "to-string": Re,
  var: ur,
  within: qe,
  distance: Ve,
  "global-state": It
};
class he {
  constructor(e, t, n, a) {
    this.name = e, this.type = t, this._evaluate = n, this.args = a;
  }
  evaluate(e) {
    return this._evaluate(e, this.args);
  }
  eachChild(e) {
    this.args.forEach(e);
  }
  outputDefined() {
    return !1;
  }
  static parse(e, t) {
    const n = e[0], a = he.definitions[n];
    if (!a)
      return t.error(`Unknown expression "${n}". If you wanted a literal array, use ["literal", [...]].`, 0);
    const o = Array.isArray(a) ? a[0] : a.type, i = Array.isArray(a) ? [[a[1], a[2]]] : a.overloads, s = i.filter(([u]) => !Array.isArray(u) || // varags
    u.length === e.length - 1);
    let l = null;
    for (const [u, c] of s) {
      l = new sr(t.registry, Xt, t.path, null, t.scope);
      const p = [];
      let d = !1;
      for (let f = 1; f < e.length; f++) {
        const h = e[f], m = Array.isArray(u) ? u[f - 1] : u.type, y = l.parse(h, 1 + p.length, m);
        if (!y) {
          d = !0;
          break;
        }
        p.push(y);
      }
      if (!d) {
        if (Array.isArray(u) && u.length !== p.length) {
          l.error(`Expected ${u.length} arguments, but found ${p.length} instead.`);
          continue;
        }
        for (let f = 0; f < p.length; f++) {
          const h = Array.isArray(u) ? u[f] : u.type, m = p[f];
          l.concat(f + 1).checkSubtype(h, m.type);
        }
        if (l.errors.length === 0)
          return new he(n, o, c, p);
      }
    }
    if (s.length === 1)
      t.errors.push(...l.errors);
    else {
      const c = (s.length ? s : i).map(([d]) => ql(d)).join(" | "), p = [];
      for (let d = 1; d < e.length; d++) {
        const f = t.parse(e[d], 1 + p.length);
        if (!f)
          return null;
        p.push(D(f.type));
      }
      t.error(`Expected arguments of type ${c}, but found (${p.join(", ")}) instead.`);
    }
    return null;
  }
  static register(e, t) {
    he.definitions = t;
    for (const n in t)
      e[n] = he;
  }
}
function na(r, [e, t, n, a]) {
  e = e.evaluate(r), t = t.evaluate(r), n = n.evaluate(r);
  const o = a ? a.evaluate(r) : 1, i = Xa(e, t, n, o);
  if (i)
    throw new V(i);
  return new $(e / 255, t / 255, n / 255, o, !1);
}
function aa(r, e) {
  return r in e;
}
function Tr(r, e) {
  const t = e[r];
  return typeof t > "u" ? null : t;
}
function Bl(r, e, t, n) {
  for (; t <= n; ) {
    const a = t + n >> 1;
    if (e[a] === r)
      return !0;
    e[a] > r ? n = a - 1 : t = a + 1;
  }
  return !1;
}
function $e(r) {
  return { type: r };
}
he.register(kn, {
  error: [
    Fs,
    [P],
    (r, [e]) => {
      throw new V(e.evaluate(r));
    }
  ],
  typeof: [
    P,
    [I],
    (r, [e]) => D(H(e.evaluate(r)))
  ],
  "to-rgba": [
    ae(S, 4),
    [be],
    (r, [e]) => {
      const [t, n, a, o] = e.evaluate(r).rgb;
      return [t * 255, n * 255, a * 255, o];
    }
  ],
  rgb: [
    be,
    [S, S, S],
    na
  ],
  rgba: [
    be,
    [S, S, S, S],
    na
  ],
  has: {
    type: M,
    overloads: [
      [
        [P],
        (r, [e]) => aa(e.evaluate(r), r.properties())
      ],
      [
        [P, De],
        (r, [e, t]) => aa(e.evaluate(r), t.evaluate(r))
      ]
    ]
  },
  get: {
    type: I,
    overloads: [
      [
        [P],
        (r, [e]) => Tr(e.evaluate(r), r.properties())
      ],
      [
        [P, De],
        (r, [e, t]) => Tr(e.evaluate(r), t.evaluate(r))
      ]
    ]
  },
  "feature-state": [
    I,
    [P],
    (r, [e]) => Tr(e.evaluate(r), r.featureState || {})
  ],
  properties: [
    De,
    [],
    (r) => r.properties()
  ],
  "geometry-type": [
    P,
    [],
    (r) => r.geometryType()
  ],
  id: [
    I,
    [],
    (r) => r.id()
  ],
  zoom: [
    S,
    [],
    (r) => r.globals.zoom
  ],
  "heatmap-density": [
    S,
    [],
    (r) => r.globals.heatmapDensity || 0
  ],
  elevation: [
    S,
    [],
    (r) => r.globals.elevation || 0
  ],
  "line-progress": [
    S,
    [],
    (r) => r.globals.lineProgress || 0
  ],
  accumulated: [
    I,
    [],
    (r) => r.globals.accumulated === void 0 ? null : r.globals.accumulated
  ],
  "+": [
    S,
    $e(S),
    (r, e) => {
      let t = 0;
      for (const n of e)
        t += n.evaluate(r);
      return t;
    }
  ],
  "*": [
    S,
    $e(S),
    (r, e) => {
      let t = 1;
      for (const n of e)
        t *= n.evaluate(r);
      return t;
    }
  ],
  "-": {
    type: S,
    overloads: [
      [
        [S, S],
        (r, [e, t]) => e.evaluate(r) - t.evaluate(r)
      ],
      [
        [S],
        (r, [e]) => -e.evaluate(r)
      ]
    ]
  },
  "/": [
    S,
    [S, S],
    (r, [e, t]) => e.evaluate(r) / t.evaluate(r)
  ],
  "%": [
    S,
    [S, S],
    (r, [e, t]) => e.evaluate(r) % t.evaluate(r)
  ],
  ln2: [
    S,
    [],
    () => Math.LN2
  ],
  pi: [
    S,
    [],
    () => Math.PI
  ],
  e: [
    S,
    [],
    () => Math.E
  ],
  "^": [
    S,
    [S, S],
    (r, [e, t]) => Math.pow(e.evaluate(r), t.evaluate(r))
  ],
  sqrt: [
    S,
    [S],
    (r, [e]) => Math.sqrt(e.evaluate(r))
  ],
  log10: [
    S,
    [S],
    (r, [e]) => Math.log(e.evaluate(r)) / Math.LN10
  ],
  ln: [
    S,
    [S],
    (r, [e]) => Math.log(e.evaluate(r))
  ],
  log2: [
    S,
    [S],
    (r, [e]) => Math.log(e.evaluate(r)) / Math.LN2
  ],
  sin: [
    S,
    [S],
    (r, [e]) => Math.sin(e.evaluate(r))
  ],
  cos: [
    S,
    [S],
    (r, [e]) => Math.cos(e.evaluate(r))
  ],
  tan: [
    S,
    [S],
    (r, [e]) => Math.tan(e.evaluate(r))
  ],
  asin: [
    S,
    [S],
    (r, [e]) => Math.asin(e.evaluate(r))
  ],
  acos: [
    S,
    [S],
    (r, [e]) => Math.acos(e.evaluate(r))
  ],
  atan: [
    S,
    [S],
    (r, [e]) => Math.atan(e.evaluate(r))
  ],
  min: [
    S,
    $e(S),
    (r, e) => Math.min(...e.map((t) => t.evaluate(r)))
  ],
  max: [
    S,
    $e(S),
    (r, e) => Math.max(...e.map((t) => t.evaluate(r)))
  ],
  abs: [
    S,
    [S],
    (r, [e]) => Math.abs(e.evaluate(r))
  ],
  round: [
    S,
    [S],
    (r, [e]) => {
      const t = e.evaluate(r);
      return t < 0 ? -Math.round(-t) : Math.round(t);
    }
  ],
  floor: [
    S,
    [S],
    (r, [e]) => Math.floor(e.evaluate(r))
  ],
  ceil: [
    S,
    [S],
    (r, [e]) => Math.ceil(e.evaluate(r))
  ],
  "filter-==": [
    M,
    [P, I],
    (r, [e, t]) => r.properties()[e.value] === t.value
  ],
  "filter-id-==": [
    M,
    [I],
    (r, [e]) => r.id() === e.value
  ],
  "filter-type-==": [
    M,
    [P],
    (r, [e]) => r.geometryType() === e.value
  ],
  "filter-<": [
    M,
    [P, I],
    (r, [e, t]) => {
      const n = r.properties()[e.value], a = t.value;
      return typeof n == typeof a && n < a;
    }
  ],
  "filter-id-<": [
    M,
    [I],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t < n;
    }
  ],
  "filter->": [
    M,
    [P, I],
    (r, [e, t]) => {
      const n = r.properties()[e.value], a = t.value;
      return typeof n == typeof a && n > a;
    }
  ],
  "filter-id->": [
    M,
    [I],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t > n;
    }
  ],
  "filter-<=": [
    M,
    [P, I],
    (r, [e, t]) => {
      const n = r.properties()[e.value], a = t.value;
      return typeof n == typeof a && n <= a;
    }
  ],
  "filter-id-<=": [
    M,
    [I],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t <= n;
    }
  ],
  "filter->=": [
    M,
    [P, I],
    (r, [e, t]) => {
      const n = r.properties()[e.value], a = t.value;
      return typeof n == typeof a && n >= a;
    }
  ],
  "filter-id->=": [
    M,
    [I],
    (r, [e]) => {
      const t = r.id(), n = e.value;
      return typeof t == typeof n && t >= n;
    }
  ],
  "filter-has": [
    M,
    [I],
    (r, [e]) => e.value in r.properties()
  ],
  "filter-has-id": [
    M,
    [],
    (r) => r.id() !== null && r.id() !== void 0
  ],
  "filter-type-in": [
    M,
    [ae(P)],
    (r, [e]) => e.value.indexOf(r.geometryType()) >= 0
  ],
  "filter-id-in": [
    M,
    [ae(I)],
    (r, [e]) => e.value.indexOf(r.id()) >= 0
  ],
  "filter-in-small": [
    M,
    [P, ae(I)],
    // assumes v is an array literal
    (r, [e, t]) => t.value.indexOf(r.properties()[e.value]) >= 0
  ],
  "filter-in-large": [
    M,
    [P, ae(I)],
    // assumes v is a array literal with values sorted in ascending order and of a single type
    (r, [e, t]) => Bl(r.properties()[e.value], t.value, 0, t.value.length - 1)
  ],
  all: {
    type: M,
    overloads: [
      [
        [M, M],
        (r, [e, t]) => e.evaluate(r) && t.evaluate(r)
      ],
      [
        $e(M),
        (r, e) => {
          for (const t of e)
            if (!t.evaluate(r))
              return !1;
          return !0;
        }
      ]
    ]
  },
  any: {
    type: M,
    overloads: [
      [
        [M, M],
        (r, [e, t]) => e.evaluate(r) || t.evaluate(r)
      ],
      [
        $e(M),
        (r, e) => {
          for (const t of e)
            if (t.evaluate(r))
              return !0;
          return !1;
        }
      ]
    ]
  },
  "!": [
    M,
    [M],
    (r, [e]) => !e.evaluate(r)
  ],
  "is-supported-script": [
    M,
    [P],
    // At parse time this will always return true, so we need to exclude this expression with isGlobalPropertyConstant
    (r, [e]) => {
      const t = r.globals && r.globals.isSupportedScript;
      return t ? t(e.evaluate(r)) : !0;
    }
  ],
  upcase: [
    P,
    [P],
    (r, [e]) => e.evaluate(r).toUpperCase()
  ],
  downcase: [
    P,
    [P],
    (r, [e]) => e.evaluate(r).toLowerCase()
  ],
  concat: [
    P,
    $e(I),
    (r, e) => e.map((t) => ht(t.evaluate(r))).join("")
  ],
  "resolved-locale": [
    P,
    [rr],
    (r, [e]) => e.evaluate(r).resolvedLocale()
  ]
});
function ql(r) {
  return Array.isArray(r) ? `(${r.map(D).join(", ")})` : `(${D(r.type)}...)`;
}
function Xt(r) {
  if (r instanceof ur)
    return Xt(r.boundExpression);
  if (r instanceof he && r.name === "error")
    return !1;
  if (r instanceof pr)
    return !1;
  if (r instanceof qe)
    return !1;
  if (r instanceof Ve)
    return !1;
  if (r instanceof It)
    return !1;
  const e = r instanceof Re || r instanceof pe;
  let t = !0;
  return r.eachChild((n) => {
    e ? t = t && Xt(n) : t = t && n instanceof ot;
  }), t ? dr(r) && hr(r, ["zoom", "heatmap-density", "elevation", "line-progress", "accumulated", "is-supported-script"]) : !1;
}
function dr(r) {
  if (r instanceof he) {
    if (r.name === "get" && r.args.length === 1)
      return !1;
    if (r.name === "feature-state")
      return !1;
    if (r.name === "has" && r.args.length === 1)
      return !1;
    if (r.name === "properties" || r.name === "geometry-type" || r.name === "id")
      return !1;
    if (/^filter-/.test(r.name))
      return !1;
  }
  if (r instanceof qe || r instanceof Ve)
    return !1;
  let e = !0;
  return r.eachChild((t) => {
    e && !dr(t) && (e = !1);
  }), e;
}
function xt(r) {
  if (r instanceof he && r.name === "feature-state")
    return !1;
  let e = !0;
  return r.eachChild((t) => {
    e && !xt(t) && (e = !1);
  }), e;
}
function hr(r, e) {
  if (r instanceof he && e.indexOf(r.name) >= 0)
    return !1;
  let t = !0;
  return r.eachChild((n) => {
    t && !hr(n, e) && (t = !1);
  }), t;
}
function Hr(r) {
  return { result: "success", value: r };
}
function et(r) {
  return { result: "error", value: r };
}
function Yt(r) {
  return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven";
}
function oo(r) {
  return !!r.expression && r.expression.parameters.indexOf("zoom") > -1;
}
function io(r) {
  return !!r.expression && r.expression.interpolated;
}
function R(r) {
  return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r;
}
function Ln(r) {
  return typeof r == "object" && r !== null && !Array.isArray(r) && H(r) === De;
}
class Vl {
  constructor(e, t, n) {
    this.expression = e, this._warningHistory = {}, this._evaluator = new Ya(), this._defaultValue = t ? Zl(t) : null, this._enumValues = t && t.type === "enum" ? t.values : null, this._globalState = n;
  }
  evaluateWithoutErrorHandling(e, t, n, a, o, i) {
    return this._globalState && (e = it(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = t, this._evaluator.featureState = n, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i, this.expression.evaluate(this._evaluator);
  }
  evaluate(e, t, n, a, o, i) {
    this._globalState && (e = it(e, this._globalState)), this._evaluator.globals = e, this._evaluator.feature = t || null, this._evaluator.featureState = n || null, this._evaluator.canonical = a, this._evaluator.availableImages = o || null, this._evaluator.formattedSection = i || null;
    try {
      const s = this.expression.evaluate(this._evaluator);
      if (s == null || typeof s == "number" && s !== s)
        return this._defaultValue;
      if (this._enumValues && !(s in this._enumValues))
        throw new V(`Expected value to be one of ${Object.keys(this._enumValues).map((l) => JSON.stringify(l)).join(", ")}, but found ${JSON.stringify(s)} instead.`);
      return s;
    } catch (s) {
      return this._warningHistory[s.message] || (this._warningHistory[s.message] = !0, typeof console < "u" && console.warn(s.message)), this._defaultValue;
    }
  }
}
function so(r) {
  return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0] in kn;
}
function lo(r, e, t) {
  const n = new sr(kn, Xt, [], e ? Hl(e) : void 0), a = n.parse(r, void 0, void 0, void 0, e && e.type === "string" ? { typeAnnotation: "coerce" } : void 0);
  return a ? Hr(new Vl(a, e, t)) : et(n.errors);
}
class oa {
  constructor(e, t, n) {
    this.kind = e, this._styleExpression = t, this.isStateDependent = e !== "constant" && !xt(t.expression), this.globalStateRefs = Cn(t.expression), this._globalState = n;
  }
  evaluateWithoutErrorHandling(e, t, n, a, o, i) {
    return this._globalState && (e = it(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
  }
  evaluate(e, t, n, a, o, i) {
    return this._globalState && (e = it(e, this._globalState)), this._styleExpression.evaluate(e, t, n, a, o, i);
  }
}
class ia {
  constructor(e, t, n, a, o) {
    this.kind = e, this.zoomStops = n, this._styleExpression = t, this.isStateDependent = e !== "camera" && !xt(t.expression), this.globalStateRefs = Cn(t.expression), this.interpolationType = a, this._globalState = o;
  }
  evaluateWithoutErrorHandling(e, t, n, a, o, i) {
    return this._globalState && (e = it(e, this._globalState)), this._styleExpression.evaluateWithoutErrorHandling(e, t, n, a, o, i);
  }
  evaluate(e, t, n, a, o, i) {
    return this._globalState && (e = it(e, this._globalState)), this._styleExpression.evaluate(e, t, n, a, o, i);
  }
  interpolationFactor(e, t, n) {
    return this.interpolationType ? Se.interpolationFactor(this.interpolationType, e, t, n) : 0;
  }
}
function Gl(r, e, t) {
  const n = lo(r, e, t);
  if (n.result === "error")
    return n;
  const a = n.value.expression, o = dr(a);
  if (!o && !Yt(e))
    return et([new ve("", "data expressions not supported")]);
  const i = hr(a, ["zoom"]);
  if (!i && !oo(e))
    return et([new ve("", "zoom expressions not supported")]);
  const s = jt(a);
  if (!s && !i)
    return et([new ve("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
  if (s instanceof ve)
    return et([s]);
  if (s instanceof Se && !io(e))
    return et([new ve("", '"interpolate" expressions cannot be used with this property')]);
  if (!s)
    return Hr(o ? new oa("constant", n.value, t) : new oa("source", n.value, t));
  const l = s instanceof Se ? s.interpolation : void 0;
  return Hr(o ? new ia("camera", n.value, s.labels, l, t) : new ia("composite", n.value, s.labels, l, t));
}
function jt(r) {
  let e = null;
  if (r instanceof lr)
    e = jt(r.result);
  else if (r instanceof wt) {
    for (const t of r.args)
      if (e = jt(t), e)
        break;
  } else (r instanceof cr || r instanceof Se) && r.input instanceof he && r.input.name === "zoom" && (e = r);
  return e instanceof ve || r.eachChild((t) => {
    const n = jt(t);
    n instanceof ve ? e = n : !e && n ? e = new ve("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e && n && e !== n && (e = new ve("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
  }), e;
}
function Cn(r, e = /* @__PURE__ */ new Set()) {
  return r instanceof It && e.add(r.key), r.eachChild((t) => {
    Cn(t, e);
  }), e;
}
function Hl(r) {
  const e = {
    color: be,
    string: P,
    number: S,
    enum: P,
    boolean: M,
    formatted: nr,
    padding: ar,
    numberArray: or,
    colorArray: yt,
    projectionDefinition: tr,
    resolvedImage: Tt,
    variableAnchorOffsetCollection: ir
  };
  return r.type === "array" ? ae(e[r.value] || I, r.length) : e[r.type];
}
function Zl(r) {
  if (r.type === "color" && Ln(r.default))
    return new $(0, 0, 0, 0);
  switch (r.type) {
    case "color":
      return $.parse(r.default) || null;
    case "padding":
      return fe.parse(r.default) || null;
    case "numberArray":
      return de.parse(r.default) || null;
    case "colorArray":
      return oe.parse(r.default) || null;
    case "variableAnchorOffsetCollection":
      return we.parse(r.default) || null;
    case "projectionDefinition":
      return ce.parse(r.default) || null;
    default:
      return r.default === void 0 ? null : r.default;
  }
}
function it(r, e) {
  const { zoom: t, heatmapDensity: n, elevation: a, lineProgress: o, isSupportedScript: i, accumulated: s } = r ?? {};
  return {
    zoom: t,
    heatmapDensity: n,
    elevation: a,
    lineProgress: o,
    isSupportedScript: i,
    accumulated: s,
    globalState: e
  };
}
function uo(r) {
  if (r === !0 || r === !1)
    return !0;
  if (!Array.isArray(r) || r.length === 0)
    return !1;
  switch (r[0]) {
    case "has":
      return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
    case "in":
      return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
    case "!in":
    case "!has":
    case "none":
      return !1;
    case "==":
    case "!=":
    case ">":
    case ">=":
    case "<":
    case "<=":
      return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
    case "any":
    case "all":
      for (const e of r.slice(1))
        if (!uo(e) && typeof e != "boolean")
          return !1;
      return !0;
    default:
      return !0;
  }
}
function co(r) {
  const e = r.key, t = r.value;
  return t ? [new w(e, t, "constants have been deprecated as of v8")] : [];
}
function G(r) {
  return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r;
}
function Ze(r) {
  if (Array.isArray(r))
    return r.map(Ze);
  if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
    const e = {};
    for (const t in r)
      e[t] = Ze(r[t]);
    return e;
  }
  return G(r);
}
function le(r) {
  const e = r.key, t = r.value, n = r.valueSpec || {}, a = r.objectElementValidators || {}, o = r.style, i = r.styleSpec, s = r.validateSpec;
  let l = [];
  const u = R(t);
  if (u !== "object")
    return [new w(e, t, `object expected, ${u} found`)];
  for (const c in t) {
    const p = c.split(".")[0], d = dt(n, p) || n["*"];
    let f;
    if (dt(a, p))
      f = a[p];
    else if (dt(n, p))
      f = s;
    else if (a["*"])
      f = a["*"];
    else if (n["*"])
      f = s;
    else {
      l.push(new w(e, t[c], `unknown property "${c}"`));
      continue;
    }
    l = l.concat(f({
      key: (e && `${e}.`) + c,
      value: t[c],
      valueSpec: d,
      style: o,
      styleSpec: i,
      object: t,
      objectKey: c,
      validateSpec: s
    }, t));
  }
  for (const c in n)
    a[c] || n[c].required && n[c].default === void 0 && t[c] === void 0 && l.push(new w(e, t, `missing required property "${c}"`));
  return l;
}
function En(r) {
  const e = r.value, t = r.valueSpec, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.key, s = r.arrayElementValidator || n;
  if (R(e) !== "array")
    return [new w(i, e, `array expected, ${R(e)} found`)];
  if (t.length && e.length !== t.length)
    return [new w(i, e, `array length ${t.length} expected, length ${e.length} found`)];
  if (t["min-length"] && e.length < t["min-length"])
    return [new w(i, e, `array length at least ${t["min-length"]} expected, length ${e.length} found`)];
  let l = {
    type: t.value,
    values: t.values
  };
  o.$version < 7 && (l.function = t.function), R(t.value) === "object" && (l = t.value);
  let u = [];
  for (let c = 0; c < e.length; c++)
    u = u.concat(s({
      array: e,
      arrayIndex: c,
      value: e[c],
      valueSpec: l,
      validateSpec: r.validateSpec,
      style: a,
      styleSpec: o,
      key: `${i}[${c}]`
    }));
  return u;
}
function mr(r) {
  const e = r.key, t = r.value, n = r.valueSpec;
  let a = R(t);
  return a === "number" && t !== t && (a = "NaN"), a !== "number" ? [new w(e, t, `number expected, ${a} found`)] : "minimum" in n && t < n.minimum ? [new w(e, t, `${t} is less than the minimum value ${n.minimum}`)] : "maximum" in n && t > n.maximum ? [new w(e, t, `${t} is greater than the maximum value ${n.maximum}`)] : [];
}
function po(r) {
  const e = r.valueSpec, t = G(r.value.type);
  let n, a = {}, o, i;
  const s = t !== "categorical" && r.value.property === void 0, l = !s, u = R(r.value.stops) === "array" && R(r.value.stops[0]) === "array" && R(r.value.stops[0][0]) === "object", c = le({
    key: r.key,
    value: r.value,
    valueSpec: r.styleSpec.function,
    validateSpec: r.validateSpec,
    style: r.style,
    styleSpec: r.styleSpec,
    objectElementValidators: {
      stops: p,
      default: h
    }
  });
  return t === "identity" && s && c.push(new w(r.key, r.value, 'missing required property "property"')), t !== "identity" && !r.value.stops && c.push(new w(r.key, r.value, 'missing required property "stops"')), t === "exponential" && r.valueSpec.expression && !io(r.valueSpec) && c.push(new w(r.key, r.value, "exponential functions not supported")), r.styleSpec.$version >= 8 && (l && !Yt(r.valueSpec) ? c.push(new w(r.key, r.value, "property functions not supported")) : s && !oo(r.valueSpec) && c.push(new w(r.key, r.value, "zoom functions not supported"))), (t === "categorical" || u) && r.value.property === void 0 && c.push(new w(r.key, r.value, '"property" property is required')), c;
  function p(m) {
    if (t === "identity")
      return [new w(m.key, m.value, 'identity function may not have a "stops" property')];
    let y = [];
    const b = m.value;
    return y = y.concat(En({
      key: m.key,
      value: b,
      valueSpec: m.valueSpec,
      validateSpec: m.validateSpec,
      style: m.style,
      styleSpec: m.styleSpec,
      arrayElementValidator: d
    })), R(b) === "array" && b.length === 0 && y.push(new w(m.key, b, "array must have at least one stop")), y;
  }
  function d(m) {
    let y = [];
    const b = m.value, v = m.key;
    if (R(b) !== "array")
      return [new w(v, b, `array expected, ${R(b)} found`)];
    if (b.length !== 2)
      return [new w(v, b, `array length 2 expected, length ${b.length} found`)];
    if (u) {
      if (R(b[0]) !== "object")
        return [new w(v, b, `object expected, ${R(b[0])} found`)];
      if (b[0].zoom === void 0)
        return [new w(v, b, "object stop key must have zoom")];
      if (b[0].value === void 0)
        return [new w(v, b, "object stop key must have value")];
      if (i && i > G(b[0].zoom))
        return [new w(v, b[0].zoom, "stop zoom values must appear in ascending order")];
      G(b[0].zoom) !== i && (i = G(b[0].zoom), o = void 0, a = {}), y = y.concat(le({
        key: `${v}[0]`,
        value: b[0],
        valueSpec: { zoom: {} },
        validateSpec: m.validateSpec,
        style: m.style,
        styleSpec: m.styleSpec,
        objectElementValidators: { zoom: mr, value: f }
      }));
    } else
      y = y.concat(f({
        key: `${v}[0]`,
        value: b[0],
        validateSpec: m.validateSpec,
        style: m.style,
        styleSpec: m.styleSpec
      }, b));
    return so(Ze(b[1])) ? y.concat([new w(`${v}[1]`, b[1], "expressions are not allowed in function stops.")]) : y.concat(m.validateSpec({
      key: `${v}[1]`,
      value: b[1],
      valueSpec: e,
      validateSpec: m.validateSpec,
      style: m.style,
      styleSpec: m.styleSpec
    }));
  }
  function f(m, y) {
    const b = R(m.value), v = G(m.value), x = m.value !== null ? m.value : y;
    if (!n)
      n = b;
    else if (b !== n)
      return [new w(m.key, x, `${b} stop domain type must match previous stop domain type ${n}`)];
    if (b !== "number" && b !== "string" && b !== "boolean")
      return [new w(m.key, x, "stop domain value must be a number, string, or boolean")];
    if (b !== "number" && t !== "categorical") {
      let E = `number expected, ${b} found`;
      return Yt(e) && t === void 0 && (E += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new w(m.key, x, E)];
    }
    return t === "categorical" && b === "number" && (!isFinite(v) || Math.floor(v) !== v) ? [new w(m.key, x, `integer expected, found ${v}`)] : t !== "categorical" && b === "number" && o !== void 0 && v < o ? [new w(m.key, x, "stop domain values must appear in ascending order")] : (o = v, t === "categorical" && v in a ? [new w(m.key, x, "stop domain values must be unique")] : (a[v] = !0, []));
  }
  function h(m) {
    return m.validateSpec({
      key: m.key,
      value: m.value,
      valueSpec: e,
      validateSpec: m.validateSpec,
      style: m.style,
      styleSpec: m.styleSpec
    });
  }
}
function st(r) {
  const e = (r.expressionContext === "property" ? Gl : lo)(Ze(r.value), r.valueSpec);
  if (e.result === "error")
    return e.value.map((n) => new w(`${r.key}${n.key}`, r.value, n.message));
  const t = e.value.expression || e.value._styleExpression.expression;
  if (r.expressionContext === "property" && r.propertyKey === "text-font" && !t.outputDefined())
    return [new w(r.key, r.value, `Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`)];
  if (r.expressionContext === "property" && r.propertyType === "layout" && !xt(t))
    return [new w(r.key, r.value, '"feature-state" data expressions are not supported with layout properties.')];
  if (r.expressionContext === "filter" && !xt(t))
    return [new w(r.key, r.value, '"feature-state" data expressions are not supported with filters.')];
  if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
    if (!hr(t, ["zoom", "feature-state"]))
      return [new w(r.key, r.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
    if (r.expressionContext === "cluster-initial" && !dr(t))
      return [new w(r.key, r.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
  }
  return [];
}
function Kl(r) {
  const e = r.value, t = r.key, n = R(e);
  return n !== "boolean" ? [new w(t, e, `boolean expected, ${n} found`)] : [];
}
function Zr(r) {
  const e = r.key, t = r.value, n = R(t);
  return n !== "string" ? [new w(e, t, `color expected, ${n} found`)] : $.parse(String(t)) ? [] : [new w(e, t, `color expected, "${t}" found`)];
}
function kt(r) {
  const e = r.key, t = r.value, n = r.valueSpec, a = [];
  return Array.isArray(n.values) ? n.values.indexOf(G(t)) === -1 && a.push(new w(e, t, `expected one of [${n.values.join(", ")}], ${JSON.stringify(t)} found`)) : Object.keys(n.values).indexOf(G(t)) === -1 && a.push(new w(e, t, `expected one of [${Object.keys(n.values).join(", ")}], ${JSON.stringify(t)} found`)), a;
}
function An(r) {
  return uo(Ze(r.value)) ? st(qt({}, r, {
    expressionContext: "filter",
    valueSpec: { value: "boolean" }
  })) : fo(r);
}
function fo(r) {
  const e = r.value, t = r.key;
  if (R(e) !== "array")
    return [new w(t, e, `array expected, ${R(e)} found`)];
  const n = r.styleSpec;
  let a, o = [];
  if (e.length < 1)
    return [new w(t, e, "filter array must have at least 1 element")];
  switch (o = o.concat(kt({
    key: `${t}[0]`,
    value: e[0],
    valueSpec: n.filter_operator,
    style: r.style,
    styleSpec: r.styleSpec
  })), G(e[0])) {
    case "<":
    case "<=":
    case ">":
    case ">=":
      e.length >= 2 && G(e[1]) === "$type" && o.push(new w(t, e, `"$type" cannot be use with operator "${e[0]}"`));
    /* falls through */
    case "==":
    case "!=":
      e.length !== 3 && o.push(new w(t, e, `filter array for operator "${e[0]}" must have 3 elements`));
    /* falls through */
    case "in":
    case "!in":
      e.length >= 2 && (a = R(e[1]), a !== "string" && o.push(new w(`${t}[1]`, e[1], `string expected, ${a} found`)));
      for (let i = 2; i < e.length; i++)
        a = R(e[i]), G(e[1]) === "$type" ? o = o.concat(kt({
          key: `${t}[${i}]`,
          value: e[i],
          valueSpec: n.geometry_type,
          style: r.style,
          styleSpec: r.styleSpec
        })) : a !== "string" && a !== "number" && a !== "boolean" && o.push(new w(`${t}[${i}]`, e[i], `string, number, or boolean expected, ${a} found`));
      break;
    case "any":
    case "all":
    case "none":
      for (let i = 1; i < e.length; i++)
        o = o.concat(fo({
          key: `${t}[${i}]`,
          value: e[i],
          style: r.style,
          styleSpec: r.styleSpec
        }));
      break;
    case "has":
    case "!has":
      a = R(e[1]), e.length !== 2 ? o.push(new w(t, e, `filter array for "${e[0]}" operator must have 2 elements`)) : a !== "string" && o.push(new w(`${t}[1]`, e[1], `string expected, ${a} found`));
      break;
  }
  return o;
}
function ho(r, e) {
  const t = r.key, n = r.validateSpec, a = r.style, o = r.styleSpec, i = r.value, s = r.objectKey, l = o[`${e}_${r.layerType}`];
  if (!l)
    return [];
  const u = s.match(/^(.*)-transition$/);
  if (e === "paint" && u && l[u[1]] && l[u[1]].transition)
    return n({
      key: t,
      value: i,
      valueSpec: o.transition,
      style: a,
      styleSpec: o
    });
  const c = r.valueSpec || l[s];
  if (!c)
    return [new w(t, i, `unknown property "${s}"`)];
  let p;
  if (R(i) === "string" && Yt(c) && !c.tokens && (p = /^{([^}]+)}$/.exec(i)))
    return [new w(t, i, `"${s}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(p[1])} }\`.`)];
  const d = [];
  return r.layerType === "symbol" && s === "text-font" && Ln(Ze(i)) && G(i.type) === "identity" && d.push(new w(t, i, '"text-font" does not support identity functions')), d.concat(n({
    key: r.key,
    value: i,
    valueSpec: c,
    style: a,
    styleSpec: o,
    expressionContext: "property",
    propertyType: e,
    propertyKey: s
  }));
}
function mo(r) {
  return ho(r, "paint");
}
function yo(r) {
  return ho(r, "layout");
}
function go(r) {
  let e = [];
  const t = r.value, n = r.key, a = r.style, o = r.styleSpec;
  if (R(t) !== "object")
    return [new w(n, t, `object expected, ${R(t)} found`)];
  !t.type && !t.ref && e.push(new w(n, t, 'either "type" or "ref" is required'));
  let i = G(t.type);
  const s = G(t.ref);
  if (t.id) {
    const l = G(t.id);
    for (let u = 0; u < r.arrayIndex; u++) {
      const c = a.layers[u];
      G(c.id) === l && e.push(new w(n, t.id, `duplicate layer id "${t.id}", previously used at line ${c.id.__line__}`));
    }
  }
  if ("ref" in t) {
    ["type", "source", "source-layer", "filter", "layout"].forEach((u) => {
      u in t && e.push(new w(n, t[u], `"${u}" is prohibited for ref layers`));
    });
    let l;
    a.layers.forEach((u) => {
      G(u.id) === s && (l = u);
    }), l ? l.ref ? e.push(new w(n, t.ref, "ref cannot reference another ref layer")) : i = G(l.type) : e.push(new w(n, t.ref, `ref layer "${s}" not found`));
  } else if (i !== "background")
    if (!t.source)
      e.push(new w(n, t, 'missing required property "source"'));
    else {
      const l = a.sources && a.sources[t.source], u = l && G(l.type);
      l ? u === "vector" && i === "raster" ? e.push(new w(n, t.source, `layer "${t.id}" requires a raster source`)) : u !== "raster-dem" && i === "hillshade" ? e.push(new w(n, t.source, `layer "${t.id}" requires a raster-dem source`)) : u !== "raster-dem" && i === "color-relief" ? e.push(new w(n, t.source, `layer "${t.id}" requires a raster-dem source`)) : u === "raster" && i !== "raster" ? e.push(new w(n, t.source, `layer "${t.id}" requires a vector source`)) : u === "vector" && !t["source-layer"] ? e.push(new w(n, t, `layer "${t.id}" must specify a "source-layer"`)) : u === "raster-dem" && i !== "hillshade" && i !== "color-relief" ? e.push(new w(n, t.source, "raster-dem source can only be used with layer type 'hillshade' or 'color-relief'.")) : i === "line" && t.paint && t.paint["line-gradient"] && (u !== "geojson" || !l.lineMetrics) && e.push(new w(n, t, `layer "${t.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e.push(new w(n, t.source, `source "${t.source}" not found`));
    }
  return e = e.concat(le({
    key: n,
    value: t,
    valueSpec: o.layer,
    style: r.style,
    styleSpec: r.styleSpec,
    validateSpec: r.validateSpec,
    objectElementValidators: {
      "*"() {
        return [];
      },
      // We don't want to enforce the spec's `"requires": true` for backward compatibility with refs;
      // the actual requirement is validated above. See https://github.com/mapbox/mapbox-gl-js/issues/5772.
      type() {
        return r.validateSpec({
          key: `${n}.type`,
          value: t.type,
          valueSpec: o.layer.type,
          style: r.style,
          styleSpec: r.styleSpec,
          validateSpec: r.validateSpec,
          object: t,
          objectKey: "type"
        });
      },
      filter: An,
      layout(l) {
        return le({
          layer: t,
          key: l.key,
          value: l.value,
          style: l.style,
          styleSpec: l.styleSpec,
          validateSpec: l.validateSpec,
          objectElementValidators: {
            "*"(u) {
              return yo(qt({ layerType: i }, u));
            }
          }
        });
      },
      paint(l) {
        return le({
          layer: t,
          key: l.key,
          value: l.value,
          style: l.style,
          styleSpec: l.styleSpec,
          validateSpec: l.validateSpec,
          objectElementValidators: {
            "*"(u) {
              return mo(qt({ layerType: i }, u));
            }
          }
        });
      }
    }
  })), e;
}
function Ke(r) {
  const e = r.value, t = r.key, n = R(e);
  return n !== "string" ? [new w(t, e, `string expected, ${n} found`)] : [];
}
function Xl(r) {
  var e;
  const t = (e = r.sourceName) !== null && e !== void 0 ? e : "", n = r.value, a = r.styleSpec, o = a.source_raster_dem, i = r.style;
  let s = [];
  const l = R(n);
  if (n === void 0)
    return s;
  if (l !== "object")
    return s.push(new w("source_raster_dem", n, `object expected, ${l} found`)), s;
  const c = G(n.encoding) === "custom", p = ["redFactor", "greenFactor", "blueFactor", "baseShift"], d = r.value.encoding ? `"${r.value.encoding}"` : "Default";
  for (const f in n)
    !c && p.includes(f) ? s.push(new w(f, n[f], `In "${t}": "${f}" is only valid when "encoding" is set to "custom". ${d} encoding found`)) : o[f] ? s = s.concat(r.validateSpec({
      key: f,
      value: n[f],
      valueSpec: o[f],
      validateSpec: r.validateSpec,
      style: i,
      styleSpec: a
    })) : s.push(new w(f, n[f], `unknown property "${f}"`));
  return s;
}
const sa = {
  promoteId: Yl
};
function vo(r) {
  const e = r.value, t = r.key, n = r.styleSpec, a = r.style, o = r.validateSpec;
  if (!e.type)
    return [new w(t, e, '"type" is required')];
  const i = G(e.type);
  let s;
  switch (i) {
    case "vector":
    case "raster":
      return s = le({
        key: t,
        value: e,
        valueSpec: n[`source_${i.replace("-", "_")}`],
        style: r.style,
        styleSpec: n,
        objectElementValidators: sa,
        validateSpec: o
      }), s;
    case "raster-dem":
      return s = Xl({
        sourceName: t,
        value: e,
        style: r.style,
        styleSpec: n,
        validateSpec: o
      }), s;
    case "geojson":
      if (s = le({
        key: t,
        value: e,
        valueSpec: n.source_geojson,
        style: a,
        styleSpec: n,
        validateSpec: o,
        objectElementValidators: sa
      }), e.cluster)
        for (const l in e.clusterProperties) {
          const [u, c] = e.clusterProperties[l], p = typeof u == "string" ? [u, ["accumulated"], ["get", l]] : u;
          s.push(...st({
            key: `${t}.${l}.map`,
            value: c,
            expressionContext: "cluster-map"
          })), s.push(...st({
            key: `${t}.${l}.reduce`,
            value: p,
            expressionContext: "cluster-reduce"
          }));
        }
      return s;
    case "video":
      return le({
        key: t,
        value: e,
        valueSpec: n.source_video,
        style: a,
        validateSpec: o,
        styleSpec: n
      });
    case "image":
      return le({
        key: t,
        value: e,
        valueSpec: n.source_image,
        style: a,
        validateSpec: o,
        styleSpec: n
      });
    case "canvas":
      return [new w(t, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
    default:
      return kt({
        key: `${t}.type`,
        value: e.type,
        valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }
      });
  }
}
function Yl({ key: r, value: e }) {
  if (R(e) === "string")
    return Ke({ key: r, value: e });
  {
    const t = [];
    for (const n in e)
      t.push(...Ke({ key: `${r}.${n}`, value: e[n] }));
    return t;
  }
}
function bo(r) {
  const e = r.value, t = r.styleSpec, n = t.light, a = r.style;
  let o = [];
  const i = R(e);
  if (e === void 0)
    return o;
  if (i !== "object")
    return o = o.concat([new w("light", e, `object expected, ${i} found`)]), o;
  for (const s in e) {
    const l = s.match(/^(.*)-transition$/);
    l && n[l[1]] && n[l[1]].transition ? o = o.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: t.transition,
      validateSpec: r.validateSpec,
      style: a,
      styleSpec: t
    })) : n[s] ? o = o.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: n[s],
      validateSpec: r.validateSpec,
      style: a,
      styleSpec: t
    })) : o = o.concat([new w(s, e[s], `unknown property "${s}"`)]);
  }
  return o;
}
function wo(r) {
  const e = r.value, t = r.styleSpec, n = t.sky, a = r.style, o = R(e);
  if (e === void 0)
    return [];
  if (o !== "object")
    return [new w("sky", e, `object expected, ${o} found`)];
  let i = [];
  for (const s in e)
    n[s] ? i = i.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: n[s],
      style: a,
      styleSpec: t
    })) : i = i.concat([new w(s, e[s], `unknown property "${s}"`)]);
  return i;
}
function So(r) {
  const e = r.value, t = r.styleSpec, n = t.terrain, a = r.style;
  let o = [];
  const i = R(e);
  if (e === void 0)
    return o;
  if (i !== "object")
    return o = o.concat([new w("terrain", e, `object expected, ${i} found`)]), o;
  for (const s in e)
    n[s] ? o = o.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: n[s],
      validateSpec: r.validateSpec,
      style: a,
      styleSpec: t
    })) : o = o.concat([new w(s, e[s], `unknown property "${s}"`)]);
  return o;
}
function Wl(r) {
  return Ke(r).length === 0 ? [] : st(r);
}
function Jl(r) {
  return Ke(r).length === 0 ? [] : st(r);
}
function Ql(r) {
  const e = r.key, t = r.value;
  if (R(t) === "array") {
    if (t.length < 1 || t.length > 4)
      return [new w(e, t, `padding requires 1 to 4 values; ${t.length} values found`)];
    const a = {
      type: "number"
    };
    let o = [];
    for (let i = 0; i < t.length; i++)
      o = o.concat(r.validateSpec({
        key: `${e}[${i}]`,
        value: t[i],
        validateSpec: r.validateSpec,
        valueSpec: a
      }));
    return o;
  } else
    return mr({
      key: e,
      value: t,
      valueSpec: {}
    });
}
function eu(r) {
  const e = r.key, t = r.value;
  if (R(t) === "array") {
    const a = {
      type: "number"
    };
    if (t.length < 1)
      return [new w(e, t, "array length at least 1 expected, length 0 found")];
    let o = [];
    for (let i = 0; i < t.length; i++)
      o = o.concat(r.validateSpec({
        key: `${e}[${i}]`,
        value: t[i],
        validateSpec: r.validateSpec,
        valueSpec: a
      }));
    return o;
  } else
    return mr({
      key: e,
      value: t,
      valueSpec: {}
    });
}
function tu(r) {
  const e = r.key, t = r.value;
  if (R(t) === "array") {
    if (t.length < 1)
      return [new w(e, t, "array length at least 1 expected, length 0 found")];
    let a = [];
    for (let o = 0; o < t.length; o++)
      a = a.concat(Zr({
        key: `${e}[${o}]`,
        value: t[o]
      }));
    return a;
  } else
    return Zr({
      key: e,
      value: t
    });
}
function ru(r) {
  const e = r.key, t = r.value, n = R(t), a = r.styleSpec;
  if (n !== "array" || t.length < 1 || t.length % 2 !== 0)
    return [new w(e, t, "variableAnchorOffsetCollection requires a non-empty array of even length")];
  let o = [];
  for (let i = 0; i < t.length; i += 2)
    o = o.concat(kt({
      key: `${e}[${i}]`,
      value: t[i],
      valueSpec: a.layout_symbol["text-anchor"]
    })), o = o.concat(En({
      key: `${e}[${i + 1}]`,
      value: t[i + 1],
      valueSpec: {
        length: 2,
        value: "number"
      },
      validateSpec: r.validateSpec,
      style: r.style,
      styleSpec: a
    }));
  return o;
}
function xo(r) {
  let e = [];
  const t = r.value, n = r.key;
  if (Array.isArray(t)) {
    const a = [], o = [];
    for (const i in t) {
      t[i].id && a.includes(t[i].id) && e.push(new w(n, t, `all the sprites' ids must be unique, but ${t[i].id} is duplicated`)), a.push(t[i].id), t[i].url && o.includes(t[i].url) && e.push(new w(n, t, `all the sprites' URLs must be unique, but ${t[i].url} is duplicated`)), o.push(t[i].url);
      const s = {
        id: {
          type: "string",
          required: !0
        },
        url: {
          type: "string",
          required: !0
        }
      };
      e = e.concat(le({
        key: `${n}[${i}]`,
        value: t[i],
        valueSpec: s,
        validateSpec: r.validateSpec
      }));
    }
    return e;
  } else
    return Ke({
      key: n,
      value: t
    });
}
function nu(r) {
  const e = r.value, t = r.styleSpec, n = t.projection, a = r.style, o = R(e);
  if (e === void 0)
    return [];
  if (o !== "object")
    return [new w("projection", e, `object expected, ${o} found`)];
  let i = [];
  for (const s in e)
    n[s] ? i = i.concat(r.validateSpec({
      key: s,
      value: e[s],
      valueSpec: n[s],
      style: a,
      styleSpec: t
    })) : i = i.concat([new w(s, e[s], `unknown property "${s}"`)]);
  return i;
}
function au(r) {
  const e = r.key;
  let t = r.value;
  t = t instanceof String ? t.valueOf() : t;
  const n = R(t);
  return n === "array" && !iu(t) && !ou(t) ? [new w(e, t, `projection expected, invalid array ${JSON.stringify(t)} found`)] : ["array", "string"].includes(n) ? [] : [new w(e, t, `projection expected, invalid type "${n}" found`)];
}
function ou(r) {
  return !!["interpolate", "step", "literal"].includes(r[0]);
}
function iu(r) {
  return Array.isArray(r) && r.length === 3 && typeof r[0] == "string" && typeof r[1] == "string" && typeof r[2] == "number";
}
function su(r) {
  return !!r && r.constructor === Object;
}
function ko(r) {
  return su(r.value) ? [] : [
    new w(r.key, r.value, `object expected, ${R(r.value)} found`)
  ];
}
const la = {
  "*"() {
    return [];
  },
  array: En,
  boolean: Kl,
  number: mr,
  color: Zr,
  constants: co,
  enum: kt,
  filter: An,
  function: po,
  layer: go,
  object: le,
  source: vo,
  light: bo,
  sky: wo,
  terrain: So,
  projection: nu,
  projectionDefinition: au,
  string: Ke,
  formatted: Wl,
  resolvedImage: Jl,
  padding: Ql,
  numberArray: eu,
  colorArray: tu,
  variableAnchorOffsetCollection: ru,
  sprite: xo,
  state: ko
};
function Wt(r) {
  const e = r.value, t = r.valueSpec, n = r.styleSpec;
  return r.validateSpec = Wt, t.expression && Ln(G(e)) ? po(r) : t.expression && so(Ze(e)) ? st(r) : t.type && la[t.type] ? la[t.type](r) : le(qt({}, r, {
    valueSpec: t.type ? n[t.type] : t
  }));
}
function Lo(r) {
  const e = r.value, t = r.key, n = Ke(r);
  return n.length || (e.indexOf("{fontstack}") === -1 && n.push(new w(t, e, '"glyphs" url must include a "{fontstack}" token')), e.indexOf("{range}") === -1 && n.push(new w(t, e, '"glyphs" url must include a "{range}" token'))), n;
}
function ie(r, e = Os) {
  let t = [];
  return t = t.concat(Wt({
    key: "",
    value: r,
    valueSpec: e.$root,
    styleSpec: e,
    style: r,
    validateSpec: Wt,
    objectElementValidators: {
      glyphs: Lo,
      "*"() {
        return [];
      }
    }
  })), r.constants && (t = t.concat(co({
    key: "constants",
    value: r.constants
  }))), Co(t);
}
ie.source = ye(me(vo));
ie.sprite = ye(me(xo));
ie.glyphs = ye(me(Lo));
ie.light = ye(me(bo));
ie.sky = ye(me(wo));
ie.terrain = ye(me(So));
ie.state = ye(me(ko));
ie.layer = ye(me(go));
ie.filter = ye(me(An));
ie.paintProperty = ye(me(mo));
ie.layoutProperty = ye(me(yo));
function me(r) {
  return function(e) {
    return r(Object.assign({}, e, { validateSpec: Wt }));
  };
}
function Co(r) {
  return [].concat(r).sort((e, t) => e.line - t.line);
}
function ye(r) {
  return function(...e) {
    return Co(r.apply(this, e));
  };
}
function ua(r) {
  if (!r)
    return {
      style: ft[br[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
      requiresUrlMonitoring: !1,
      // default styles don't require URL monitoring
      isFallback: !0
    };
  if (typeof r == "string") {
    const t = uu(r);
    return t.isValidStyle ? {
      style: t.styleObject,
      requiresUrlMonitoring: !1,
      isFallback: !1
    } : t.isValidJSON ? {
      style: ft[br[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
      requiresUrlMonitoring: !1,
      // default styles don't require URL monitoring
      isFallback: !0
    } : r.startsWith("http") ? { style: r, requiresUrlMonitoring: !0, isFallback: !1 } : r.toLowerCase().includes(".json") ? {
      style: lu(r),
      requiresUrlMonitoring: !0,
      isFallback: !1
    } : {
      style: wi(r),
      requiresUrlMonitoring: !0,
      isFallback: !1
    };
  }
  return r instanceof Si ? {
    style: r.getExpandedStyleURL(),
    requiresUrlMonitoring: !1,
    isFallback: !1
  } : r instanceof xi ? {
    style: r.getDefaultVariant().getExpandedStyleURL(),
    requiresUrlMonitoring: !1,
    isFallback: !1
  } : ie(r).length === 0 ? {
    style: r,
    requiresUrlMonitoring: !1,
    isFallback: !1,
    isJSON: !0
  } : {
    style: ft[br[0].referenceStyleID].getDefaultVariant().getExpandedStyleURL(),
    requiresUrlMonitoring: !1,
    // default styles don't require URL monitoring
    isFallback: !0
  };
}
function lu(r) {
  try {
    return new URL(r).href;
  } catch {
  }
  return new URL(r, location.origin).href;
}
function uu(r) {
  try {
    const e = JSON.parse(r), t = ie(e);
    return {
      isValidJSON: !0,
      isValidStyle: t.length === 0,
      styleObject: t.length === 0 ? e : null
    };
  } catch {
    return {
      isValidJSON: !1,
      isValidStyle: !1,
      styleObject: null
    };
  }
}
function Ce(r, e, t) {
  const n = window.document.createElement(r);
  return e !== void 0 && (n.className = e), t && t.appendChild(n), n;
}
function Lt(r) {
  r.parentNode && r.parentNode.removeChild(r);
}
class cu {
  constructor() {
    g(this, "_map");
    g(this, "_container");
    g(this, "_terrainButton");
    Ni(["_toggleTerrain", "_updateTerrainIcon"], this);
  }
  onAdd(e) {
    return this._map = e, this._container = Ce("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = Ce("button", "maplibregl-ctrl-terrain", this._container), Ce("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
  }
  onRemove() {
    Lt(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
  }
  _toggleTerrain() {
    Eo(this._map), this._updateTerrainIcon();
  }
  _updateTerrainIcon() {
    this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.hasTerrain() ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"));
  }
}
function Eo(r) {
  r.hasTerrain() ? r.disableTerrain() : r.enableTerrain();
}
class pu extends Na {
  constructor(t = {}) {
    super({
      showCompass: t.showCompass ?? !0,
      showZoom: t.showZoom ?? !0,
      visualizePitch: t.visualizePitch ?? !0
    });
    /**
     * Overloading: Limit how flat the compass icon can get
     */
    g(this, "_rotateCompassArrow", () => {
      const t = this._map.getBearing(), n = this._map.getPitch(), a = this.options.visualizePitch ? `scale(${Math.min(1.5, 1 / Math.cos(n * (Math.PI / 180)) ** 0.5)}) rotateX(${Math.min(70, n)}deg) rotateZ(${-t}deg)` : `rotate(${-t}deg)`;
      this._compassIcon.style.transform = a;
    });
    this._compass && (this._compass.removeEventListener("click", this._compass.clickFunction), this._compass.addEventListener("click", (n) => {
      this._map.getPitch() === 0 ? this._map.easeTo({ pitch: Math.min(this._map.getMaxPitch(), 80) }) : this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: n }) : this._map.resetNorth({}, { originalEvent: n });
    }));
  }
  /**
   * Overloading: the button now stores its click callback so that we can later on delete it and replace it
   */
  _createButton(t, n) {
    const a = super._createButton(t, n);
    return a.clickFunction = n, a;
  }
}
const ca = k.Marker, pa = k.LngLat, fu = k.LngLatBounds;
class du extends Ei {
  constructor() {
    super(...arguments);
    g(this, "lastUpdatedCenter", new pa(0, 0));
    /**
     * Update the camera location to center on the current position
     *
     * @param {Position} position the Geolocation API Position
     * @private
     */
    g(this, "_updateCamera", (t) => {
      var c;
      const n = new pa(t.coords.longitude, t.coords.latitude), a = t.coords.accuracy, i = {
        bearing: this._map.getBearing(),
        ...this.options.fitBoundsOptions,
        linear: !0
      }, s = this._map.getZoom();
      s > (((c = this.options.fitBoundsOptions) == null ? void 0 : c.maxZoom) ?? 30) && (i.zoom = s), this._map.fitBounds(fu.fromLngLat(n, a), i, {
        geolocateSource: !0
        // tag this camera change so it won't cause the control to change to background state
      });
      let l = !1;
      const u = () => {
        l = !0;
      };
      this._map.once("click", u), this._map.once("dblclick", u), this._map.once("dragstart", u), this._map.once("mousedown", u), this._map.once("touchstart", u), this._map.once("wheel", u), this._map.once("moveend", () => {
        this._map.off("click", u), this._map.off("dblclick", u), this._map.off("dragstart", u), this._map.off("mousedown", u), this._map.off("touchstart", u), this._map.off("wheel", u), !l && (this.lastUpdatedCenter = this._map.getCenter());
      });
    });
    g(this, "_finishSetupUI", (t) => {
      if (this._map) {
        if (t === !1) {
          const n = this._map._getUIString("GeolocateControl.LocationNotAvailable");
          this._geolocateButton.disabled = !0, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
        } else {
          const n = this._map._getUIString("GeolocateControl.FindMyLocation");
          this._geolocateButton.disabled = !1, this._geolocateButton.title = n, this._geolocateButton.setAttribute("aria-label", n);
        }
        this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = Ce("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new ca({ element: this._dotElement }), this._circleElement = Ce("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new ca({
          element: this._circleElement,
          pitchAlignment: "map"
        }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("move", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = !0, this.options.trackUserLocation && this._map.on("moveend", (n) => {
          const a = n.originalEvent && n.originalEvent.type === "resize", o = this.lastUpdatedCenter.distanceTo(this._map.getCenter());
          !n.geolocateSource && this._watchState === "ACTIVE_LOCK" && !a && o > 1 && (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new Event("trackuserlocationend")));
        });
      }
    });
    g(this, "_onZoom", () => {
      this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
    });
  }
  _updateCircleRadius() {
    if (this._watchState !== "BACKGROUND" && this._watchState !== "ACTIVE_LOCK")
      return;
    const t = [this._lastKnownPosition.coords.longitude, this._lastKnownPosition.coords.latitude], n = this._map.project(t), a = this._map.unproject([n.x, n.y]), o = this._map.unproject([n.x + 20, n.y]), i = a.distanceTo(o) / 20, s = Math.ceil(2 * this._accuracy / i);
    this._circleElement.style.width = `${s}px`, this._circleElement.style.height = `${s}px`;
  }
  // We are overwriting the method _setErrorState from Maplibre's GeolocateControl because the
  // case BACKGROUND_ERROR is not dealt with in the original function and yields an error.
  // Related issue: https://github.com/maplibre/maplibre-gl-js/issues/2294
  _setErrorState() {
    switch (this._watchState) {
      case "WAITING_ACTIVE":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
        break;
      case "ACTIVE_LOCK":
        this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "BACKGROUND":
        this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
        break;
      case "ACTIVE_ERROR":
        break;
      case "BACKGROUND_ERROR":
        break;
      default:
        throw new Error(`Unexpected watchState ${this._watchState}`);
    }
  }
}
var Te, ee, _e, Ie, nt;
class hu {
  /**
   * @param selectorOrElement Element to be used as control, specified as either reference to element itself or a CSS selector to find the element in DOM
   * @param onClick Function called when the element is clicked
   * @param onRender Function called every time the underlying map renders a new state
   */
  constructor(e, t, n) {
    Y(this, Te);
    Y(this, ee);
    Y(this, _e);
    Y(this, Ie);
    Y(this, nt);
    if (typeof e == "string") {
      const a = document.querySelector(e);
      if (!a) throw new Error(`No element has been found with selector "${e}" when creating an external control.`);
      J(this, ee, a);
    } else
      J(this, ee, e);
    t && J(this, _e, (a) => {
      t(L(this, Te), L(this, ee), a);
    }), n && J(this, Ie, (a) => {
      n(L(this, Te), L(this, ee), a);
    }), J(this, nt, L(this, ee).parentElement);
  }
  onAdd(e) {
    return J(this, Te, e), L(this, _e) && L(this, ee).addEventListener("click", L(this, _e)), L(this, Ie) && L(this, Te).on("render", L(this, Ie)), Lt(L(this, ee)), L(this, ee);
  }
  onRemove() {
    L(this, _e) && L(this, ee).removeEventListener("click", L(this, _e)), L(this, Ie) && L(this, Te).off("render", L(this, Ie)), L(this, nt) ? L(this, nt).appendChild(L(this, ee)) : Lt(L(this, ee));
  }
}
Te = new WeakMap(), ee = new WeakMap(), _e = new WeakMap(), Ie = new WeakMap(), nt = new WeakMap();
class mu {
  constructor() {
    g(this, "map");
    g(this, "container");
    g(this, "projectionButton");
  }
  onAdd(e) {
    return this.map = e, this.container = Ce("div", "maplibregl-ctrl maplibregl-ctrl-group"), this.projectionButton = Ce("button", "maplibregl-ctrl-projection", this.container), Ce("span", "maplibregl-ctrl-icon", this.projectionButton).setAttribute("aria-hidden", "true"), this.projectionButton.type = "button", this.projectionButton.addEventListener("click", this.toggleProjection.bind(this)), e.on("projectiontransition", this.updateProjectionIcon.bind(this)), this.updateProjectionIcon(), this.container;
  }
  onRemove() {
    Lt(this.container), this.map.off("projectiontransition", this.updateProjectionIcon), this.map = void 0;
  }
  toggleProjection() {
    Ao(this.map), this.updateProjectionIcon();
  }
  updateProjectionIcon() {
    this.projectionButton.classList.remove("maplibregl-ctrl-projection-globe"), this.projectionButton.classList.remove("maplibregl-ctrl-projection-mercator"), this.map.isGlobeProjection() ? (this.projectionButton.classList.add("maplibregl-ctrl-projection-mercator"), this.projectionButton.title = "Enable Mercator projection") : (this.projectionButton.classList.add("maplibregl-ctrl-projection-globe"), this.projectionButton.title = "Enable Globe projection");
  }
}
function Ao(r) {
  r.getProjection() === void 0 && r.setProjection({ type: "mercator" }), r.isGlobeProjection() ? r.enableMercatorProjection() : r.enableGlobeProjection();
}
const ct = {
  "zoom-in": (r) => r.zoomIn(),
  "zoom-out": (r) => r.zoomOut(),
  "toggle-projection": Ao,
  "toggle-terrain": Eo,
  "reset-view": (r) => {
    r.getPitch() === 0 ? r.easeTo({ pitch: Math.min(r.getMaxPitch(), 80) }) : r.resetNorthPitch();
  },
  "reset-bearing": (r) => {
    r.rotateTo(0);
  },
  "reset-pitch": (r) => {
    r.setPitch(0);
  },
  "reset-roll": (r) => {
    r.setRoll(0);
  }
};
var Et, at;
class Kr extends hu {
  /**
   * Constructs an instance of External Control to have a predefined functionality
   * @param controlElement Element to be used as control, specified as reference to element itself
   * @param controlType One of the predefined types of functionality
   */
  constructor(t, n) {
    if (n && !(n in ct)) throw new Error(`data-maptiler-control value "${n}" is invalid.`);
    super(t, n && ct[n]);
    Y(this, Et);
    Y(this, at, /* @__PURE__ */ new Map());
  }
  onAdd(t) {
    return J(this, Et, t), super.onAdd(t);
  }
  onRemove() {
    for (const [t, n] of L(this, at)) {
      const a = t.deref();
      a && a.removeEventListener("click", n);
    }
    L(this, at).clear(), super.onRemove();
  }
  /**
   * Configure a child element to be part of this control and to have a predefined functionality added
   * @param controlElement Element that is a descendant of the control element and that optionally should have some functionality
   * @param controlType One of the predefined types of functionality
   */
  configureGroupItem(t, n) {
    if (!n) return;
    if (!(n in ct)) throw new Error(`data-maptiler-control value "${n}" is invalid.`);
    const a = (o) => {
      ct[n](L(this, Et), t, o);
    };
    t.addEventListener("click", a), L(this, at).set(new WeakRef(t), a);
  }
}
Et = new WeakMap(), at = new WeakMap(), g(Kr, "controlCallbacks", ct);
var te, ue, Me, Pe, re, At, Z, To, se, _o;
class _r {
  constructor(e, t) {
    Y(this, Z);
    Y(this, te);
    g(this, "map");
    Y(this, ue);
    Y(this, Me);
    Y(this, Pe);
    Y(this, re, !1);
    Y(this, At);
    e.style !== void 0 && J(this, re, !0), J(this, te, {
      // set defaults
      zoomAdjust: -4,
      position: "top-right",
      // inherit map options
      ...t,
      // override any lingering control options
      forceNoAttributionControl: !0,
      attributionControl: !1,
      navigationControl: !1,
      geolocateControl: !1,
      maptilerLogo: !1,
      minimap: !1,
      hash: !1,
      pitchAdjust: !1,
      // override map options with new user defined minimap options
      ...e,
      containerStyle: {
        border: "1px solid #000",
        width: "400px",
        height: "300px",
        ...e.containerStyle ?? {}
      }
    }), e.lockZoom !== void 0 && (L(this, te).minZoom = e.lockZoom, L(this, te).maxZoom = e.lockZoom);
  }
  setStyle(e, t) {
    L(this, re) || this.map.setStyle(e, t), Q(this, Z, se).call(this);
  }
  addLayer(e, t) {
    return L(this, re) || this.map.addLayer(e, t), Q(this, Z, se).call(this), this.map;
  }
  moveLayer(e, t) {
    return L(this, re) || this.map.moveLayer(e, t), Q(this, Z, se).call(this), this.map;
  }
  removeLayer(e) {
    return L(this, re) || this.map.removeLayer(e), Q(this, Z, se).call(this), this;
  }
  setLayerZoomRange(e, t, n) {
    return L(this, re) || this.map.setLayerZoomRange(e, t, n), Q(this, Z, se).call(this), this;
  }
  setFilter(e, t, n) {
    return L(this, re) || this.map.setFilter(e, t, n), Q(this, Z, se).call(this), this;
  }
  setPaintProperty(e, t, n, a) {
    return L(this, re) || this.map.setPaintProperty(e, t, n, a), Q(this, Z, se).call(this), this;
  }
  setLayoutProperty(e, t, n, a) {
    return L(this, re) || this.map.setLayoutProperty(e, t, n, a), Q(this, Z, se).call(this), this;
  }
  setGlyphs(e, t) {
    return L(this, re) || this.map.setGlyphs(e, t), Q(this, Z, se).call(this), this;
  }
  onAdd(e) {
    J(this, ue, e), J(this, Me, Ce("div", "maplibregl-ctrl maplibregl-ctrl-group"));
    for (const [t, n] of Object.entries(L(this, te).containerStyle))
      L(this, Me).style.setProperty(t, n);
    return L(this, te).container = L(this, Me), L(this, te).zoom = e.getZoom() + L(this, te).zoomAdjust, this.map = new Po(L(this, te)), this.map.once("style.load", () => {
      this.map.resize();
    }), this.map.once("load", () => {
      Q(this, Z, To).call(this, L(this, te).parentRect), J(this, At, Q(this, Z, _o).call(this));
    }), L(this, Me);
  }
  onRemove() {
    var e;
    (e = L(this, At)) == null || e.call(this), Lt(L(this, Me));
  }
}
te = new WeakMap(), ue = new WeakMap(), Me = new WeakMap(), Pe = new WeakMap(), re = new WeakMap(), At = new WeakMap(), Z = new WeakSet(), To = function(e) {
  e === void 0 || e.linePaint === void 0 && e.fillPaint === void 0 || (J(this, Pe, {
    type: "Feature",
    properties: {
      name: "parentRect"
    },
    geometry: {
      type: "Polygon",
      coordinates: [[[], [], [], [], []]]
    }
  }), this.map.addSource("parentRect", {
    type: "geojson",
    data: L(this, Pe)
  }), (e.lineLayout !== void 0 || e.linePaint !== void 0) && this.map.addLayer({
    id: "parentRectOutline",
    type: "line",
    source: "parentRect",
    layout: {
      ...e.lineLayout
    },
    paint: {
      "line-color": "#FFF",
      "line-width": 1,
      "line-opacity": 0.85,
      ...e.linePaint
    }
  }), e.fillPaint !== void 0 && this.map.addLayer({
    id: "parentRectFill",
    type: "fill",
    source: "parentRect",
    layout: {},
    paint: {
      "fill-color": "#08F",
      "fill-opacity": 0.135,
      ...e.fillPaint
    }
  }), Q(this, Z, se).call(this));
}, se = function() {
  if (L(this, Pe) === void 0) return;
  const { devicePixelRatio: e } = window, t = L(this, ue).getCanvas(), n = t.width / e, a = t.height / e, o = L(this, ue).unproject.bind(L(this, ue)), i = o([0, 0]), s = o([n, 0]), l = o([0, a]), u = o([n, a]);
  L(this, Pe).geometry.coordinates = [[l.toArray(), u.toArray(), s.toArray(), i.toArray(), l.toArray()]];
  const c = this.map.getSource("parentRect");
  c !== void 0 && c.setData(L(this, Pe));
}, _o = function() {
  const { pitchAdjust: e } = L(this, te), t = () => {
    i("parent");
  }, n = () => {
    i("minimap");
  }, a = () => {
    L(this, ue).on("move", t), this.map.on("move", n);
  }, o = () => {
    L(this, ue).off("move", t), this.map.off("move", n);
  }, i = (s) => {
    o();
    const l = s === "parent" ? L(this, ue) : this.map, u = s === "parent" ? this.map : L(this, ue), c = l.getCenter(), p = l.getZoom() + L(this, te).zoomAdjust * (s === "parent" ? 1 : -1), d = l.getBearing(), f = l.getPitch();
    u.jumpTo({
      center: c,
      zoom: p,
      bearing: d,
      pitch: e ? f : 0
    }), Q(this, Z, se).call(this), a();
  };
  return a(), () => {
    o();
  };
};
class yu {
  /**
   *
   * @param map : a Map instance
   * @param delay : a delay in milliseconds after which the payload is sent to MapTiler cloud (cannot be less than 1000ms)
   */
  constructor(e, t = 2e3) {
    g(this, "map");
    g(this, "registeredModules", /* @__PURE__ */ new Set());
    g(this, "viewerType");
    this.map = e, this.viewerType = "Map", setTimeout(
      async () => {
        if (!j.telemetry)
          return;
        const n = this.preparePayload();
        try {
          (await fetch(n, { method: "POST" })).ok || console.warn("The metrics could not be sent to MapTiler Cloud");
        } catch (a) {
          console.warn("The metrics could not be sent to MapTiler Cloud", a);
        }
      },
      Math.max(1e3, t)
    );
  }
  /**
   * Register a module to the telemetry system of the SDK.
   * The arguments `name` and `version` likely come from the package.json
   * of each module.
   */
  registerModule(e, t) {
    this.registeredModules.add(`${e}:${t}`);
  }
  registerViewerType(e = "Map") {
    this.viewerType = e;
  }
  preparePayload() {
    const e = new URL(W.telemetryURL);
    return e.searchParams.append("sdk", oi()), e.searchParams.append("key", j.apiKey), e.searchParams.append("mtsid", on), e.searchParams.append("session", j.session ? "1" : "0"), e.searchParams.append("caching", j.caching ? "1" : "0"), e.searchParams.append("lang-updated", this.map.isLanguageUpdated() ? "1" : "0"), e.searchParams.append("terrain", this.map.getTerrain() ? "1" : "0"), e.searchParams.append("globe", this.map.isGlobeProjection() ? "1" : "0"), e.searchParams.append("viewerType", this.viewerType), this.registeredModules.size > 0 && e.searchParams.append("modules", Array.from(this.registeredModules).join("|")), e.href;
  }
}
var Ct = typeof Float32Array < "u" ? Float32Array : Array;
function mt() {
  var r = new Ct(16);
  return Ct != Float32Array && (r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = 0, r[12] = 0, r[13] = 0, r[14] = 0), r[0] = 1, r[5] = 1, r[10] = 1, r[15] = 1, r;
}
function gu(r, e, t, n, a, o, i, s, l, u, c, p, d, f, h, m, y) {
  return r[0] = e, r[1] = t, r[2] = n, r[3] = a, r[4] = o, r[5] = i, r[6] = s, r[7] = l, r[8] = u, r[9] = c, r[10] = p, r[11] = d, r[12] = f, r[13] = h, r[14] = m, r[15] = y, r;
}
function vu(r, e, t) {
  var n = e[0], a = e[1], o = e[2], i = e[3], s = e[4], l = e[5], u = e[6], c = e[7], p = e[8], d = e[9], f = e[10], h = e[11], m = e[12], y = e[13], b = e[14], v = e[15], x = t[0], E = t[1], C = t[2], T = t[3];
  return r[0] = x * n + E * s + C * p + T * m, r[1] = x * a + E * l + C * d + T * y, r[2] = x * o + E * u + C * f + T * b, r[3] = x * i + E * c + C * h + T * v, x = t[4], E = t[5], C = t[6], T = t[7], r[4] = x * n + E * s + C * p + T * m, r[5] = x * a + E * l + C * d + T * y, r[6] = x * o + E * u + C * f + T * b, r[7] = x * i + E * c + C * h + T * v, x = t[8], E = t[9], C = t[10], T = t[11], r[8] = x * n + E * s + C * p + T * m, r[9] = x * a + E * l + C * d + T * y, r[10] = x * o + E * u + C * f + T * b, r[11] = x * i + E * c + C * h + T * v, x = t[12], E = t[13], C = t[14], T = t[15], r[12] = x * n + E * s + C * p + T * m, r[13] = x * a + E * l + C * d + T * y, r[14] = x * o + E * u + C * f + T * b, r[15] = x * i + E * c + C * h + T * v, r;
}
function bu(r, e, t) {
  var n = t[0], a = t[1], o = t[2];
  return r[0] = e[0] * n, r[1] = e[1] * n, r[2] = e[2] * n, r[3] = e[3] * n, r[4] = e[4] * a, r[5] = e[5] * a, r[6] = e[6] * a, r[7] = e[7] * a, r[8] = e[8] * o, r[9] = e[9] * o, r[10] = e[10] * o, r[11] = e[11] * o, r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15], r;
}
function fa(r, e, t) {
  var n = Math.sin(t), a = Math.cos(t), o = e[4], i = e[5], s = e[6], l = e[7], u = e[8], c = e[9], p = e[10], d = e[11];
  return e !== r && (r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[4] = o * a + u * n, r[5] = i * a + c * n, r[6] = s * a + p * n, r[7] = l * a + d * n, r[8] = u * a - o * n, r[9] = c * a - i * n, r[10] = p * a - s * n, r[11] = d * a - l * n, r;
}
function wu(r, e, t) {
  var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[8], c = e[9], p = e[10], d = e[11];
  return e !== r && (r[4] = e[4], r[5] = e[5], r[6] = e[6], r[7] = e[7], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a - u * n, r[1] = i * a - c * n, r[2] = s * a - p * n, r[3] = l * a - d * n, r[8] = o * n + u * a, r[9] = i * n + c * a, r[10] = s * n + p * a, r[11] = l * n + d * a, r;
}
function da(r, e, t) {
  var n = Math.sin(t), a = Math.cos(t), o = e[0], i = e[1], s = e[2], l = e[3], u = e[4], c = e[5], p = e[6], d = e[7];
  return e !== r && (r[8] = e[8], r[9] = e[9], r[10] = e[10], r[11] = e[11], r[12] = e[12], r[13] = e[13], r[14] = e[14], r[15] = e[15]), r[0] = o * a + u * n, r[1] = i * a + c * n, r[2] = s * a + p * n, r[3] = l * a + d * n, r[4] = u * a - o * n, r[5] = c * a - i * n, r[6] = p * a - s * n, r[7] = d * a - l * n, r;
}
function Su(r, e, t, n, a) {
  var o = 1 / Math.tan(e / 2);
  if (r[0] = o / t, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = o, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[11] = -1, r[12] = 0, r[13] = 0, r[15] = 0, a != null && a !== 1 / 0) {
    var i = 1 / (n - a);
    r[10] = (a + n) * i, r[14] = 2 * a * n * i;
  } else
    r[10] = -1, r[14] = -2 * n;
  return r;
}
var xu = Su;
function Dt() {
  var r = new Ct(3);
  return Ct != Float32Array && (r[0] = 0, r[1] = 0, r[2] = 0), r;
}
function ku(r, e, t) {
  var n = new Ct(3);
  return n[0] = r, n[1] = e, n[2] = t, n;
}
function Ir(r, e) {
  var t = e[0], n = e[1], a = e[2], o = t * t + n * n + a * a;
  return o > 0 && (o = 1 / Math.sqrt(o)), r[0] = e[0] * o, r[1] = e[1] * o, r[2] = e[2] * o, r;
}
function ha(r, e, t) {
  var n = e[0], a = e[1], o = e[2], i = t[0], s = t[1], l = t[2];
  return r[0] = a * l - o * s, r[1] = o * i - n * l, r[2] = n * s - a * i, r;
}
(function() {
  var r = Dt();
  return function(e, t, n, a, o, i) {
    var s, l;
    for (t || (t = 3), n || (n = 0), a ? l = Math.min(a * t + n, e.length) : l = e.length, s = n; s < l; s += t)
      r[0] = e[s], r[1] = e[s + 1], r[2] = e[s + 2], o(r, r, i), e[s] = r[0], e[s + 1] = r[1], e[s + 2] = r[2];
    return e;
  };
})();
function Lu(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Mr, ma;
function Cu() {
  return ma || (ma = 1, Mr = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50]
  }), Mr;
}
var Pr, ya;
function Io() {
  if (ya) return Pr;
  ya = 1;
  const r = Cu(), e = {};
  for (const a of Object.keys(r))
    e[r[a]] = a;
  const t = {
    rgb: { channels: 3, labels: "rgb" },
    hsl: { channels: 3, labels: "hsl" },
    hsv: { channels: 3, labels: "hsv" },
    hwb: { channels: 3, labels: "hwb" },
    cmyk: { channels: 4, labels: "cmyk" },
    xyz: { channels: 3, labels: "xyz" },
    lab: { channels: 3, labels: "lab" },
    lch: { channels: 3, labels: "lch" },
    hex: { channels: 1, labels: ["hex"] },
    keyword: { channels: 1, labels: ["keyword"] },
    ansi16: { channels: 1, labels: ["ansi16"] },
    ansi256: { channels: 1, labels: ["ansi256"] },
    hcg: { channels: 3, labels: ["h", "c", "g"] },
    apple: { channels: 3, labels: ["r16", "g16", "b16"] },
    gray: { channels: 1, labels: ["gray"] }
  };
  Pr = t;
  for (const a of Object.keys(t)) {
    if (!("channels" in t[a]))
      throw new Error("missing channels property: " + a);
    if (!("labels" in t[a]))
      throw new Error("missing channel labels property: " + a);
    if (t[a].labels.length !== t[a].channels)
      throw new Error("channel and label counts mismatch: " + a);
    const { channels: o, labels: i } = t[a];
    delete t[a].channels, delete t[a].labels, Object.defineProperty(t[a], "channels", { value: o }), Object.defineProperty(t[a], "labels", { value: i });
  }
  t.rgb.hsl = function(a) {
    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(o, i, s), u = Math.max(o, i, s), c = u - l;
    let p, d;
    u === l ? p = 0 : o === u ? p = (i - s) / c : i === u ? p = 2 + (s - o) / c : s === u && (p = 4 + (o - i) / c), p = Math.min(p * 60, 360), p < 0 && (p += 360);
    const f = (l + u) / 2;
    return u === l ? d = 0 : f <= 0.5 ? d = c / (u + l) : d = c / (2 - u - l), [p, d * 100, f * 100];
  }, t.rgb.hsv = function(a) {
    let o, i, s, l, u;
    const c = a[0] / 255, p = a[1] / 255, d = a[2] / 255, f = Math.max(c, p, d), h = f - Math.min(c, p, d), m = function(y) {
      return (f - y) / 6 / h + 1 / 2;
    };
    return h === 0 ? (l = 0, u = 0) : (u = h / f, o = m(c), i = m(p), s = m(d), c === f ? l = s - i : p === f ? l = 1 / 3 + o - s : d === f && (l = 2 / 3 + i - o), l < 0 ? l += 1 : l > 1 && (l -= 1)), [
      l * 360,
      u * 100,
      f * 100
    ];
  }, t.rgb.hwb = function(a) {
    const o = a[0], i = a[1];
    let s = a[2];
    const l = t.rgb.hsl(a)[0], u = 1 / 255 * Math.min(o, Math.min(i, s));
    return s = 1 - 1 / 255 * Math.max(o, Math.max(i, s)), [l, u * 100, s * 100];
  }, t.rgb.cmyk = function(a) {
    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.min(1 - o, 1 - i, 1 - s), u = (1 - o - l) / (1 - l) || 0, c = (1 - i - l) / (1 - l) || 0, p = (1 - s - l) / (1 - l) || 0;
    return [u * 100, c * 100, p * 100, l * 100];
  };
  function n(a, o) {
    return (a[0] - o[0]) ** 2 + (a[1] - o[1]) ** 2 + (a[2] - o[2]) ** 2;
  }
  return t.rgb.keyword = function(a) {
    const o = e[a];
    if (o)
      return o;
    let i = 1 / 0, s;
    for (const l of Object.keys(r)) {
      const u = r[l], c = n(a, u);
      c < i && (i = c, s = l);
    }
    return s;
  }, t.keyword.rgb = function(a) {
    return r[a];
  }, t.rgb.xyz = function(a) {
    let o = a[0] / 255, i = a[1] / 255, s = a[2] / 255;
    o = o > 0.04045 ? ((o + 0.055) / 1.055) ** 2.4 : o / 12.92, i = i > 0.04045 ? ((i + 0.055) / 1.055) ** 2.4 : i / 12.92, s = s > 0.04045 ? ((s + 0.055) / 1.055) ** 2.4 : s / 12.92;
    const l = o * 0.4124 + i * 0.3576 + s * 0.1805, u = o * 0.2126 + i * 0.7152 + s * 0.0722, c = o * 0.0193 + i * 0.1192 + s * 0.9505;
    return [l * 100, u * 100, c * 100];
  }, t.rgb.lab = function(a) {
    const o = t.rgb.xyz(a);
    let i = o[0], s = o[1], l = o[2];
    i /= 95.047, s /= 100, l /= 108.883, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116, l = l > 8856e-6 ? l ** (1 / 3) : 7.787 * l + 16 / 116;
    const u = 116 * s - 16, c = 500 * (i - s), p = 200 * (s - l);
    return [u, c, p];
  }, t.hsl.rgb = function(a) {
    const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;
    let l, u, c;
    if (i === 0)
      return c = s * 255, [c, c, c];
    s < 0.5 ? l = s * (1 + i) : l = s + i - s * i;
    const p = 2 * s - l, d = [0, 0, 0];
    for (let f = 0; f < 3; f++)
      u = o + 1 / 3 * -(f - 1), u < 0 && u++, u > 1 && u--, 6 * u < 1 ? c = p + (l - p) * 6 * u : 2 * u < 1 ? c = l : 3 * u < 2 ? c = p + (l - p) * (2 / 3 - u) * 6 : c = p, d[f] = c * 255;
    return d;
  }, t.hsl.hsv = function(a) {
    const o = a[0];
    let i = a[1] / 100, s = a[2] / 100, l = i;
    const u = Math.max(s, 0.01);
    s *= 2, i *= s <= 1 ? s : 2 - s, l *= u <= 1 ? u : 2 - u;
    const c = (s + i) / 2, p = s === 0 ? 2 * l / (u + l) : 2 * i / (s + i);
    return [o, p * 100, c * 100];
  }, t.hsv.rgb = function(a) {
    const o = a[0] / 60, i = a[1] / 100;
    let s = a[2] / 100;
    const l = Math.floor(o) % 6, u = o - Math.floor(o), c = 255 * s * (1 - i), p = 255 * s * (1 - i * u), d = 255 * s * (1 - i * (1 - u));
    switch (s *= 255, l) {
      case 0:
        return [s, d, c];
      case 1:
        return [p, s, c];
      case 2:
        return [c, s, d];
      case 3:
        return [c, p, s];
      case 4:
        return [d, c, s];
      case 5:
        return [s, c, p];
    }
  }, t.hsv.hsl = function(a) {
    const o = a[0], i = a[1] / 100, s = a[2] / 100, l = Math.max(s, 0.01);
    let u, c;
    c = (2 - i) * s;
    const p = (2 - i) * l;
    return u = i * l, u /= p <= 1 ? p : 2 - p, u = u || 0, c /= 2, [o, u * 100, c * 100];
  }, t.hwb.rgb = function(a) {
    const o = a[0] / 360;
    let i = a[1] / 100, s = a[2] / 100;
    const l = i + s;
    let u;
    l > 1 && (i /= l, s /= l);
    const c = Math.floor(6 * o), p = 1 - s;
    u = 6 * o - c, (c & 1) !== 0 && (u = 1 - u);
    const d = i + u * (p - i);
    let f, h, m;
    switch (c) {
      default:
      case 6:
      case 0:
        f = p, h = d, m = i;
        break;
      case 1:
        f = d, h = p, m = i;
        break;
      case 2:
        f = i, h = p, m = d;
        break;
      case 3:
        f = i, h = d, m = p;
        break;
      case 4:
        f = d, h = i, m = p;
        break;
      case 5:
        f = p, h = i, m = d;
        break;
    }
    return [f * 255, h * 255, m * 255];
  }, t.cmyk.rgb = function(a) {
    const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100, l = a[3] / 100, u = 1 - Math.min(1, o * (1 - l) + l), c = 1 - Math.min(1, i * (1 - l) + l), p = 1 - Math.min(1, s * (1 - l) + l);
    return [u * 255, c * 255, p * 255];
  }, t.xyz.rgb = function(a) {
    const o = a[0] / 100, i = a[1] / 100, s = a[2] / 100;
    let l, u, c;
    return l = o * 3.2406 + i * -1.5372 + s * -0.4986, u = o * -0.9689 + i * 1.8758 + s * 0.0415, c = o * 0.0557 + i * -0.204 + s * 1.057, l = l > 31308e-7 ? 1.055 * l ** (1 / 2.4) - 0.055 : l * 12.92, u = u > 31308e-7 ? 1.055 * u ** (1 / 2.4) - 0.055 : u * 12.92, c = c > 31308e-7 ? 1.055 * c ** (1 / 2.4) - 0.055 : c * 12.92, l = Math.min(Math.max(0, l), 1), u = Math.min(Math.max(0, u), 1), c = Math.min(Math.max(0, c), 1), [l * 255, u * 255, c * 255];
  }, t.xyz.lab = function(a) {
    let o = a[0], i = a[1], s = a[2];
    o /= 95.047, i /= 100, s /= 108.883, o = o > 8856e-6 ? o ** (1 / 3) : 7.787 * o + 16 / 116, i = i > 8856e-6 ? i ** (1 / 3) : 7.787 * i + 16 / 116, s = s > 8856e-6 ? s ** (1 / 3) : 7.787 * s + 16 / 116;
    const l = 116 * i - 16, u = 500 * (o - i), c = 200 * (i - s);
    return [l, u, c];
  }, t.lab.xyz = function(a) {
    const o = a[0], i = a[1], s = a[2];
    let l, u, c;
    u = (o + 16) / 116, l = i / 500 + u, c = u - s / 200;
    const p = u ** 3, d = l ** 3, f = c ** 3;
    return u = p > 8856e-6 ? p : (u - 16 / 116) / 7.787, l = d > 8856e-6 ? d : (l - 16 / 116) / 7.787, c = f > 8856e-6 ? f : (c - 16 / 116) / 7.787, l *= 95.047, u *= 100, c *= 108.883, [l, u, c];
  }, t.lab.lch = function(a) {
    const o = a[0], i = a[1], s = a[2];
    let l;
    l = Math.atan2(s, i) * 360 / 2 / Math.PI, l < 0 && (l += 360);
    const c = Math.sqrt(i * i + s * s);
    return [o, c, l];
  }, t.lch.lab = function(a) {
    const o = a[0], i = a[1], l = a[2] / 360 * 2 * Math.PI, u = i * Math.cos(l), c = i * Math.sin(l);
    return [o, u, c];
  }, t.rgb.ansi16 = function(a, o = null) {
    const [i, s, l] = a;
    let u = o === null ? t.rgb.hsv(a)[2] : o;
    if (u = Math.round(u / 50), u === 0)
      return 30;
    let c = 30 + (Math.round(l / 255) << 2 | Math.round(s / 255) << 1 | Math.round(i / 255));
    return u === 2 && (c += 60), c;
  }, t.hsv.ansi16 = function(a) {
    return t.rgb.ansi16(t.hsv.rgb(a), a[2]);
  }, t.rgb.ansi256 = function(a) {
    const o = a[0], i = a[1], s = a[2];
    return o === i && i === s ? o < 8 ? 16 : o > 248 ? 231 : Math.round((o - 8) / 247 * 24) + 232 : 16 + 36 * Math.round(o / 255 * 5) + 6 * Math.round(i / 255 * 5) + Math.round(s / 255 * 5);
  }, t.ansi16.rgb = function(a) {
    let o = a % 10;
    if (o === 0 || o === 7)
      return a > 50 && (o += 3.5), o = o / 10.5 * 255, [o, o, o];
    const i = (~~(a > 50) + 1) * 0.5, s = (o & 1) * i * 255, l = (o >> 1 & 1) * i * 255, u = (o >> 2 & 1) * i * 255;
    return [s, l, u];
  }, t.ansi256.rgb = function(a) {
    if (a >= 232) {
      const u = (a - 232) * 10 + 8;
      return [u, u, u];
    }
    a -= 16;
    let o;
    const i = Math.floor(a / 36) / 5 * 255, s = Math.floor((o = a % 36) / 6) / 5 * 255, l = o % 6 / 5 * 255;
    return [i, s, l];
  }, t.rgb.hex = function(a) {
    const i = (((Math.round(a[0]) & 255) << 16) + ((Math.round(a[1]) & 255) << 8) + (Math.round(a[2]) & 255)).toString(16).toUpperCase();
    return "000000".substring(i.length) + i;
  }, t.hex.rgb = function(a) {
    const o = a.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!o)
      return [0, 0, 0];
    let i = o[0];
    o[0].length === 3 && (i = i.split("").map((p) => p + p).join(""));
    const s = parseInt(i, 16), l = s >> 16 & 255, u = s >> 8 & 255, c = s & 255;
    return [l, u, c];
  }, t.rgb.hcg = function(a) {
    const o = a[0] / 255, i = a[1] / 255, s = a[2] / 255, l = Math.max(Math.max(o, i), s), u = Math.min(Math.min(o, i), s), c = l - u;
    let p, d;
    return c < 1 ? p = u / (1 - c) : p = 0, c <= 0 ? d = 0 : l === o ? d = (i - s) / c % 6 : l === i ? d = 2 + (s - o) / c : d = 4 + (o - i) / c, d /= 6, d %= 1, [d * 360, c * 100, p * 100];
  }, t.hsl.hcg = function(a) {
    const o = a[1] / 100, i = a[2] / 100, s = i < 0.5 ? 2 * o * i : 2 * o * (1 - i);
    let l = 0;
    return s < 1 && (l = (i - 0.5 * s) / (1 - s)), [a[0], s * 100, l * 100];
  }, t.hsv.hcg = function(a) {
    const o = a[1] / 100, i = a[2] / 100, s = o * i;
    let l = 0;
    return s < 1 && (l = (i - s) / (1 - s)), [a[0], s * 100, l * 100];
  }, t.hcg.rgb = function(a) {
    const o = a[0] / 360, i = a[1] / 100, s = a[2] / 100;
    if (i === 0)
      return [s * 255, s * 255, s * 255];
    const l = [0, 0, 0], u = o % 1 * 6, c = u % 1, p = 1 - c;
    let d = 0;
    switch (Math.floor(u)) {
      case 0:
        l[0] = 1, l[1] = c, l[2] = 0;
        break;
      case 1:
        l[0] = p, l[1] = 1, l[2] = 0;
        break;
      case 2:
        l[0] = 0, l[1] = 1, l[2] = c;
        break;
      case 3:
        l[0] = 0, l[1] = p, l[2] = 1;
        break;
      case 4:
        l[0] = c, l[1] = 0, l[2] = 1;
        break;
      default:
        l[0] = 1, l[1] = 0, l[2] = p;
    }
    return d = (1 - i) * s, [
      (i * l[0] + d) * 255,
      (i * l[1] + d) * 255,
      (i * l[2] + d) * 255
    ];
  }, t.hcg.hsv = function(a) {
    const o = a[1] / 100, i = a[2] / 100, s = o + i * (1 - o);
    let l = 0;
    return s > 0 && (l = o / s), [a[0], l * 100, s * 100];
  }, t.hcg.hsl = function(a) {
    const o = a[1] / 100, s = a[2] / 100 * (1 - o) + 0.5 * o;
    let l = 0;
    return s > 0 && s < 0.5 ? l = o / (2 * s) : s >= 0.5 && s < 1 && (l = o / (2 * (1 - s))), [a[0], l * 100, s * 100];
  }, t.hcg.hwb = function(a) {
    const o = a[1] / 100, i = a[2] / 100, s = o + i * (1 - o);
    return [a[0], (s - o) * 100, (1 - s) * 100];
  }, t.hwb.hcg = function(a) {
    const o = a[1] / 100, s = 1 - a[2] / 100, l = s - o;
    let u = 0;
    return l < 1 && (u = (s - l) / (1 - l)), [a[0], l * 100, u * 100];
  }, t.apple.rgb = function(a) {
    return [a[0] / 65535 * 255, a[1] / 65535 * 255, a[2] / 65535 * 255];
  }, t.rgb.apple = function(a) {
    return [a[0] / 255 * 65535, a[1] / 255 * 65535, a[2] / 255 * 65535];
  }, t.gray.rgb = function(a) {
    return [a[0] / 100 * 255, a[0] / 100 * 255, a[0] / 100 * 255];
  }, t.gray.hsl = function(a) {
    return [0, 0, a[0]];
  }, t.gray.hsv = t.gray.hsl, t.gray.hwb = function(a) {
    return [0, 100, a[0]];
  }, t.gray.cmyk = function(a) {
    return [0, 0, 0, a[0]];
  }, t.gray.lab = function(a) {
    return [a[0], 0, 0];
  }, t.gray.hex = function(a) {
    const o = Math.round(a[0] / 100 * 255) & 255, s = ((o << 16) + (o << 8) + o).toString(16).toUpperCase();
    return "000000".substring(s.length) + s;
  }, t.rgb.gray = function(a) {
    return [(a[0] + a[1] + a[2]) / 3 / 255 * 100];
  }, Pr;
}
var Rr, ga;
function Eu() {
  if (ga) return Rr;
  ga = 1;
  const r = Io();
  function e() {
    const o = {}, i = Object.keys(r);
    for (let s = i.length, l = 0; l < s; l++)
      o[i[l]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    return o;
  }
  function t(o) {
    const i = e(), s = [o];
    for (i[o].distance = 0; s.length; ) {
      const l = s.pop(), u = Object.keys(r[l]);
      for (let c = u.length, p = 0; p < c; p++) {
        const d = u[p], f = i[d];
        f.distance === -1 && (f.distance = i[l].distance + 1, f.parent = l, s.unshift(d));
      }
    }
    return i;
  }
  function n(o, i) {
    return function(s) {
      return i(o(s));
    };
  }
  function a(o, i) {
    const s = [i[o].parent, o];
    let l = r[i[o].parent][o], u = i[o].parent;
    for (; i[u].parent; )
      s.unshift(i[u].parent), l = n(r[i[u].parent][u], l), u = i[u].parent;
    return l.conversion = s, l;
  }
  return Rr = function(o) {
    const i = t(o), s = {}, l = Object.keys(i);
    for (let u = l.length, c = 0; c < u; c++) {
      const p = l[c];
      i[p].parent !== null && (s[p] = a(p, i));
    }
    return s;
  }, Rr;
}
var zr, va;
function Au() {
  if (va) return zr;
  va = 1;
  const r = Io(), e = Eu(), t = {}, n = Object.keys(r);
  function a(i) {
    const s = function(...l) {
      const u = l[0];
      return u == null ? u : (u.length > 1 && (l = u), i(l));
    };
    return "conversion" in i && (s.conversion = i.conversion), s;
  }
  function o(i) {
    const s = function(...l) {
      const u = l[0];
      if (u == null)
        return u;
      u.length > 1 && (l = u);
      const c = i(l);
      if (typeof c == "object")
        for (let p = c.length, d = 0; d < p; d++)
          c[d] = Math.round(c[d]);
      return c;
    };
    return "conversion" in i && (s.conversion = i.conversion), s;
  }
  return n.forEach((i) => {
    t[i] = {}, Object.defineProperty(t[i], "channels", { value: r[i].channels }), Object.defineProperty(t[i], "labels", { value: r[i].labels });
    const s = e(i);
    Object.keys(s).forEach((u) => {
      const c = s[u];
      t[i][u] = o(c), t[i][u].raw = a(c);
    });
  }), zr = t, zr;
}
var Tu = Au();
const _u = /* @__PURE__ */ Lu(Tu);
function ba({ gl: r, type: e, source: t }) {
  const n = r.createShader(e);
  if (n === null)
    throw new Error("Cannot create shader");
  if (r.shaderSource(n, t), r.compileShader(n), !r.getShaderParameter(n, r.COMPILE_STATUS))
    throw console.error("Shader compilation error:", r.getShaderInfoLog(n)), r.deleteShader(n), new Error("Cannot compile shader");
  return n;
}
function Iu({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }) {
  const n = ba({
    gl: r,
    type: r.VERTEX_SHADER,
    source: e
  }), a = ba({ gl: r, type: r.FRAGMENT_SHADER, source: t }), o = r.createProgram();
  if (r.attachShader(o, n), r.attachShader(o, a), r.linkProgram(o), !r.getProgramParameter(o, r.LINK_STATUS))
    throw console.error("Error: ", r.getProgramInfoLog(o)), new Error("Cannot link shader program");
  return o;
}
function Mu(r, e, t) {
  const n = r.getUniformLocation(e, t);
  if (n === null)
    throw new Error(`Cannot get uniform location for ${t}`);
  return n;
}
function Mo({
  gl: r,
  vertexShaderSource: e,
  fragmentShaderSource: t,
  attributesKeys: n,
  uniformsKeys: a,
  vertices: o,
  indices: i
}) {
  const s = Iu({ gl: r, vertexShaderSource: e, fragmentShaderSource: t }), l = n.reduce((f, h) => (f[h] = r.getAttribLocation(s, `a_${h}`), f), {}), u = a.reduce((f, h) => (f[h] = Mu(r, s, `u_${h}`), f), {}), c = r.createBuffer();
  r.bindBuffer(r.ARRAY_BUFFER, c), r.bufferData(r.ARRAY_BUFFER, new Float32Array(o), r.STATIC_DRAW);
  let p, d;
  return i !== void 0 && (p = r.createBuffer(), d = i.length, r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, p), r.bufferData(r.ELEMENT_ARRAY_BUFFER, new Uint16Array(i), r.STATIC_DRAW)), {
    shaderProgram: s,
    programInfo: {
      attributesLocations: l,
      uniformsLocations: u
    },
    positionBuffer: c,
    indexBuffer: p,
    indexBufferLength: d
  };
}
function Ut(r) {
  if (!r)
    return [1, 1, 1, 0];
  if (r === "transparent")
    return [1, 1, 1, 0];
  try {
    const e = Pu(r), t = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})?$/i.exec(e);
    if (t != null && t.length) {
      const a = !!t[4];
      return [..._u.hex.rgb(e).map((o) => o / 255), a ? parseInt(t[4], 16) / 255 : 1];
    }
    const n = e.match(/(\d\.\d(\d+)?|\d{3}|\d{2}|\d{1})/gi) ?? ["0", "0", "0"];
    if (e.includes("rgb")) {
      const a = e.includes("rgba"), o = [
        ...n.map((i) => parseFloat(i)).map((i, s) => s < 3 ? i / 255 : i)
        // because alpha is in the range 0 - 1, not 0 - 255
      ];
      return a || o.push(1), o;
    }
  } catch {
  }
  return console.warn([`[parseColorStringToVec4]: Color ${r} is either not a valid color or its type is not supported, defaulting to black`]), [0, 0, 0, 1];
}
let pt;
function Pu(r) {
  return pt = pt ?? document.createElement("canvas").getContext("2d"), pt ? (pt.fillStyle = r, pt.fillStyle) : "#000000";
}
const Tn = 1, U = Tn / 2, B = Tn / 2, q = Tn / 2, Ru = [-U, -B, q, U, -B, q, U, B, q, -U, B, q], zu = [-U, -B, -q, -U, B, -q, U, B, -q, U, -B, -q], Ou = [-U, B, -q, -U, B, q, U, B, q, U, B, -q], Fu = [-U, -B, -q, U, -B, -q, U, -B, q, -U, -B, q], $u = [U, -B, -q, U, B, -q, U, B, q, U, -B, q], Nu = [-U, -B, -q, -U, -B, q, -U, B, q, -U, B, -q], ju = [...Ru, ...zu, ...Ou, ...Fu, ...$u, ...Nu], Du = [
  // Front
  0,
  1,
  2,
  0,
  2,
  3,
  // Back
  4,
  5,
  6,
  4,
  6,
  7,
  // Left
  8,
  9,
  10,
  8,
  10,
  11,
  // Right
  12,
  13,
  14,
  12,
  14,
  15,
  // Up
  16,
  17,
  18,
  16,
  18,
  19,
  // Down
  20,
  21,
  22,
  20,
  22,
  23
], Uu = `attribute vec3 a_vertexPosition;
varying vec3 vTextureCoord;

uniform mat4 u_projectionMatrix;
uniform mat4 u_modelViewMatrix;
  
void main(void) {
  vTextureCoord = vec3(-a_vertexPosition.x, a_vertexPosition.y, a_vertexPosition.z);
  gl_Position = u_projectionMatrix * u_modelViewMatrix * vec4(a_vertexPosition, 1.0);
}
`, wa = `precision mediump float;

varying vec3 vTextureCoord;

%USE_TEXTURE_MACRO_MARKER%

# ifdef USE_TEXTURE
uniform samplerCube u_cubeSampler;
uniform float u_fadeOpacity;
# endif

uniform vec4 u_bgColor;

void main(void) {
  #ifdef USE_TEXTURE
  vec4 texColor = textureCube(u_cubeSampler, vTextureCoord);

    gl_FragColor = mix(
      u_bgColor,
      texColor,
      min(texColor.a, u_fadeOpacity)
    );

    gl_FragColor.a = max(gl_FragColor.a, u_fadeOpacity);

  #else
  gl_FragColor = u_bgColor;
  #endif
}
`;
var Bu = /* @__PURE__ */ ((r) => (r.UNIVERSE_DARK = "universe-dark", r))(Bu || {});
const Ge = {
  stars: {
    color: "hsl(233,100%,92%)",
    preset: "stars"
  },
  space: {
    color: "hsl(210, 100%, 4%)",
    preset: "space"
  },
  milkyway: {
    color: "hsl(233,100%,92%)",
    preset: "milkyway"
  },
  "milkyway-subtle": {
    color: "hsl(233,100%,92%)",
    preset: "milkyway-subtle"
  },
  "milkyway-bright": {
    color: "hsl(233,100%,92%)",
    preset: "milkyway-bright"
  },
  "milkyway-colored": {
    color: "black",
    preset: "milkyway-colored"
  }
};
var Ne = /* @__PURE__ */ ((r) => (r.POSITIVE_X = "pX", r.NEGATIVE_X = "nX", r.POSITIVE_Y = "pY", r.NEGATIVE_Y = "nY", r.POSITIVE_Z = "pZ", r.NEGATIVE_Z = "nZ", r))(Ne || {});
const tt = /* @__PURE__ */ new Map();
function qu(r) {
  const e = tt.get(r);
  e && (tt.delete(r), r.deleteTexture(e));
}
const Sa = /* @__PURE__ */ new Map();
let xa;
function Vu({ gl: r, faces: e, onReady: t, forceRefresh: n }) {
  if (tt.get(r) && !n && xa === JSON.stringify(e)) {
    t(tt.get(r), Sa.get(r));
    return;
  }
  xa = JSON.stringify(e);
  const a = tt.get(r) ?? r.createTexture();
  if (r.bindTexture(r.TEXTURE_CUBE_MAP, a), !e) {
    console.warn("[CubemapLayer][loadCubemapTexture]: Faces are null");
    return;
  }
  const o = Object.keys(e).length;
  if (o !== 6) {
    console.warn(`[CubemapLayer][loadCubemapTexture]: Faces should contain exactly 6 images, but found ${o}`);
    return;
  }
  const i = Object.entries(e).map(([s, l]) => new Promise((u, c) => {
    const p = s;
    if (l === void 0) {
      c(new Error(`[CubemapLayer][loadCubemapTexture]: Face ${s} is undefined`));
      return;
    }
    const d = new Image();
    d.crossOrigin = "anonymous";
    const f = () => {
      u({ image: d, key: p });
    };
    d.src = l, d.complete && d.naturalWidth > 0 ? f() : d.onload = f, d.onerror = () => {
      c(new Error(`[CubemapLayer][loadCubemapTexture]: Error loading image ${l}`));
    };
  }));
  Promise.all(i).then((s) => {
    for (let u = 0; u < s.length; u++) {
      const p = r.RGBA, d = r.RGBA, f = r.UNSIGNED_BYTE, { image: h, key: m } = s[u] ?? {};
      if (!h || !m) {
        console.warn("[CubemapLayer][loadCubemapTexture]: Image or key is null");
        continue;
      }
      const y = Gu(r, m);
      r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE), r.texImage2D(y, 0, p, d, f, h);
    }
    r.bindTexture(r.TEXTURE_CUBE_MAP, a), r.generateMipmap(r.TEXTURE_CUBE_MAP), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MIN_FILTER, r.LINEAR_MIPMAP_LINEAR), r.texParameteri(r.TEXTURE_CUBE_MAP, r.TEXTURE_MAG_FILTER, r.LINEAR);
    const l = s.map((u) => u.image);
    t(a, l), Sa.set(r, l), tt.set(r, a);
  }).catch((s) => {
    console.error("[CubemapLayer][loadCubemapTexture]: Error loading cubemap texture", s);
  });
}
function Gu(r, e) {
  if (e === Ne.POSITIVE_X)
    return r.TEXTURE_CUBE_MAP_POSITIVE_X;
  if (e === Ne.NEGATIVE_X)
    return r.TEXTURE_CUBE_MAP_NEGATIVE_X;
  if (e === Ne.POSITIVE_Y)
    return r.TEXTURE_CUBE_MAP_POSITIVE_Y;
  if (e === Ne.NEGATIVE_Y)
    return r.TEXTURE_CUBE_MAP_NEGATIVE_Y;
  if (e === Ne.POSITIVE_Z)
    return r.TEXTURE_CUBE_MAP_POSITIVE_Z;
  if (e === Ne.NEGATIVE_Z)
    return r.TEXTURE_CUBE_MAP_NEGATIVE_Z;
  throw new Error(`[CubemapLayer][loadCubemapTexture]: Invalid key ${e}`);
}
function Hu(r, e, t) {
  return [
    ze(r[0], e[0], t),
    ze(r[1], e[1], t),
    ze(r[2], e[2], t),
    ze(r[3], e[3], t)
  ];
}
function ze(r, e, t) {
  return r + (e - r) * t;
}
function Jt(r) {
  if (!r)
    return {};
  const e = Object.keys(r).sort().map((t) => [t, r[t]]);
  return Object.fromEntries(e);
}
const Je = "https://api.maptiler.com/resources/space", Zu = ["vertexPosition"], Ku = ["projectionMatrix", "modelViewMatrix", "cubeSampler", "bgColor", "fadeOpacity"], ka = "%USE_TEXTURE_MACRO_MARKER%", Xu = "#define USE_TEXTURE", La = Ge.stars;
function Yu(r, e) {
  if (!Xr(r))
    return {
      color: "transparent"
    };
  if (r === !0)
    return e;
  const t = {
    ...r
  };
  if (r.faces || r.path)
    return delete t.preset, t;
  const n = r.preset;
  if (!(n === void 0) && !(n in Ge))
    throw new Error(`[CubemapLayer]: Invalid preset "${n}". Available presets: ${Object.keys(Ge).join(", ")}`);
  return {
    ...t,
    // this _could_ be nullish_
    color: t.color ?? Ge[n].color ?? "hsl(233,100%,92%)"
  };
}
class Or {
  /**
   * Creates a new instance of CubemapLayer
   *
   * @param {CubemapLayerConstructorOptions | true} cubemapConfig - Configuration options for the cubemap layer or `true` to use default options.
   * Can specify faces, preset, path, and color properties to configure the cubemap.
   *
   * @remarks You shouldn't have to use this class directly.
   * Instead, use the `Map.setHalo` method to create and add a halo layer to the map.
   * The constructor initializes the cubemap with the provided configuration.
   * It processes the faces definition, sets up background colors, and determines
   * whether to use a cubemap texture based on the provided options.
   */
  constructor(e) {
    g(this, "id", "Cubemap Layer");
    g(this, "type", "custom");
    g(this, "renderingMode", "3d");
    /**
     * The map instance to which this layer is added.
     * @type {MapSDK}
     * @private
     */
    g(this, "map");
    /**
     * The cubemap faces definition, which can be either a preset, path, or explicit face URLs.
     * @type {CubemapFaces | null}
     * @remarks
     * This property is set during the initialization of the layer and can be updated later.
     * If no faces are defined, it will be `null`.
     */
    g(this, "faces");
    /**
     * Indicates whether to use a cubemap texture for rendering.
     * @type {boolean}
     * @private
     * @default true
     */
    g(this, "useCubemapTexture", !0);
    /**
     * The current opacity of the fade effect applied to the cubemap image texture, used for fading in and out.
     * @type {number}
     * @private
     * @default 0.0
     */
    g(this, "currentFadeOpacity", 0);
    /**
     * Indicates whether the cubemap needs to be updated, typically when the faces or texture changes.
     * @type {boolean}
     * @private
     * @default false
     */
    g(this, "cubeMapNeedsUpdate", !1);
    /**
     * The background color of the cubemap layer, represented as a Vec4 (RGBA).
     * @type {Vec4}
     * @private
     */
    g(this, "bgColor");
    /**
     * The previous background color used for transition animations.
     * @type {Vec4}
     * @private
     */
    g(this, "previousBgColor", [0, 0, 0, 0]);
    /**
     * The target background color to which the layer will transition.
     * @type {Vec4}
     * @private
     */
    g(this, "targetBgColor", [0, 0, 0, 0]);
    /**
     * The delta value used for transitioning the background color. 0 = start of transition, 1 = end of transition.
     * This value is incremented over time to create a smooth transition effect.
     * @type {number}
     * @private
     */
    g(this, "transitionDelta", 0);
    /**
     * The WebGL context used for rendering the cubemap layer.
     * @type {WebGLContext}
     * @private
     */
    g(this, "gl");
    /**
     * The cubemap object that contains the shader program, buffers and uniform locations for rendering.
     * @type {Object3D}
     * @private
     */
    g(this, "cubemap");
    /**
     * The WebGL texture used for the cubemap, which is created from the defined faces.
     * This texture is used to render the cubemap in the scene.
     * @type {WebGLTexture | undefined}
     * @private
     */
    g(this, "texture");
    /**
     * The key representing the current faces definition, used to diff / track changes in the cubemap faces.
     * @type {string}
     */
    g(this, "currentFacesDefinitionKey", "");
    /**
     * The configuration options for the cubemap layer.
     * @type {CubemapLayerConstructorOptions}
     * @private
     */
    g(this, "options");
    g(this, "animationActive", !0);
    /**
     * Animates the cubemap image fading in.
     * This method gradually increases the opacity of the cubemap image to create a fade-in effect.
     *
     * @private
     */
    g(this, "imageIsAnimating", !1);
    /**
     * The delta value used for the image fade-in animation.
     * This value is incremented over time to create a smooth fade-in effect.
     * @type {number}
     * @private
     */
    g(this, "imageFadeInDelta", 0);
    const t = Yu(e, La);
    this.options = t, this.currentFacesDefinitionKey = JSON.stringify(t.faces ?? t.preset ?? t.path), this.bgColor = [0, 0, 0, 0], this.targetBgColor = Ut(t.color), this.faces = Ca(t), this.useCubemapTexture = this.faces !== null;
  }
  /**
   * Updates the cubemap object with the current faces and shader configuration.
   * This method is called when the cubemap faces change or when the layer is initialized.
   * @returns {void}
   * @remarks
   * It creates a new Object3D instance with the specified vertex and fragment shaders,
   * attributes, and uniforms. The cubemap will be rendered using this configuration.
   */
  updateCubemap({ facesNeedUpdate: e } = { facesNeedUpdate: !0 }) {
    this.useCubemapTexture = this.faces !== null;
    const t = Ku.filter((n) => n === "cubeSampler" || n === "fadeOpacity" ? this.useCubemapTexture : !0);
    this.cubemap = Mo({
      gl: this.gl,
      vertexShaderSource: Uu,
      // Because we only want to use the read the texture in gl if we're supposed to
      fragmentShaderSource: this.useCubemapTexture ? wa.replace(ka, Xu) : wa.replace(ka, ""),
      attributesKeys: Zu,
      uniformsKeys: t,
      vertices: ju,
      indices: Du
    }), this.cubeMapNeedsUpdate = e, this.useCubemapTexture && this.updateTexture(this.gl, this.faces), this.animateColorChange();
  }
  /**
   * Called when the layer is added to the map.
   * Initializes the cubemap and sets up the WebGL context.
   *
   * @param {MapSDK} map - The map instance to which this layer is added.
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
   */
  onAdd(e, t) {
    this.map = e, this.gl = t, this.updateCubemap();
  }
  /**
   * Called when the layer is removed from the map.
   * Cleans up the cubemap resources and WebGL buffers.
   *
   * @param {MapSDK} _map - The map instance from which this layer is removed.
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
   */
  onRemove(e, t) {
    this.cubemap && (this.texture && (qu(t), this.texture = void 0), t.deleteProgram(this.cubemap.shaderProgram), t.deleteBuffer(this.cubemap.positionBuffer));
  }
  /**
   * Updates the cubemap texture with the provided faces.
   * This method is called when the cubemap faces change or when the layer is initialized.
   *
   * @param {WebGLContext} gl - The WebGL context used for rendering.
   * @param {CubemapFaces} faces - The cubemap faces to be loaded into the texture.
   */
  updateTexture(e, t) {
    if (this.cubeMapNeedsUpdate === !0 && !this.imageIsAnimating) {
      if (this.cubeMapNeedsUpdate = !1, !this.useCubemapTexture)
        return;
      Vu({
        gl: e,
        faces: t,
        onReady: (n) => {
          this.texture = n, this.animateIn();
        }
      });
    }
  }
  /**
   * Called before the layer is rendered.
   * Updates the cubemap texture with the current faces.
   *
   * @param {WebGLContext} gl - The WebGL context used for rendering.
   * @param {CustomRenderMethodInput} _options - Additional options for the render method.
   */
  prerender(e, t) {
    this.faces && this.updateTexture(this.gl, this.faces);
  }
  /**
   * Lerps the background color transition of the cubemap layer.
   * This method smoothly transitions the background color from the previous color to the target color.
   *
   * @private
   */
  animateColorChange() {
    const e = () => {
      this.transitionDelta < 1 && (requestAnimationFrame(e), this.bgColor = Hu(this.previousBgColor, this.targetBgColor, this.transitionDelta), this.transitionDelta += 0.075, this.map.triggerRepaint());
    };
    requestAnimationFrame(e);
  }
  /**
   * Animates the cubemap image fading in.
   * This method gradually increases the opacity of the cubemap image to create a fade-in effect.
   * @private
   */
  async animateIn() {
    if (!this.imageIsAnimating) {
      if (!this.animationActive) {
        this.currentFadeOpacity = 1, this.imageFadeInDelta = 1, this.map.triggerRepaint();
        return;
      }
      return new Promise((e) => {
        this.imageIsAnimating = !0;
        const t = () => {
          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = ze(0, 1, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta < 1) {
            requestAnimationFrame(t);
            return;
          }
          this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();
        };
        requestAnimationFrame(t);
      });
    }
  }
  /**
   * Animates the cubemap image fading out.
   * This method gradually decreases the opacity of the cubemap image to create a fade-out effect.
   * @returns {Promise<void>} A promise that resolves when the animation is complete.
   * @private
   */
  async animateOut() {
    if (!(this.imageIsAnimating || !this.animationActive))
      return new Promise((e) => {
        const t = () => {
          if (this.imageFadeInDelta = Math.min(this.imageFadeInDelta + 0.05, 1), this.currentFadeOpacity = ze(1, 0, this.imageFadeInDelta), this.map.triggerRepaint(), this.imageFadeInDelta >= 1) {
            this.imageIsAnimating = !1, this.imageFadeInDelta = 0, e();
            return;
          }
          requestAnimationFrame(t);
        };
        requestAnimationFrame(t);
      });
  }
  setAnimationActive(e) {
    this.animationActive = e;
  }
  /**
   * Renders the cubemap layer to the WebGL context.
   * This method is called internally during the rendering phase of the map.
   *
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL context used for rendering.
   * @param {CustomRenderMethodInput} _options - Additional options for the render method.
   * @throws Error if the map, cubemap, or texture is undefined.
   */
  render(e, t) {
    if (!this.map.isGlobeProjection())
      return;
    if (this.map === void 0)
      throw new Error("[CubemapLayer]: Map is undefined");
    if (this.cubemap === void 0)
      throw new Error("[CubemapLayer]: Cubemap is undefined");
    this.texture, e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.DST_ALPHA), e.useProgram(this.cubemap.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.cubemap.positionBuffer), e.vertexAttribPointer(this.cubemap.programInfo.attributesLocations.vertexPosition, 3, e.FLOAT, !1, 0, 0), e.enableVertexAttribArray(this.cubemap.programInfo.attributesLocations.vertexPosition);
    const n = 0.1, a = 1e4, o = e.canvas, i = o.clientWidth / o.clientHeight, s = this.map.transform, l = s.fov * (Math.PI / 180), u = mt();
    xu(u, l, i, n, a), da(u, u, s.rollInRadians), fa(u, u, -s.pitchInRadians), da(u, u, s.bearingInRadians);
    const c = s.center.lat * Math.PI / 180, p = s.center.lng * Math.PI / 180;
    fa(u, u, c), wu(u, u, -p), e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.projectionMatrix, !1, u);
    const d = mt();
    if (e.uniformMatrix4fv(this.cubemap.programInfo.uniformsLocations.modelViewMatrix, !1, d), e.uniform4fv(this.cubemap.programInfo.uniformsLocations.bgColor, new Float32Array(this.bgColor)), e.uniform1f(this.cubemap.programInfo.uniformsLocations.fadeOpacity, this.currentFadeOpacity), this.useCubemapTexture && this.texture && (e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_CUBE_MAP, this.texture), e.uniform1i(this.cubemap.programInfo.uniformsLocations.cubeSampler, 0)), this.cubemap.indexBuffer === void 0)
      throw new Error("Index buffer is undefined");
    if (this.cubemap.indexBufferLength === void 0)
      throw new Error("Index buffer length is undefined");
    e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this.cubemap.indexBuffer), e.drawElements(e.TRIANGLES, this.cubemap.indexBufferLength, e.UNSIGNED_SHORT, 0);
  }
  setBgColor(e) {
    this.targetBgColor = e, this.previousBgColor = this.bgColor, this.transitionDelta = 0;
  }
  /**
   * Returns the current configuration options for the cubemap layer.
   * @returns {CubemapLayerConstructorOptions} The current configuration options.
   */
  getConfig() {
    return this.options;
  }
  /**
   * Checks if the cubemap needs to be updated based on the provided specification.
   *
   * @param {CubemapDefinition} spec - The cubemap specification to compare with the current cubemap.
   * @returns {boolean} True if the cubemap needs to be updated, false otherwise.
   */
  shouldUpdate(e) {
    const t = this.getConfig();
    if (e === void 0 && t)
      return !0;
    const n = typeof e == "boolean" ? e : Jt(e), a = Jt(t);
    return JSON.stringify(n) !== JSON.stringify(a);
  }
  async setCubemapFaces(e) {
    if (await this.animateOut(), !e.faces && !e.preset && !e.path) {
      this.faces = null, this.useCubemapTexture = !1, this.currentFacesDefinitionKey = "empty", await this.animateIn();
      return;
    }
    this.faces = Ca(e), this.currentFacesDefinitionKey = JSON.stringify(e.faces ?? e.preset ?? e.path);
  }
  /**
   * Sets the cubemap for the layer based on the provided definition.
   * This method updates the cubemap faces, background color, and triggers a repaint of the map.
   *
   * @param {CubemapDefinition} cubemap - The cubemap definition containing faces, preset, path, or color.
   * @returns {Promise<void>} A promise that resolves when the cubemap is set and the map is updated.
   * @remarks
   * This method checks if the provided cubemap definition has a color, and if so, it updates the background color.
   * It also checks if the faces definition has changed compared to the current one,
   * and if so, it updates the cubemap faces.
   * Finally, it calls `updateCubemap` to apply the changes and trigger a repaint of the map.
   */
  async setCubemap(e) {
    const t = typeof e == "boolean" ? La : e;
    this.options = t;
    const n = JSON.stringify(t.faces ?? t.preset ?? t.path), a = this.currentFacesDefinitionKey !== n;
    a && (await this.setCubemapFaces(t), this.cubeMapNeedsUpdate = !0);
    const o = Ut(t.color);
    if (t.color && this.targetBgColor.toString() !== o.toString())
      this.setBgColor(o);
    else if (!t.color && t.preset && t.preset in Ge) {
      const i = Ge[t.preset];
      this.setBgColor(Ut(i.color));
    }
    this.updateCubemap({ facesNeedUpdate: a });
  }
  /**
   * Shows the cubemap layer by setting its visibility to "visible".
   * This method is used to make the cubemap layer visible on the map.
   */
  show() {
    this.map.setLayoutProperty(this.id, "visibility", "visible");
  }
  /**
   * Hides the cubemap layer by setting its visibility to "none".
   * This method is used to remove the cubemap layer from the map without deleting it.
   */
  hide() {
    this.map.setLayoutProperty(this.id, "visibility", "none");
  }
}
function Xr(r) {
  return r ? typeof r == "boolean" ? !0 : !(!r.path && !r.preset && !r.faces && !r.color || r.preset && !(r.preset in Ge) || r.faces && (!r.faces.pX || !r.faces.nX || !r.faces.pY || !r.faces.nY || !r.faces.pZ || !r.faces.nZ)) : !1;
}
function Ca(r) {
  if (r.faces)
    return r.faces;
  if (r.preset)
    return {
      pX: `${Je}/${r.preset}/px.webp`,
      nX: `${Je}/${r.preset}/nx.webp`,
      pY: `${Je}/${r.preset}/py.webp`,
      nY: `${Je}/${r.preset}/ny.webp`,
      pZ: `${Je}/${r.preset}/pz.webp`,
      nZ: `${Je}/${r.preset}/nz.webp`
    };
  if (r.path) {
    const e = r.path.baseUrl, t = r.path.format ?? "png";
    return {
      pX: `${e}/px.${t}`,
      nX: `${e}/nx.${t}`,
      pY: `${e}/py.${t}`,
      nY: `${e}/ny.${t}`,
      pZ: `${e}/pz.${t}`,
      nZ: `${e}/nz.${t}`
    };
  }
  return null;
}
const Wu = `attribute vec3 a_position;

uniform mat4 u_matrix;
uniform mat4 u_rotationMatrix;

uniform float u_scale;

varying vec2 v_pos;
varying float v_scale;

void main() {
  v_scale = u_scale;
  v_pos = a_position.xy * u_scale;
  gl_Position = u_matrix * u_rotationMatrix * vec4(a_position, 1.0);
}
`, Ju = `precision mediump float;
varying vec2 v_pos;
      
uniform int u_stopsNumber;
uniform float u_stops[100];
uniform vec4 u_colors[100];
uniform float u_maxDistance;

varying float v_scale;

const float EPSILON = 0.000001;

vec2 center = vec2(0.0, 0.0);
void main() {
  float rawDistance = distance(center, v_pos);
  float distanceFromGlobeEdge = rawDistance - 1.0;

    vec4 color = u_colors[0];

  // if we're further than the max distance, we should not render anything.
  // This is to always render a circle, otherwise we end up rendering
  // to the corners of the plane.
  if (distance(center, v_pos) > u_maxDistance * v_scale) {
    discard;
  }

  for (int i = 1; i < 100; i++) {
    // if we're past the last stop
    // we should fill to the end with the last stop color
    if (i >= u_stopsNumber) {
      color = u_colors[i - 1];
      break;
    }

    float scaledStopPosition = u_stops[i] * pow(v_scale, 1.6);
    float lastStopValue = u_stops[i - 1];
    float thisStopValue = u_stops[i];

    // this is to avoid blending errors when the stops are the same
    // eg when you would want a sharp edge between two stops.
    // \`numbersAreEqual\` will be 1.0 if the numbers are equal, 0.0 if they are not.
    // We then subtract EPSILON from the last stop making the stop value _almost_ equal
    // to the next stop but not enough to cause blending issues.
    // It's more efficient to do this than an if / else statement.
    float numbersAreEqual = 1.0 - step(EPSILON, abs(lastStopValue - thisStopValue));
    lastStopValue = lastStopValue - numbersAreEqual * EPSILON;

    float lastScaledStopPosition = lastStopValue * pow(v_scale, 1.6);

    if (distanceFromGlobeEdge <= scaledStopPosition) {
      float stopBlendFactor = (distanceFromGlobeEdge - lastScaledStopPosition) / (scaledStopPosition - lastScaledStopPosition);
      color = mix(u_colors[i - 1], u_colors[i], stopBlendFactor);
      break;
    }
  }
  
  // gl_FragColor = color;
  gl_FragColor = vec4(color.rgb * color.a, color.a);
}
`, ke = 2, Qu = ["position"], ec = ["matrix", "rotationMatrix", "stopsNumber", "stops", "colors", "maxDistance", "scale"], tc = [
  -ke,
  -ke,
  0,
  ke,
  -ke,
  0,
  -ke,
  ke,
  0,
  ke,
  ke,
  0
], Ft = [
  [0, "rgba(176, 208, 240, 1)"],
  [0.1, "rgba(98, 168, 229, 0.3)"],
  [0.2, "rgba(98, 168, 229, 0.0)"]
], $t = 0.9, Ea = 0.06;
class Fr {
  /**
   * Creates a new RadialGradientLayer instance.
   *
   * @param {RadialGradientLayerConstructorOptions | boolean} gradient - Configuration options for the radial gradient or a boolean value.
   * If a boolean is provided, default configuration options will be used.
   * If an `RadialGradientLayerConstructorOptions` is provided, it will be merged with default options.
   */
  constructor(e) {
    g(this, "id", "Halo Layer");
    g(this, "type", "custom");
    g(this, "renderingMode", "3d");
    /**
     * The gradient definition used by this layer.
     * It contains the stops and scale for the radial gradient.
     * @private
     * @type {GradientDefinition}
     */
    g(this, "gradient");
    /**
     * The scale of the radial gradient, which determines its size.
     * This value is animated from 0 to the target scale during the layer's appearance.
     * @private
     * @type {number}
     */
    g(this, "scale", 0);
    /**
     * The animation delta value used to control the progress of the gradient's appearance animation.
     * It is incremented during each frame of the animation until it reaches 1.
     * @private
     * @type {number}
     */
    g(this, "animationDelta", 0);
    /**
     * The MapSDK instance to which this layer is added.
     * This is set when the layer is added to the map.
     * @private
     * @type {MapSDK}
     */
    g(this, "map");
    /**
     * The 3D object representing the radial gradient plane.
     * This object is created when the layer is added to the map and contains the shader program and buffers.
     * It is used for rendering the radial gradient effect.
     * @private
     * @type {Object3D<(typeof ATTRIBUTES_KEYS)[number], (typeof UNIFORMS_KEYS)[number]>}
     */
    g(this, "plane");
    /**
     * Whether the halo should be animated in and out.
     * @private
     * @type {boolean}
     */
    g(this, "animationActive", !0);
    if (typeof e == "boolean") {
      this.gradient = {
        scale: $t,
        stops: Ft
      };
      return;
    }
    const t = Aa(e);
    if (t.length > 0)
      throw new Error(`[RadialGradientLayer]: Invalid Halo specification:
 - ${t.join(`
 - `)}
    `);
    this.gradient = {
      scale: e.scale ?? $t,
      stops: e.stops ?? Ft
    };
  }
  /**
   * Adds the radial gradient layer to the specified map.
   * This method is called by the map when the layer is added to it.
   *
   * @param {MapSDK} map - The MapSDK instance to which this layer is being added
   * @param {WebGLRenderingContext | WebGL2RenderingContext} gl - The WebGL rendering context used for rendering the layer
   * @returns void
   */
  onAdd(e, t) {
    this.map = e, this.plane = Mo({
      gl: t,
      vertexShaderSource: Wu,
      fragmentShaderSource: Ju,
      attributesKeys: Qu,
      uniformsKeys: ec,
      vertices: tc
    }), this.animateIn();
  }
  /**
   * Returns the current gradient configuration of the radial gradient layer.
   *
   * @returns {GradientDefinition} The current gradient configuration.
   */
  getConfig() {
    return this.gradient;
  }
  /**
   * Checks if the gradient needs to be updated based on the provided specification.
   *
   * @param {GradientDefinition} spec - The gradient specification to compare with the current gradient.
   * @returns {boolean} True if the gradient needs to be updated, false otherwise.
   */
  shouldUpdate(e) {
    const t = this.getConfig();
    if (e === void 0 && t)
      return !0;
    const n = typeof e == "boolean" ? e : Jt(e), a = Jt(t);
    return JSON.stringify(n) !== JSON.stringify(a);
  }
  /**
   * Animates the radial gradient into view by gradually scaling from 0 to the target scale.
   *
   * This method uses requestAnimationFrame to create a smooth scaling animation effect.
   * During each frame, it:
   *   1. Interpolates the scale value between 0 and the target scale
   *   2. Increments the animation progress (animationDelta)
   *   3. Triggers a map repaint
   *
   * @private
   * @returns {Promise<void>} A promise that resolves when the animation completes
   */
  async animateIn() {
    if (!this.animationActive) {
      this.scale = this.gradient.scale, this.animationDelta = 1, this.map.triggerRepaint();
      return;
    }
    return new Promise((e) => {
      this.animationDelta = 0;
      const t = () => {
        if (this.animationDelta <= 1) {
          this.scale = ze(0, this.gradient.scale, this.animationDelta), this.animationDelta += Ea, this.map.triggerRepaint(), requestAnimationFrame(t);
          return;
        }
        e();
      };
      requestAnimationFrame(t);
    });
  }
  /**
   * Animates the radial gradient layer out by gradually reducing its scale to zero.
   *
   * This method creates a smooth transition effect by linearly interpolating the scale
   * from its current value to zero over multiple animation frames. During each frame,
   * the animation progresses by incrementing the internal animation delta value.
   *
   * The map is repainted after each animation step to reflect the updated scale.
   *
   * @private
   * @returns A Promise that resolves when the animation is complete.
   */
  async animateOut() {
    if (this.animationActive)
      return this.animationDelta = 0, new Promise((e) => {
        const t = () => {
          if (this.animationDelta < 1) {
            this.scale = ze(this.gradient.scale, 0, this.animationDelta), this.animationDelta += Ea, this.map.triggerRepaint(), requestAnimationFrame(t);
            return;
          }
          e();
        };
        t();
      });
  }
  onRemove(e, t) {
    this.plane !== void 0 && (t.deleteProgram(this.plane.shaderProgram), t.deleteBuffer(this.plane.positionBuffer));
  }
  prerender(e, t) {
  }
  render(e, t) {
    if (this.map === void 0)
      throw new Error("[RadialGradientLayer]: Map is undefined");
    if (!this.map.isGlobeProjection())
      return;
    if (this.plane === void 0)
      throw new Error("[RadialGradientLayer]: Plane is undefined");
    e.disable(e.DEPTH_TEST), e.enable(e.BLEND), e.useProgram(this.plane.shaderProgram), e.bindBuffer(e.ARRAY_BUFFER, this.plane.positionBuffer);
    const n = this.plane.programInfo.attributesLocations.position;
    e.enableVertexAttribArray(n), e.vertexAttribPointer(n, 3, e.FLOAT, !1, 0, 0);
    const a = mt(), o = this.scale;
    bu(a, a, [o, o, o]);
    const i = mt();
    vu(i, t.defaultProjectionData.mainMatrix, a);
    const s = this.plane.programInfo.uniformsLocations.matrix;
    e.uniformMatrix4fv(s, !1, i);
    const l = mt(), u = this.map.transform.cameraPosition, c = Ir(Dt(), u), p = ku(0, 1, 0), d = Dt();
    ha(d, p, c), Ir(d, d);
    const f = Dt();
    ha(f, c, d), Ir(f, f), gu(l, d[0], d[1], d[2], 0, f[0], f[1], f[2], 0, c[0], c[1], c[2], 0, 0, 0, 0, 1);
    const h = this.plane.programInfo.uniformsLocations.rotationMatrix;
    e.uniformMatrix4fv(h, !1, l);
    const m = this.gradient.stops.length, y = [], b = [];
    for (let v = 0; v <= m; v++)
      if (v < m) {
        y[v] = this.gradient.stops[v][0];
        const x = Ut(this.gradient.stops[v][1]);
        b.push(...x);
      }
    e.uniform1i(this.plane.programInfo.uniformsLocations.stopsNumber, m), e.uniform1fv(this.plane.programInfo.uniformsLocations.stops, new Float32Array(y)), e.uniform4fv(this.plane.programInfo.uniformsLocations.colors, new Float32Array(b)), e.uniform1f(this.plane.programInfo.uniformsLocations.maxDistance, ke), e.uniform1f(this.plane.programInfo.uniformsLocations.scale, o), e.drawArrays(e.TRIANGLE_STRIP, 0, 4);
  }
  /**
   * Sets a new gradient for the radial gradient layer and animates the transition.
   *
   * This method first animates the current gradient out, then updates the gradient
   * property with the new gradient definition, and finally animates the new gradient in.
   *
   * @param {GradientDefinition} gradient - The new gradient definition to set for this layer.
   * @returns {Promise<void>} A promise that resolves when the new gradient is set and animated in.
   */
  async setGradient(e) {
    if (e === !1) {
      await this.animateOut();
      return;
    }
    await this.animateOut();
    const t = Aa(e);
    if (t.length > 0)
      throw new Error(`[RadialGradientLayer]: Invalid Halo specification:
 - ${t.join(`
 - `)}
    `);
    e === !0 ? (this.gradient.scale = $t, this.gradient.stops = Ft) : (this.gradient.scale = e.scale ?? $t, this.gradient.stops = e.stops ?? Ft), await this.animateIn();
  }
  setAnimationActive(e) {
    this.animationActive = e;
  }
  show() {
    this.map.setLayoutProperty(this.id, "visibility", "visible");
  }
  hide() {
    this.map.setLayoutProperty(this.id, "visibility", "none");
  }
}
const rc = ["scale", "stops"];
function Aa(r) {
  var t;
  const e = [];
  if (typeof r == "boolean")
    return [];
  try {
    const n = Object.keys(r).filter((a) => !rc.includes(a));
    n.length > 0 && e.push(`Properties ${n.map((a) => `\`${a}\``).join(", ")} are not supported.`);
  } catch {
    e.push("Halo specification is not an object.");
  }
  return typeof r.scale != "number" && e.push("Halo `scale` property is not a number."), (!r.stops || r.stops.length === 0) && e.push("Halo `stops` property is not an array."), (t = r.stops) != null && t.some((n) => typeof n[0] != "number" || typeof n[1] != "string") && e.push("Halo `stops` property is not an array of [number, string]"), e;
}
function nc() {
  const r = "color: #3A1888; background: white; padding: 5px 0; font-weight: bold;", e = "color: #FBC935; background: white; padding: 5px; font-weight: bold;", t = "color: #F1175D; background: white; padding: 5px 0; font-weight: bold;";
  console.info(
    `%c%c%c %cMapTiler SDK JS v${oi()} %c%c%c`,
    e + "padding-right: 0;",
    r,
    t,
    "color: #333; background: white; padding: 5px 0; font-weight: bold;",
    t,
    r,
    e + "padding-left: 0;"
  );
}
const ac = {
  POINT: "POINT",
  COUNTRY: "COUNTRY"
};
let Po = class Ro extends k.Map {
  constructor(t) {
    t.logSDKVersion !== !1 && nc(), Ui(t.container), t.apiKey && (j.apiKey = t.apiKey);
    const { style: n, requiresUrlMonitoring: a, isFallback: o } = ua(t.style);
    o && console.warn(
      "Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."
    ), j.apiKey || console.warn("MapTiler Cloud API key is not set. Visit https://maptiler.com and try Cloud for free!");
    const i = location.hash;
    let s = {
      compact: !1
    };
    t.customAttribution ? s.customAttribution = t.customAttribution : t.attributionControl && typeof t.attributionControl == "object" && (s = {
      ...s,
      ...t.attributionControl
    });
    const l = {
      ...t,
      style: n,
      maplibreLogo: !1,
      transformRequest: Un(t.transformRequest),
      attributionControl: t.forceNoAttributionControl === !0 ? !1 : s
    };
    delete l.style;
    super(l);
    g(this, "telemetry");
    g(this, "space");
    g(this, "halo");
    g(this, "options");
    g(this, "isTerrainEnabled", !1);
    g(this, "terrainExaggeration", 1);
    g(this, "primaryLanguage");
    g(this, "terrainGrowing", !1);
    g(this, "terrainFlattening", !1);
    g(this, "minimap");
    g(this, "forceLanguageUpdate");
    g(this, "languageAlwaysBeenStyle");
    g(this, "isReady", !1);
    g(this, "terrainAnimationDuration", 1e3);
    g(this, "monitoredStyleUrls");
    g(this, "styleInProcess", !1);
    g(this, "curentProjection");
    g(this, "originalLabelStyle", new window.Map());
    g(this, "isStyleLocalized", !1);
    g(this, "languageIsUpdated", !1);
    g(this, "spaceboxLoadingState", {
      styleLoadCallbackSet: !1,
      styleLoadedCallbackFired: !1
    });
    this.options = t, this.setStyle(n), a && this.monitorStyleUrl(n);
    const u = () => {
      let h = "The distant style could not be loaded.";
      this.getStyle() ? h += " Leaving the style as is." : (this.setStyle(ft.STREETS), h += `Loading default MapTiler Cloud style "${ft.STREETS.getDefaultVariant().getId()}" as a fallback.`), console.warn(h);
    };
    if (this.on("style.load", () => {
      this.styleInProcess = !1, (typeof t.rtlTextPlugin == "string" || typeof t.rtlTextPlugin > "u") && $i(t.rtlTextPlugin);
    }), this.on("error", (h) => {
      if (h.error instanceof k.AJAXError) {
        const y = h.error.url, b = new URL(y);
        b.search = "";
        const v = b.href;
        this.monitoredStyleUrls && this.monitoredStyleUrls.has(v) && (this.monitoredStyleUrls.delete(v), u());
        return;
      }
      if (this.styleInProcess) {
        u();
        return;
      }
    }), j.caching && !jr && console.warn("The cache API is only available in secure contexts. More info at https://developer.mozilla.org/en-US/docs/Web/API/Cache"), j.caching && jr && Fi(), typeof t.language > "u")
      this.primaryLanguage = j.primaryLanguage;
    else {
      const h = zn(t.language, z);
      this.primaryLanguage = h ?? j.primaryLanguage;
    }
    this.forceLanguageUpdate = !(this.primaryLanguage === z.STYLE || this.primaryLanguage === z.STYLE_LOCK), this.languageAlwaysBeenStyle = this.primaryLanguage === z.STYLE, this.terrainExaggeration = t.terrainExaggeration ?? this.terrainExaggeration, this.curentProjection = t.projection, this.on("style.load", (h) => {
      this.curentProjection === "mercator" ? this.setProjection({ type: "mercator" }) : this.curentProjection === "globe" && this.setProjection({ type: "globe" });
    }), this.once("styledata", async () => {
      if (!t.geolocate || t.center || t.hash && i)
        return;
      try {
        if (t.geolocate === ac.COUNTRY) {
          await this.fitToIpBounds();
          return;
        }
      } catch (y) {
        console.warn(y.message);
      }
      let h;
      try {
        await this.centerOnIpPoint(t.zoom), h = this.getCameraHash();
      } catch (y) {
        console.warn(y.message);
      }
      (await navigator.permissions.query({
        name: "geolocation"
      })).state === "granted" && navigator.geolocation.getCurrentPosition(
        // success callback
        (y) => {
          h === this.getCameraHash() && (this.terrain ? this.easeTo({
            center: [y.coords.longitude, y.coords.latitude],
            zoom: t.zoom || 12,
            duration: 2e3
          }) : this.once("terrain", () => {
            this.easeTo({
              center: [y.coords.longitude, y.coords.latitude],
              zoom: t.zoom || 12,
              duration: 2e3
            });
          }));
        },
        // error callback
        null,
        // options
        {
          maximumAge: 24 * 3600 * 1e3,
          // a day in millisec
          timeout: 5e3,
          // milliseconds
          enableHighAccuracy: !1
        }
      );
    }), this.on("styledata", () => {
      this.setPrimaryLanguage(this.primaryLanguage);
    }), this.on("styledata", () => {
      this.getTerrain() === null && this.isTerrainEnabled && this.enableTerrain(this.terrainExaggeration);
    }), this.once("load", async () => {
      let h = { logo: null };
      try {
        const m = Object.keys(this.style.tileManagers).map((v) => this.getSource(v)).filter((v) => v && "url" in v && typeof v.url == "string" && v.url.includes("tiles.json")), y = new URL(m[0].url);
        y.searchParams.has("key") || y.searchParams.append("key", j.apiKey), h = await (await fetch(y.href)).json();
      } catch {
      }
      if (t.customControls) {
        const m = "[data-maptiler-control-group]", y = "[data-maptiler-control]", b = (T) => {
          let N = T.dataset.maptilerControl;
          return (N === "true" || N === "") && (N = void 0), N;
        }, v = (T) => T.dataset.maptilerPosition;
        let x = [...this._container.ownerDocument.querySelectorAll(m)], E = [...this._container.ownerDocument.querySelectorAll(y)].filter(
          (T) => T.closest(m) === null
        );
        if (typeof t.customControls == "string") {
          const T = t.customControls;
          x = x.filter((N) => N.matches(T) || N.closest(T) !== null), E = E.filter((N) => N.matches(T) || N.closest(T) !== null);
        }
        for (const T of x) {
          const N = new Kr(T);
          this.addControl(N, v(T));
          for (const ge of T.querySelectorAll(y))
            N.configureGroupItem(ge, b(ge));
        }
        for (const T of E)
          this.addControl(new Kr(T, b(T)), v(T));
        const C = () => {
          const { lng: T, lat: N } = this.getCenter();
          this._container.style.setProperty("--maptiler-center-lng", String(T)), this._container.style.setProperty("--maptiler-center-lat", String(N)), this._container.style.setProperty("--maptiler-zoom", String(this.getZoom())), this._container.style.setProperty("--maptiler-bearing", String(this.getBearing())), this._container.style.setProperty("--maptiler-pitch", String(this.getPitch())), this._container.style.setProperty("--maptiler-roll", String(this.getRoll())), this._container.style.setProperty("--maptiler-is-globe-projection", String(this.isGlobeProjection())), this._container.style.setProperty("--maptiler-has-terrain", String(this.hasTerrain()));
        };
        C(), this.on("render", C);
      }
      if (t.forceNoAttributionControl !== !0)
        if ("logo" in h && h.logo) {
          const m = h.logo;
          this.addControl(new $n({ logoURL: m }), t.logoPosition);
        } else t.maptilerLogo && this.addControl(new $n(), t.logoPosition);
      if (t.scaleControl) {
        const m = t.scaleControl === !0 || t.scaleControl === void 0 ? "bottom-right" : t.scaleControl, y = new Ti({ unit: j.unit });
        this.addControl(y, m), j.on("unit", (b) => {
          y.setUnit(b);
        });
      }
      if (t.navigationControl !== !1) {
        const m = t.navigationControl === !0 || t.navigationControl === void 0 ? "top-right" : t.navigationControl;
        this.addControl(new pu(), m);
      }
      if (t.geolocateControl !== !1) {
        const m = t.geolocateControl === !0 || t.geolocateControl === void 0 ? "top-right" : t.geolocateControl;
        this.addControl(
          // new maplibregl.GeolocateControl({
          new du({
            positionOptions: {
              enableHighAccuracy: !0,
              maximumAge: 0,
              timeout: 6e3
            },
            fitBoundsOptions: {
              maxZoom: 15
            },
            trackUserLocation: !0,
            showAccuracyCircle: !0,
            showUserLocation: !0
          }),
          m
        );
      }
      if (t.terrainControl) {
        const m = t.terrainControl === !0 || t.terrainControl === void 0 ? "top-right" : t.terrainControl;
        this.addControl(new cu(), m);
      }
      if (t.projectionControl) {
        const m = t.projectionControl === !0 || t.projectionControl === void 0 ? "top-right" : t.projectionControl;
        this.addControl(new mu(), m);
      }
      if (t.fullscreenControl) {
        const m = t.fullscreenControl === !0 || t.fullscreenControl === void 0 ? "top-right" : t.fullscreenControl;
        this.addControl(new _i({}), m);
      }
      this.isReady = !0, this.fire("ready", { target: this });
    });
    let c = !1, p = !1, d;
    this.once("ready", () => {
      c = !0, p && this.fire("loadWithTerrain", d);
    }), this.once("style.load", () => {
      const { minimap: h } = t;
      if (typeof h == "object") {
        const {
          zoom: m,
          center: y,
          style: b,
          language: v,
          apiKey: x,
          maptilerLogo: E,
          canvasContextAttributes: C,
          refreshExpiredTiles: T,
          maxBounds: N,
          scrollZoom: ge,
          minZoom: Xe,
          maxZoom: Ye,
          boxZoom: X,
          locale: We,
          fadeDuration: li,
          crossSourceCollisions: ui,
          clickTolerance: ci,
          bounds: pi,
          fitBoundsOptions: fi,
          pixelRatio: di,
          validateStyle: hi
        } = t;
        this.minimap = new _r(h, {
          zoom: m,
          center: y,
          style: b,
          language: v,
          apiKey: x,
          container: "null",
          maptilerLogo: E,
          canvasContextAttributes: C,
          refreshExpiredTiles: T,
          maxBounds: N,
          scrollZoom: ge,
          minZoom: Xe,
          maxZoom: Ye,
          boxZoom: X,
          locale: We,
          fadeDuration: li,
          crossSourceCollisions: ui,
          clickTolerance: ci,
          bounds: pi,
          fitBoundsOptions: fi,
          pixelRatio: di,
          validateStyle: hi
        }), this.addControl(this.minimap, h.position ?? "bottom-left");
      } else h === !0 ? (this.minimap = new _r({}, t), this.addControl(this.minimap, "bottom-left")) : h !== void 0 && h !== !1 && (this.minimap = new _r({}, t), this.addControl(this.minimap, h));
    });
    const f = (h) => {
      h.terrain && (p = !0, d = {
        type: "loadWithTerrain",
        target: this,
        terrain: h.terrain
      }, this.off("terrain", f), c && this.fire("loadWithTerrain", d));
    };
    this.on("terrain", f), t.terrain && this.enableTerrain(t.terrainExaggeration ?? this.terrainExaggeration), this.once("load", () => {
      this.getCanvas().addEventListener("webglcontextlost", (m) => {
        if (this._removed === !0) {
          console.warn("[webglcontextlost]", "WebGL context lost after map removal. This is harmless.");
          return;
        }
        console.warn("[webglcontextlost]", "Unexpected loss of WebGL context!"), this.fire("webglContextLost", m);
      });
      const h = this.getLayersOrder()[0];
      t.space && this.initSpace({ options: t, before: h }), t.halo && this.initHalo({ options: t, before: h });
    }), this.telemetry = new yu(this);
  }
  getSpace() {
    return this.space;
  }
  /**
   * Sets the space for the map.
   * @param {CubemapDefinition} space the `CubemapDefinition` options to set.
   * @remarks This method, at present, ** overwrites ** the current config.
   * If an option is not set it will internally revert to the default option
   * unless explicitly set when calling.
   */
  setSpace(t, n = !0) {
    if (n && (this.options.space = t), t === !1) {
      this.space = void 0;
      return;
    }
    if (this.space) {
      this.space.setCubemap(t), this.getLayer(this.space.id) || this.addLayer(this.space, this.getLayersOrder()[0]);
      return;
    }
    this.space = new Or(t), this.once("load", () => {
      const a = this.getLayersOrder()[0];
      this.space && this.addLayer(this.space, a);
    });
  }
  /**
   * Enables the animations for the space layer.
   */
  enableSpaceAnimations() {
    this.setSpaceAnimationActive(!0);
  }
  /**
   * Disables the animations for the space layer.
   */
  disableSpaceAnimations() {
    this.setSpaceAnimationActive(!1);
  }
  /**
   * Enables the animations for the halo layer.
   */
  enableHaloAnimations() {
    this.setHaloAnimationActive(!0);
  }
  /**
   * Disables the animations for the halo layer.
   */
  disableHaloAnimations() {
    this.setHaloAnimationActive(!1);
  }
  /**
   * Sets whether the halo layer should be animated in and out.
   * @param active - Whether the animation should be active.
   */
  setHaloAnimationActive(t) {
    this.halo ? this.halo.setAnimationActive(t) : this.once("load", () => {
      var n;
      (n = this.halo) == null || n.setAnimationActive(t);
    });
  }
  /**
   * Sets whether the space layer should be animated in and out.
   * @param active - Whether the animation should be active.
   */
  setSpaceAnimationActive(t) {
    this.space ? this.space.setAnimationActive(t) : this.once("load", () => {
      var n;
      (n = this.space) == null || n.setAnimationActive(t);
    });
  }
  setSpaceFromStyle({ style: t }) {
    var i, s, l, u, c;
    if (this.options.space === !1)
      return;
    if (this.options.space !== !0 && Xr(this.options.space)) {
      this.setSpace(this.options.space);
      return;
    }
    const n = (s = (i = t.metadata) == null ? void 0 : i.maptiler) == null ? void 0 : s.space, a = Xr(n);
    if (JSON.stringify((l = this.space) == null ? void 0 : l.getConfig()) === JSON.stringify(n)) {
      if (this.space && !this.getLayer(this.space.id)) {
        const p = this.getLayersOrder()[0];
        this.addLayer(this.space, p);
      }
      return;
    }
    if (a) {
      this.setSpace(n, !1);
      return;
    }
    if (this.options.space === !0) {
      this.setSpace(!0);
      return;
    }
    if (((u = this.space) == null ? void 0 : u.getConfig()) && n === void 0) {
      this.setSpace({ color: "transparent" }, !1), this.removeLayer(((c = this.space) == null ? void 0 : c.id) ?? "");
      return;
    }
    if (this.space && this.isGlobeProjection()) {
      if (!this.getLayer(this.space.id)) {
        const p = this.getLayersOrder()[0];
        this.addLayer(this.space, p);
      }
      this.space.setCubemap(n);
    }
  }
  setHaloFromStyle({ style: t }) {
    var o, i, s;
    if (this.options.halo === !1)
      return;
    const n = (o = t.metadata) == null ? void 0 : o.maptiler;
    if (JSON.stringify((i = this.halo) == null ? void 0 : i.getConfig()) === JSON.stringify(n == null ? void 0 : n.halo)) {
      if (this.halo && !this.getLayer(this.halo.id)) {
        const l = this.getLayersOrder().indexOf(((s = this.space) == null ? void 0 : s.id) ?? "") + 1, u = this.getLayersOrder()[l];
        this.addLayer(this.halo, u);
      }
      return;
    }
    if (!(n != null && n.halo) && !this.options.halo) {
      this.setHalo({
        stops: [
          [0, "transparent"],
          [0.01, "transparent"]
        ],
        scale: 1
      });
      return;
    }
    (() => {
      var l;
      if (this.halo) {
        if (!this.getLayer(this.halo.id)) {
          const c = this.getLayersOrder().indexOf(((l = this.space) == null ? void 0 : l.id) ?? "") + 1, p = this.getLayersOrder()[c];
          this.addLayer(this.halo, p);
        }
        const u = (n == null ? void 0 : n.halo) ?? this.options.halo;
        u && this.halo.setGradient(u);
      }
    })();
  }
  initSpace({ options: t = this.options, before: n, spec: a }) {
    if (this.space) {
      this.getLayer(this.space.id) || this.addLayer(this.space, n);
      return;
    }
    if (t.space === !1) return;
    if (t.space) {
      this.space = new Or(t.space), this.addLayer(this.space, n);
      return;
    }
    const o = a;
    o && (this.space = new Or(o), this.addLayer(this.space, n));
  }
  initHalo({ options: t = this.options, before: n, spec: a }) {
    if (this.halo && this.getLayer(this.halo.id) || t.halo === !1) return;
    const o = a;
    if (t.halo) {
      this.halo = new Fr(t.halo), this.addLayer(this.halo, n);
      return;
    }
    o && (this.halo = new Fr(o), this.addLayer(this.halo, n));
  }
  getHalo() {
    return this.halo;
  }
  setHalo(t) {
    if (this.options.halo = t, !!this.isGlobeProjection()) {
      if (this.halo) {
        this.halo.setGradient(t);
        return;
      }
      this.halo = new Fr(t), this.once("load", () => {
        var s;
        const n = this.getLayersOrder(), a = n[0], o = n.indexOf(((s = this.space) == null ? void 0 : s.id) ?? "") + 2, i = n[o];
        this.halo && this.addLayer(this.halo, this.space ? i : a);
      });
    }
  }
  /**
   * Recreates the map instance with the same options.
   * Useful for WebGL context loss.
   */
  recreate() {
    const t = {
      center: this.getCenter(),
      zoom: this.getZoom(),
      bearing: this.getBearing(),
      pitch: this.getPitch()
    };
    this.remove(), Object.assign(this, new Ro({ ...this.options })), this.once("load", () => {
      this.jumpTo(t);
    });
  }
  /**
   * Set the duration (millisec) of the terrain animation for growing or flattening.
   * Must be positive. (Built-in default: `1000` milliseconds)
   */
  setTerrainAnimationDuration(t) {
    this.terrainAnimationDuration = Math.max(t, 0);
  }
  /**
   * Awaits for _this_ Map instance to be "loaded" and returns a Promise to the Map.
   * If _this_ Map instance is already loaded, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "load" event.
   * @returns
   */
  async onLoadAsync() {
    return new Promise((t) => {
      if (this.loaded()) {
        t(this);
        return;
      }
      this.once("load", () => {
        t(this);
      });
    });
  }
  /**
   * Awaits for _this_ Map instance to be "ready" and returns a Promise to the Map.
   * If _this_ Map instance is already ready, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "ready" event.
   * A map instance is "ready" when all the controls that can be managed by the contructor are
   * dealt with. This happens after the "load" event, due to the asynchronous nature
   * of some built-in controls.
   */
  async onReadyAsync() {
    return new Promise((t) => {
      if (this.isReady) {
        t(this);
        return;
      }
      this.once("ready", () => {
        t(this);
      });
    });
  }
  /**
   * Awaits for _this_ Map instance to be "loaded" as well as with terrain being non-null for the first time
   * and returns a Promise to the Map.
   * If _this_ Map instance is already loaded with terrain, the Promise is resolved directly,
   * otherwise, it is resolved as a result of the "loadWithTerrain" event.
   * @returns
   */
  async onLoadWithTerrainAsync() {
    return new Promise((t) => {
      if (this.isReady && this.terrain) {
        t(this);
        return;
      }
      this.once("loadWithTerrain", () => {
        t(this);
      });
    });
  }
  monitorStyleUrl(t) {
    typeof this.monitoredStyleUrls > "u" && (this.monitoredStyleUrls = /* @__PURE__ */ new Set());
    const n = new URL(t);
    n.search = "", this.monitoredStyleUrls.add(n.href);
  }
  /**
   * Update the style of the map.
   * Can be:
   * - a full style URL (possibly with API key)
   * - a shorthand with only the MapTIler style name (eg. `"streets-v2"`)
   * - a longer form with the prefix `"maptiler://"` (eg. `"maptiler://streets-v2"`)
   */
  setStyle(t, n) {
    var c, p, d, f, h;
    this.originalLabelStyle.clear(), (c = this.minimap) == null || c.setStyle(t), this.forceLanguageUpdate = !0, this.once("idle", () => {
      this.forceLanguageUpdate = !1;
    });
    const a = ua(t);
    if (a.requiresUrlMonitoring && this.monitorStyleUrl(a.style), a.isFallback) {
      if (this.getStyle())
        return console.warn(
          "[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Keeping the curent style instead."
        ), this;
      console.warn(
        "[Map.setStyle]: Invalid style. A style must be a valid URL to a style.json, a JSON string representing a valid StyleSpecification or a valid StyleSpecification object. Fallback to default MapTiler style."
      );
    }
    this.spaceboxLoadingState.styleLoadedCallbackFired = !1, this.spaceboxLoadingState.styleLoadCallbackSet = !1;
    const o = this.getStyle(), i = a.style;
    try {
      super.setStyle(a.style, { ...n, diff: typeof a.style != "string" }), this.styleInProcess = !0;
    } catch (m) {
      this.styleInProcess = !1, console.error("[Map.setStyle]: Error while setting style:", m);
    }
    const s = () => {
      const m = a.style;
      if (!m.projection || m.projection.type === "mercator") {
        console.warn("[Map.setStyle]: Neither space nor halo is supported for mercator projection. Ignoring...");
        return;
      }
      this.setSpaceFromStyle({ style: a.style }), this.setHaloFromStyle({ style: a.style });
    }, l = (m) => {
      var b, v, x, E;
      const y = (m == null ? void 0 : m.target.getStyle()) ?? a.style;
      if (!this.spaceboxLoadingState.styleLoadedCallbackFired && (this.spaceboxLoadingState.styleLoadedCallbackFired = !0, this.spaceboxLoadingState.styleLoadCallbackSet = !1, typeof y != "string"))
        try {
          const C = this.getLayersOrder()[0];
          this.space ? this.setSpaceFromStyle({ style: y }) : this.initSpace({ before: C, spec: (v = (b = y.metadata) == null ? void 0 : b.maptiler) == null ? void 0 : v.space }), this.halo ? this.setHaloFromStyle({ style: y }) : this.initHalo({ before: C, spec: (E = (x = y.metadata) == null ? void 0 : x.maptiler) == null ? void 0 : E.halo });
        } catch (C) {
          console.error(C);
        }
    };
    return typeof a.style == "string" || a.requiresUrlMonitoring ? (this.once("style.load", l), this) : (requestIdleCallback(() => {
      try {
        l();
      } catch (m) {
        console.error(m);
      }
    }), this.spaceboxLoadingState.styleLoadCallbackSet ? ((p = o == null ? void 0 : o.terrain) == null ? void 0 : p.source) !== ((d = i == null ? void 0 : i.terrain) == null ? void 0 : d.source) || ((f = o == null ? void 0 : o.terrain) == null ? void 0 : f.exaggeration) !== ((h = i == null ? void 0 : i.terrain) == null ? void 0 : h.exaggeration) ? (this.once("terrain", s), this) : this : (this.once("style.load", l), this.once("projection.change", l), this.spaceboxLoadingState.styleLoadCallbackSet = !0, this));
  }
  /**
   * Adds a [MapLibre style layer](https://maplibre.org/maplibre-style-spec/layers)
   * to the map's style.
   *
   * A layer defines how data from a specified source will be styled. Read more about layer types
   * and available paint and layout properties in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/layers).
   *
   * @param layer - The layer to add,
   * conforming to either the MapLibre Style Specification's [layer definition](https://maplibre.org/maplibre-style-spec/layers) or,
   * less commonly, the {@link CustomLayerInterface} specification.
   * The MapLibre Style Specification's layer definition is appropriate for most layers.
   *
   * @param beforeId - The ID of an existing layer to insert the new layer before,
   * resulting in the new layer appearing visually beneath the existing layer.
   * If this argument is not specified, the layer will be appended to the end of the layers array
   * and appear visually above all other layers.
   *
   * @returns `this`
   */
  addLayer(t, n) {
    var a;
    return (a = this.minimap) == null || a.addLayer(t, n), super.addLayer(t, n);
  }
  /**
   * Moves a layer to a different z-position.
   *
   * @param id - The ID of the layer to move.
   * @param beforeId - The ID of an existing layer to insert the new layer before. When viewing the map, the `id` layer will appear beneath the `beforeId` layer. If `beforeId` is omitted, the layer will be appended to the end of the layers array and appear above all other layers on the map.
   * @returns `this`
   *
   * @example
   * Move a layer with ID 'polygon' before the layer with ID 'country-label'. The `polygon` layer will appear beneath the `country-label` layer on the map.
   * ```ts
   * map.moveLayer('polygon', 'country-label');
   * ```
   */
  moveLayer(t, n) {
    var a;
    return (a = this.minimap) == null || a.moveLayer(t, n), super.moveLayer(t, n);
  }
  /**
   * Removes the layer with the given ID from the map's style.
   *
   * An {@link ErrorEvent} will be fired if the image parameter is invald.
   *
   * @param id - The ID of the layer to remove
   * @returns `this`
   *
   * @example
   * If a layer with ID 'state-data' exists, remove it.
   * ```ts
   * if (map.getLayer('state-data')) map.removeLayer('state-data');
   * ```
   */
  removeLayer(t) {
    var n;
    return (n = this.minimap) == null || n.removeLayer(t), super.removeLayer(t);
  }
  /**
   * Sets the zoom extent for the specified style layer. The zoom extent includes the
   * [minimum zoom level](https://maplibre.org/maplibre-style-spec/layers/#minzoom)
   * and [maximum zoom level](https://maplibre.org/maplibre-style-spec/layers/#maxzoom))
   * at which the layer will be rendered.
   *
   * Note: For style layers using vector sources, style layers cannot be rendered at zoom levels lower than the
   * minimum zoom level of the _source layer_ because the data does not exist at those zoom levels. If the minimum
   * zoom level of the source layer is higher than the minimum zoom level defined in the style layer, the style
   * layer will not be rendered at all zoom levels in the zoom range.
   */
  setLayerZoomRange(t, n, a) {
    var o;
    return (o = this.minimap) == null || o.setLayerZoomRange(t, n, a), super.setLayerZoomRange(t, n, a);
  }
  /**
   * Sets the filter for the specified style layer.
   *
   * Filters control which features a style layer renders from its source.
   * Any feature for which the filter expression evaluates to `true` will be
   * rendered on the map. Those that are false will be hidden.
   *
   * Use `setFilter` to show a subset of your source data.
   *
   * To clear the filter, pass `null` or `undefined` as the second parameter.
   */
  setFilter(t, n, a) {
    var o;
    return (o = this.minimap) == null || o.setFilter(t, n, a), super.setFilter(t, n, a);
  }
  /**
   * Sets the value of a paint property in the specified style layer.
   *
   * @param layerId - The ID of the layer to set the paint property in.
   * @param name - The name of the paint property to set.
   * @param value - The value of the paint property to set.
   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
   * @param options - Options object.
   * @returns `this`
   * @example
   * ```ts
   * map.setPaintProperty('my-layer', 'fill-color', '#faafee');
   * ```
   */
  setPaintProperty(t, n, a, o) {
    var i;
    return (i = this.minimap) == null || i.setPaintProperty(t, n, a, o), super.setPaintProperty(t, n, a, o);
  }
  /**
   * Sets the value of a layout property in the specified style layer.
   * Layout properties define how the layer is styled.
   * Layout properties for layers of the same type are documented together.
   * Layers of different types have different layout properties.
   * See the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/) for the complete list of layout properties.
   * @param layerId - The ID of the layer to set the layout property in.
   * @param name - The name of the layout property to set.
   * @param value - The value of the layout property to set.
   * Must be of a type appropriate for the property, as defined in the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/).
   * @param options - Options object.
   * @returns `this`
   */
  setLayoutProperty(t, n, a, o) {
    var i;
    return (i = this.minimap) == null || i.setLayoutProperty(t, n, a, o), super.setLayoutProperty(t, n, a, o);
  }
  /**
   * Sets the value of the style's glyphs property.
   *
   * @param glyphsUrl - Glyph URL to set. Must conform to the [MapLibre Style Specification](https://maplibre.org/maplibre-style-spec/glyphs/).
   * @param options - Options object.
   * @returns `this`
   * @example
   * ```ts
   * map.setGlyphs('https://demotiles.maplibre.org/font/{fontstack}/{range}.pbf');
   * ```
   */
  setGlyphs(t, n) {
    var a;
    return (a = this.minimap) == null || a.setGlyphs(t, n), super.setGlyphs(t, n);
  }
  getStyleLanguage() {
    return !this.style || !this.style.stylesheet || !this.style.stylesheet.metadata || typeof this.style.stylesheet.metadata != "object" ? null : "maptiler:language" in this.style.stylesheet.metadata && typeof this.style.stylesheet.metadata["maptiler:language"] == "string" ? ki(this.style.stylesheet.metadata["maptiler:language"]) : null;
  }
  /**
   * Define the primary language of the map. Note that not all the languages shorthands provided are available.
   */
  setLanguage(t) {
    var n;
    (n = this.minimap) == null || n.map.setLanguage(t), this.onStyleReady(() => {
      this.setPrimaryLanguage(t);
    });
  }
  /**
   * Define the primary language of the map. Note that not all the languages shorthands provided are available.
   */
  setPrimaryLanguage(t) {
    const n = this.getStyleLanguage(), a = zn(t, z);
    if (!a) {
      console.warn(`The language "${a}" is not supported.`);
      return;
    }
    if (!(a.flag === z.STYLE.flag && n && (n.flag === z.AUTO.flag || n.flag === z.VISITOR.flag)) && (a.flag !== z.STYLE.flag && (this.languageAlwaysBeenStyle = !1), this.languageAlwaysBeenStyle || this.primaryLanguage === a && !this.forceLanguageUpdate))
      return;
    if (this.primaryLanguage.flag === z.STYLE_LOCK.flag) {
      console.warn("The language cannot be changed because this map has been instantiated with the STYLE_LOCK language flag.");
      return;
    }
    this.primaryLanguage = a;
    let o = a;
    if (a.flag === z.STYLE.flag) {
      if (!n) {
        console.warn("The style has no default languages or has an invalid one.");
        return;
      }
      o = n;
    }
    let i = z.LOCAL.flag, s = ["get", i];
    o.flag === z.VISITOR.flag ? (i = Fn().flag, s = [
      "case",
      ["all", ["has", i], ["has", z.LOCAL.flag]],
      [
        "case",
        ["==", ["get", i], ["get", z.LOCAL.flag]],
        ["get", z.LOCAL.flag],
        ["format", ["get", i], { "font-scale": 0.8 }, `
`, ["get", z.LOCAL.flag], { "font-scale": 1.1 }]
      ],
      ["get", z.LOCAL.flag]
    ]) : o.flag === z.VISITOR_ENGLISH.flag ? (i = z.ENGLISH.flag, s = [
      "case",
      ["all", ["has", i], ["has", z.LOCAL.flag]],
      [
        "case",
        ["==", ["get", i], ["get", z.LOCAL.flag]],
        ["get", z.LOCAL.flag],
        ["format", ["get", i], { "font-scale": 0.8 }, `
`, ["get", z.LOCAL.flag], { "font-scale": 1.1 }]
      ],
      ["get", z.LOCAL.flag]
    ]) : o.flag === z.AUTO.flag ? (i = Fn().flag, s = ["coalesce", ["get", i], ["get", z.LOCAL.flag]]) : o === z.LOCAL ? (i = z.LOCAL.flag, s = ["get", i]) : (i = o.flag, s = ["coalesce", ["get", i], ["get", z.LOCAL.flag]]);
    const { layers: l } = this.getStyle(), u = this.originalLabelStyle.size === 0;
    if (u) {
      const c = Ki(l, this);
      this.isStyleLocalized = Object.keys(c.localized).length > 0;
    }
    for (const c of l) {
      if (c.type !== "symbol")
        continue;
      const p = c, d = this.getSource(p.source);
      if (!d || !("url" in d && typeof d.url == "string") || new URL(d.url).host !== W.maptilerApiHost)
        continue;
      const { id: h, layout: m } = p;
      if (!m || !("text-field" in m))
        continue;
      let y;
      if (u ? (y = this.getLayoutProperty(h, "text-field"), this.originalLabelStyle.set(h, y)) : y = this.originalLabelStyle.get(h), typeof y == "string") {
        const { contains: b, exactMatch: v } = qi(y, this.isStyleLocalized);
        if (!b) continue;
        if (v)
          this.setLayoutProperty(h, "text-field", s);
        else {
          const x = Vi(y, s, this.isStyleLocalized);
          this.setLayoutProperty(h, "text-field", x);
        }
      } else {
        const b = Bi(y, s, this.isStyleLocalized);
        this.setLayoutProperty(h, "text-field", b);
      }
    }
    this.languageIsUpdated = !0;
  }
  /**
   * Get the primary language
   * @returns
   */
  getPrimaryLanguage() {
    return this.primaryLanguage;
  }
  /**
   * Get the exaggeration factor applied to the terrain
   * @returns
   */
  getTerrainExaggeration() {
    return this.terrainExaggeration;
  }
  /**
   * Know if terrian is enabled or not
   * @returns
   */
  hasTerrain() {
    return this.isTerrainEnabled;
  }
  growTerrain(t) {
    if (!this.terrain)
      return;
    const n = performance.now(), a = this.terrain.exaggeration, o = t - a, i = () => {
      if (!this.terrain || this.terrainFlattening)
        return;
      const s = (performance.now() - n) / this.terrainAnimationDuration;
      if (s < 0.99) {
        const l = 1 - (1 - s) ** 4, u = a + l * o;
        this.terrain.exaggeration = u, requestAnimationFrame(i);
      } else
        this.terrainGrowing = !1, this.terrainFlattening = !1, this.terrain.exaggeration = t, this.fire("terrainAnimationStop", { terrain: this.terrain });
      this._elevationFreeze = !1, this.triggerRepaint();
    };
    !this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = !0, this.terrainFlattening = !1, requestAnimationFrame(i);
  }
  /**
   * Enables the 3D terrain visualization
   */
  enableTerrain(t = this.terrainExaggeration) {
    if (t < 0) {
      console.warn("Terrain exaggeration cannot be negative.");
      return;
    }
    const n = (o) => {
      !this.terrain || o.type !== "data" || o.dataType !== "source" || !("source" in o) || o.sourceId !== "maptiler-terrain" || o.source.type !== "raster-dem" || o.isSourceLoaded && (this.off("data", n), this.growTerrain(t));
    }, a = () => {
      this.isTerrainEnabled = !0, this.terrainExaggeration = t, this.on("data", n), this.addSource(W.terrainSourceId, {
        type: "raster-dem",
        url: W.terrainSourceURL
      }), this.setTerrain({
        source: W.terrainSourceId,
        exaggeration: 0
      });
    };
    if (this.getTerrain()) {
      this.isTerrainEnabled = !0, this.growTerrain(t);
      return;
    }
    if (this.loaded() || this.isTerrainEnabled)
      a();
    else {
      const o = () => {
        this.getTerrain() && this.getSource(W.terrainSourceId) || a();
      };
      this.once("load", () => {
        o();
      }), this.once("moveend", () => {
        o();
      });
    }
  }
  /**
   * Disable the 3D terrain visualization
   */
  disableTerrain() {
    if (!this.terrain)
      return;
    this.isTerrainEnabled = !1;
    const t = performance.now(), n = this.terrain.exaggeration, a = () => {
      if (!this.terrain || this.terrainGrowing)
        return;
      const o = (performance.now() - t) / this.terrainAnimationDuration;
      if (this._elevationFreeze = !1, o < 0.99) {
        const i = (1 - o) ** 4, s = n * i;
        this.terrain.exaggeration = s, requestAnimationFrame(a);
      } else
        this.terrain.exaggeration = 0, this.terrainGrowing = !1, this.terrainFlattening = !1, this.setTerrain(), this.getSource(W.terrainSourceId) && this.removeSource(W.terrainSourceId), this.fire("terrainAnimationStop", { terrain: null });
      this.triggerRepaint();
    };
    !this.terrainGrowing && !this.terrainFlattening && this.fire("terrainAnimationStart", { terrain: this.terrain }), this.terrainGrowing = !1, this.terrainFlattening = !0, requestAnimationFrame(a);
  }
  /**
   * Sets the 3D terrain exageration factor.
   * If the terrain was not enabled prior to the call of this method,
   * the method `.enableTerrain()` will be called.
   * If `animate` is `true`, the terrain transformation will be animated in the span of 1 second.
   * If `animate` is `false`, no animated transition to the newly defined exaggeration.
   */
  setTerrainExaggeration(t, n = !0) {
    !n && this.terrain ? (this.terrainExaggeration = t, this.terrain.exaggeration = t, this.triggerRepaint()) : this.enableTerrain(t);
  }
  /**
   * Perform an action when the style is ready. It could be at the moment of calling this method
   * or later.
   */
  onStyleReady(t) {
    this.isStyleLoaded() ? t() : this.once("styledata", () => {
      t();
    });
  }
  async fitToIpBounds() {
    const t = await On.info();
    this.fitBounds(t.country_bounds, {
      duration: 0,
      padding: 100
    });
  }
  async centerOnIpPoint(t) {
    const n = await On.info();
    this.jumpTo({
      center: [n.longitude ?? 0, n.latitude ?? 0],
      zoom: t || 11
    });
  }
  getCameraHash() {
    const t = new Float32Array(5), n = this.getCenter();
    return t[0] = n.lng, t[1] = n.lat, t[2] = this.getZoom(), t[3] = this.getPitch(), t[4] = this.getBearing(), gi.fromUint8Array(new Uint8Array(t.buffer));
  }
  /**
   * Get the SDK config object.
   * This is convenient to dispatch the SDK configuration to externally built layers
   * that do not directly have access to the SDK configuration but do have access to a Map instance.
   */
  getSdkConfig() {
    return j;
  }
  /**
   * Get the MapTiler session ID. Convenient to dispatch to externaly built component
   * that do not directly have access to the SDK configuration but do have access to a Map instance.
   * @returns
   */
  getMaptilerSessionId() {
    return on;
  }
  /**
   *  Updates the requestManager's transform request with a new function.
   *
   * @param transformRequest A callback run before the Map makes a request for an external URL. The callback can be used to modify the url, set headers, or set the credentials property for cross-origin requests.
   *    Expected to return an object with a `url` property and optionally `headers` and `credentials` properties
   *
   * @returns {Map} `this`
   *
   *  @example
   *  map.setTransformRequest((url: string, resourceType: string) => {});
   */
  setTransformRequest(t) {
    return super.setTransformRequest(Un(t)), this;
  }
  /**
   * Gets the {@link ProjectionSpecification}.
   * @returns the projection specification.
   * @example
   * ```ts
   * let projection = map.getProjection();
   * ```
   */
  getProjection() {
    const t = this.style.getProjection();
    return !t === void 0 && this.style.projection ? { type: this.style.projection.name } : t;
  }
  /**
   * Returns whether a globe projection is currently being used
   */
  isGlobeProjection() {
    const t = this.getProjection();
    return t ? t.type === "globe" : !1;
  }
  /**
   * Activate the globe projection.
   */
  enableGlobeProjection() {
    this.isGlobeProjection() !== !0 && (this.setProjection({ type: "globe" }), this.curentProjection = "globe");
  }
  /**
   * Activate the mercator projection.
   */
  enableMercatorProjection() {
    this.isGlobeProjection() !== !1 && (this.setProjection({ type: "mercator" }), this.curentProjection = "mercator");
  }
  setProjection(t) {
    return this.fire("projection.change", { target: this, projection: t }), super.setProjection(t);
  }
  /**
   * Returns `true` is the language was ever updated, meaning changed
   * from what is delivered in the style.
   * Returns `false` if language in use is the language from the style
   * and has never been changed.
   */
  isLanguageUpdated() {
    return this.languageIsUpdated;
  }
};
class ne {
  constructor(e, t, n, a = {}) {
    g(this, "type");
    g(this, "target");
    g(this, "originalEvent");
    g(this, "imageX");
    g(this, "imageY");
    g(this, "isOutOfBounds");
    this.type = e, this.target = t, this.originalEvent = n ?? null, Object.assign(this, a);
  }
}
const zo = [
  // pass nothing other than target (map / viewer) and type
  "idle",
  "render",
  "load",
  "remove",
  "idle"
  // these are fired on layers, not the map,
  // keeping them for reference
  // "content",
  // "visibility",
], Oo = [
  "error"
  // ErrorEvent
], Fo = ["resize"], $o = ["webglcontextlost", "webglcontextrestored"], No = [
  "moveend",
  "movestart",
  "move",
  "zoomend",
  "zoomstart",
  "zoom",
  "rotatestart",
  "rotateend",
  "rotate",
  "dragstart",
  "dragend",
  "drag",
  "boxzoomcancel",
  "boxzoomend",
  "boxzoomstart"
], jo = ["click", "dblclick", "mousedown", "mouseup", "mousemove", "mouseout", "mouseover", "contextmenu", "touchstart", "touchend", "touchmove", "touchcancel"], Do = ["cooperativegestureprevented"], Uo = [
  "data",
  "dataloading",
  "sourcedata",
  "sourcedataloading",
  "dataabort",
  "sourcedataabort"
  // this is fired on layers, not the map
  // keeping it for reference
  // "metadata",
], oc = [
  ...zo,
  ...Oo,
  ...Fo,
  ...$o,
  ...No,
  ...jo,
  ...Uo,
  ...Do
], ic = ["lngLat", "_defaultPrevented"];
function sc({ map: r, viewer: e, lngLatToPx: t }) {
  oc.forEach((n) => {
    try {
      r.on(n, (a) => {
        const o = n;
        if (jo.includes(o)) {
          const f = a, h = f.lngLat && t(f.lngLat), m = e.getImageMetadata(), b = {
            isOutOfBounds: m ? h[0] < 0 || h[0] > m.width || h[1] < 0 || h[1] > m.height : !0,
            imageX: h[0],
            imageY: h[1],
            ...Object.fromEntries(Object.entries(a).filter(([v]) => !ic.includes(v)))
          };
          e.fire(new ne(n, e, f.originalEvent, b));
          return;
        }
        const i = n;
        if (No.includes(i)) {
          const f = a;
          e.fire(new ne(n, e, f.originalEvent, f));
          return;
        }
        const s = n;
        if (Oo.includes(s)) {
          const f = a;
          e.fire(new ne(n, e, null, f));
          return;
        }
        const l = n;
        if (Fo.includes(l)) {
          const f = a;
          e.fire(new ne(n, e, null, f));
          return;
        }
        const u = n;
        if ($o.includes(u)) {
          const f = a;
          e.fire(new ne(n, e, f.originalEvent, f));
          return;
        }
        const c = n;
        if (Uo.includes(c)) {
          const f = a;
          e.fire(new ne(n, e, null, f));
          return;
        }
        const p = n;
        if (Do.includes(p)) {
          const f = a;
          e.fire(new ne(n, e, null, f));
          return;
        }
        const d = n;
        if (zo.includes(d)) {
          e.fire(new ne(n, e));
          return;
        }
      });
    } catch (a) {
      console.error(`Error forwarding event to ImageViewer, event of type "${n}" is not supported`, a);
    }
  });
}
class lc extends Error {
  constructor(t, n, a) {
    const o = `[${a}]: Failed to fetch ${n} at ${t.url}: ${t.status.toString()}: ${t.statusText}`;
    super(o);
    g(this, "status");
    g(this, "statusText");
    this.name = "FetchError", this.message = o, this.status = t.status, this.statusText = t.statusText;
  }
}
const Ta = 85.051129;
function uc(r, e) {
  return new an(e.x / r, e.y / r).toLngLat();
}
function cc(r) {
  return Math.pow(2, r);
}
function pc(r) {
  return Math.log(r) / Math.LN2;
}
function Bo(r, e, t) {
  return Math.min(t, Math.max(e, r));
}
function Yr(r) {
  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360;
}
function Wr(r) {
  return (180 + r) / 360;
}
function _a(r, e, t) {
  const n = t - e, a = ((r - e) % n + n) % n + e;
  return a === e ? t : a;
}
function fc(r, e) {
  const t = Bo(e.lat, -Ta, Ta);
  return new si(Wr(e.lng) * r, Yr(t) * r);
}
const dc = function(r, e) {
  e = Bo(e, this.minZoom, this.maxZoom);
  const t = {
    center: new ii(r.lng, r.lat),
    zoom: e
  };
  let n = this.lngRange;
  const a = this.latRange;
  if (n === null) {
    const X = 179.9999999999;
    n = [-X, X];
  }
  const o = this.tileSize * cc(t.zoom);
  let i = 0, s = o, l = 0, u = o, c = 0, p = 0;
  const { x: d, y: f } = this.size, h = 0.5;
  a && (i = Yr(a[1]) * o, s = Yr(a[0]) * o, s - i < h * f && (c = h * f / (s - i))), n && (l = _a(Wr(n[0]) * o, 0, o), u = _a(Wr(n[1]) * o, 0, o), u < l && (u += o), u - l < h * d && (p = h * d / (u - l)));
  const { x: m, y } = fc(o, r);
  let b, v;
  const x = Math.min(p || 0, c || 0);
  if (x)
    return t.zoom += pc(x), t;
  let E = 0, C = 0;
  const T = 1, N = 1 - (s - i) / f, ge = 1 - (u - l) / d;
  E = Math.max(ge, T), C = Math.max(N, T);
  const Xe = 1 - E, Ye = 1 - C;
  if (a) {
    const X = Ye * f / 2;
    y - X < i && (v = i + X), y + X > s && (v = s - X);
  }
  if (n) {
    const X = m, We = Xe * d / 2;
    X - We < l && (b = l + We), X + We > u && (b = u - We);
  }
  if (b !== void 0 || v !== void 0) {
    const X = new si(b ?? m, v ?? y);
    t.center = uc(o, X).wrap();
  }
  return t;
}, hc = {
  center: "translate(-50%,-50%)",
  top: "translate(-50%,0)",
  "top-left": "translate(0,0)",
  "top-right": "translate(-100%,0)",
  bottom: "translate(-50%,-100%)",
  "bottom-left": "translate(0,-100%)",
  "bottom-right": "translate(-100%,-100%)",
  left: "translate(0,-50%)",
  right: "translate(-100%,-50%)"
};
function mc(r) {
  function e(t) {
    if (!this._map) return;
    const n = this._map.loaded() && !this._map.isMoving();
    ((t == null ? void 0 : t.type) === "terrain" || (t == null ? void 0 : t.type) === "render" && !n) && this._map.once("render", this._update), this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset), this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
    let a = "";
    this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? a = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (a = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
    let o = "";
    this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? o = "rotateX(0deg)" : this._pitchAlignment === "map" && (o = `rotateX(${this._map.getPitch()}deg)`), !this._subpixelPositioning && (!t || t.type === "moveend") && (this._pos = this._pos.round());
    const i = `${hc[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${o} ${a}`;
    this._element.style.transform = i;
  }
  r._update = e.bind(r);
}
class yc {
  constructor({ imageViewer: e }) {
    g(this, "viewer");
    g(this, "container");
    g(this, "handleClick", () => {
      this.viewer.fitImageToViewport({ ease: !0 });
    });
    if (!e)
      throw new Error("ImageViewerFitImageToBoundsControl: an instance of 'ImageViewer' is required");
    this.viewer = e;
  }
  onAdd(e) {
    const t = document.createElement("button");
    this.container = document.createElement("div"), this.container.classList.add("maplibregl-ctrl", "maplibregl-ctrl-group"), t.classList.add("maplibregl-ctrl-fit-image-to-bounds");
    const n = document.createElement("span");
    return n.classList.add("maplibregl-ctrl-icon"), t.title = "Zoom image to viewport bounds", t.appendChild(n), t.addEventListener("click", this.handleClick), this.container.appendChild(t), this.container;
  }
  onRemove() {
    this.container.remove();
  }
}
const qo = Symbol("MapTiler:ImageViewer:Internal:lngLatToPxInternal"), Vo = Symbol("MapTiler:ImageViewer:Internal:pxToLngLatInternal"), { Evented: gc } = k, vc = {
  style: {
    version: 8,
    sources: {},
    layers: []
  },
  minPitch: 0,
  maxPitch: 0,
  pitch: 0,
  bearing: 0,
  projection: "mercator",
  geolocateControl: !1,
  navigationControl: !1,
  projectionControl: !1,
  hash: !1,
  renderWorldCopies: !1,
  terrain: !1,
  space: !1,
  halo: !1,
  transformConstrain: dc
}, bc = {
  debug: !1,
  fitToBoundsControl: !0,
  navigationControl: !0
};
var Oa, Fa, $a;
class wc extends ($a = gc, Fa = qo, Oa = Vo, $a) {
  //#region constructor
  /**
   * The constructor for the ImageViewer.
   *
   * @param {Partial<ImageViewerConstructorOptions>} imageViewerConstructorOptions - The options for the ImageViewer.
   * @example
   * ```ts
   * import "@maptiler/sdk/dist/maptiler-sdk.css"; // import css
   * import { ImageViewer } from "@maptiler/sdk"; // import the sdk
   *
   * const imageViewer = new ImageViewer({
   *   container: document.getElementById("map"),
   *   imageUUID: "01986025-ceb9-7487-9ea6-7a8637dcc1a1",
   *   debug: true, // show tile boundaries, padding, collision boxes etc
   *   fitToBoundsControl: true, // show a control to fit the image to the viewport
   *   navigationControl: true, // show a navigation control
   *   center: [0, 0], // center in pixels
   *   zoom: 1, // zoom level
   *   bearing: 0, // bearing
   * });
   * ```
   */
  constructor(t) {
    super();
    /**
     * The UUID of the image.
     *
     * @internal
     */
    g(this, "imageUUID");
    /**
     * Whether to enable debug mode.
     *
     * @internal
     */
    g(this, "debug");
    /**
     * The metadata of the image.
     *
     */
    g(this, "imageMetadata");
    /**
     * Why not extend the Map class?
     * Because ImageViewer technically operates in screen space and not in map space.
     * We wrap map and perform calculations in screen space.
     * We do not want to have to extend the Map class and give access to
     * methods and properties that operate in LngLat space.   *
     */
    g(this, "sdk");
    /**
     * The options for the ImageViewer.
     *
     * @internal
     */
    g(this, "options");
    /**
     * The size of the image.
     *
     * @internal
     */
    g(this, "imageSize");
    /**
     * The padded size max.
     *
     * @internal
     */
    g(this, "paddedSizeMax");
    /**
     * The control to fit the image to the viewport.
     */
    g(this, "fitToBoundsControlInstance");
    // this flag is used to determine if the image should be fit to the viewport
    // when the map is resized
    g(this, "shouldFitImageToViewport", !0);
    // aliases for methods that are not exposed by the SDK
    // but used internally (ImageMarkers)
    g(this, Fa, this.lngLatToPx.bind(this));
    g(this, Oa, this.pxToLngLat.bind(this));
    if (!t.imageUUID)
      throw new Error("[ImageViewer]: `imageUUID` is required");
    if (typeof t.container != "string" && !(t.container instanceof HTMLElement))
      throw new Error("[ImageViewer]: `container` is required and must be a string or HTMLElement");
    this.options = {
      ...bc,
      ...t
    };
    const n = {
      ...this.options,
      ...vc
    };
    delete n.center, this.sdk = new Po(n), this.sdk.telemetry.registerViewerType("ImageViewer");
    const { imageUUID: a, debug: o } = t;
    this.imageUUID = a, this.debug = o ?? !1, this.debug && (this.sdk.showTileBoundaries = this.debug, this.sdk.showPadding = this.debug, this.sdk.showCollisionBoxes = this.debug, this.sdk.repaint = this.debug), this.init();
  }
  /**
   * The version of the ImageViewer / SDK.
   */
  get version() {
    return this.sdk.version;
  }
  //#region onReadyAsync
  /**
   * Waits for the ImageViewer to be ready.
   *
   * @returns {Promise<void>}
   */
  async onReadyAsync() {
    try {
      await this.sdk.onReadyAsync(), await Promise.race([
        new Promise((t, n) => {
          this.once("imageviewerready", (a) => {
            t(a);
          }), this.once("imagevieweriniterror", (a) => {
            n(a.error);
          });
        }),
        new Promise((t, n) => {
          setTimeout(() => {
            n(new Error("Timeout waiting for image viewer to be ready"));
          }, 5e3);
        })
      ]);
    } catch (t) {
      throw t;
    }
  }
  //#region init
  /**
   * Initializes the ImageViewer
   *  - fetches the image metadata
   *  - adds the image source to the sdk instance
   *  - sets the center to the middle of the image (if center is not provided)
   *  - monkeypatches the maplibre-gl sdk transform method to allow for overpanning and underzooming.
   *  - sets up global event forwarding / intercepting from the map instance
   *  - sets the center to the middle of the image (if center is not provided)
   *
   * @internal
   * @returns {Promise<void>}
   */
  async init() {
    var t, n, a;
    try {
      await this.fetchImageMetadata(), this.addImageSource(), this.options.navigationControl && this.sdk.addControl(
        new Na({
          visualizePitch: !1,
          visualizeRoll: !1
        })
      ), this.fitToBoundsControlInstance = new yc({ imageViewer: this }), this.options.fitToBoundsControl && this.sdk.addControl(this.fitToBoundsControlInstance), sc({
        map: this.sdk,
        viewer: this,
        lngLatToPx: (u) => this.lngLatToPx(u)
      });
      const { center: o, zoom: i, bearing: s } = this.options, l = o ?? [(((t = this.imageMetadata) == null ? void 0 : t.width) ?? 0) / 2, (((n = this.imageMetadata) == null ? void 0 : n.height) ?? 0) / 2];
      this.setCenter(l), this.setBearing(s ?? 0), this.options.zoom ? this.setZoom(i ?? ((a = this.imageMetadata) == null ? void 0 : a.maxzoom) ?? 5) : this.fitImageToViewport(), this.sdk.on("wheel", () => {
        this.shouldFitImageToViewport = !1;
      }), this.sdk.on("touchstart", () => {
        this.shouldFitImageToViewport = !1;
      }), this.sdk.on("drag", () => {
        this.shouldFitImageToViewport = !1;
      }), this.sdk.on("resize", () => {
        var d, f;
        const u = this.getCenter(), c = ((d = this.imageMetadata) == null ? void 0 : d.width) ?? 0, p = ((f = this.imageMetadata) == null ? void 0 : f.height) ?? 0;
        this.shouldFitImageToViewport && this.fitImageToViewport(), (u[0] !== c / 2 || u[1] !== p / 2) && this.setCenter(u);
      }), this.fire("imageviewerready", new ne("imageviewerready", this));
    } catch (o) {
      this.fire("imagevieweriniterror", { error: o });
    }
  }
  //#region fitImageToViewport
  /**
   * Fits the image to the viewport.
   *
   * @param {Object} options - The options for the fit image to viewport.
   * @param {boolean} options.ease - Whether to ease to the viewport bounds.
   */
  fitImageToViewport({ ease: t = !1 } = {}) {
    if (!this.imageMetadata)
      throw new Error("[ImageViewer]: Image metadata not found");
    const n = this.pxToLngLat([0, 0]), a = this.pxToLngLat([this.imageMetadata.width ?? 0, this.imageMetadata.height ?? 0]), o = this.sdk.cameraForBounds([n, a], { padding: 50 });
    o && (t ? this.sdk.easeTo({ ...o, pitch: 0 }, null) : this.sdk.jumpTo({ ...o, pitch: 0 }, null)), this.shouldFitImageToViewport = !0;
  }
  //#region fetchImageMetadata
  /**
   * Fetches the image metadata from the API.
   *
   * @internal
   * @returns {Promise<void>}
   */
  async fetchImageMetadata() {
    const t = Sc(this.imageUUID), n = await fetch(t);
    if (!n.ok)
      throw new lc(n, "image metadata", "ImageViewer");
    const a = await n.json();
    this.imageMetadata = a, Object.freeze(this.imageMetadata);
  }
  //#region addImageSource
  /**
   * Adds the image source to the sdk instance.
   *
   * @internal
   * @returns {void}
   */
  addImageSource() {
    if (!this.imageMetadata)
      throw this.fire("error", new ne("error", this, null, { error: new Error("[ImageViewer]: Image metadata not found") })), new Error("[ImageViewer]: Image metadata not found");
    const t = xc(this.imageUUID), n = (s) => Math.pow(2, Math.ceil(Math.log(s) / Math.LN2));
    this.imageSize = [this.imageMetadata.width, this.imageMetadata.height], this.paddedSizeMax = Math.max(n(this.imageSize[0]), n(this.imageSize[1]));
    const a = this.pxToLngLat([0, 0]), o = this.pxToLngLat(this.imageSize), i = [a.lng, o.lat, o.lng, a.lat];
    this.sdk.addSource("image", {
      ...this.imageMetadata,
      type: "raster",
      bounds: i,
      tiles: [t]
    }), this.sdk.addLayer({
      id: "image",
      type: "raster",
      source: "image"
    });
  }
  //#region SDK mappings
  /**
   * Triggers a repaint of the ImageViewer. Same as map.triggerRepaint().
   *
   * @internal
   * @returns {void}
   */
  triggerRepaint() {
    this.sdk.triggerRepaint();
  }
  /**
   * The scroll zoom handler.
   *
   * @internal
   * @returns {ScrollZoomHandler}
   */
  get scrollZoom() {
    return this.sdk.scrollZoom;
  }
  /**
   * The scroll zoom handler.
   *
   * @internal
   * @param {ScrollZoomHandler} value - The scroll zoom handler.
   */
  set scrollZoom(t) {
    this.sdk.scrollZoom = t;
  }
  /**
   * The box zoom handler.
   *
   * @internal
   * @returns {BoxZoomHandler}
   */
  get boxZoom() {
    return this.sdk.boxZoom;
  }
  /**
   * The box zoom handler.
   *
   * @internal
   * @param {BoxZoomHandler} value - The box zoom handler.
   */
  set boxZoom(t) {
    this.sdk.boxZoom = t;
  }
  /**
   * The drag pan handler.
   *
   * @internal
   * @returns {DragPanHandler}
   */
  get dragPan() {
    return this.sdk.dragPan;
  }
  /**
   * The drag pan handler.
   *
   * @internal
   * @param {DragPanHandler} value - The drag pan handler.
   */
  set dragPan(t) {
    this.sdk.dragPan = t;
  }
  /**
   * The keyboard handler.
   *
   * @internal
   * @returns {KeyboardHandler}
   */
  get keyboard() {
    return this.sdk.keyboard;
  }
  /**
   * The keyboard handler.
   *
   * @internal
   * @param {KeyboardHandler} value - The keyboard handler.
   */
  set keyboard(t) {
    this.sdk.keyboard = t;
  }
  /**
   * The double click zoom handler.
   *
   * @internal
   * @returns {DoubleClickZoomHandler}
   */
  get doubleClickZoom() {
    return this.sdk.doubleClickZoom;
  }
  /**
   * The double click zoom handler.
   *
   * @internal
   * @param {DoubleClickZoomHandler} value - The double click zoom handler.
   */
  set doubleClickZoom(t) {
    this.sdk.doubleClickZoom = t;
  }
  /**
   * The touch zoom rotate handler.
   *
   * @internal
   * @returns {TwoFingersTouchZoomRotateHandler}
   */
  get touchZoomRotate() {
    return this.sdk.touchZoomRotate;
  }
  /**
   * The touch zoom rotate handler.
   *
   * @internal
   * @param {TwoFingersTouchZoomRotateHandler} value - The touch zoom rotate handler.
   */
  set touchZoomRotate(t) {
    this.sdk.touchZoomRotate = t;
  }
  /**
   * The cooperative gestures handler.
   *
   * @internal
   * @returns {CooperativeGesturesHandler}
   */
  get cooperativeGestures() {
    return this.sdk.cooperativeGestures;
  }
  /**
   * The cooperative gestures handler.
   *
   * @internal
   * @param {CooperativeGesturesHandler} value - The cooperative gestures handler.
   */
  set cooperativeGestures(t) {
    this.sdk.cooperativeGestures = t;
  }
  //#endregion SDK Mappings
  //#region lngLatToPx
  /**
   * Converts a LngLat to a px coordinate, based on the image metadata.
   *
   * @internal
   * @param {LngLat} lngLat - The LngLat to convert.
   * @returns {[number, number]} The px coordinate.
   */
  lngLatToPx(t) {
    if (!this.paddedSizeMax) {
      const a = "[ImageViewer]: Unable to convert LngLat to px, padded size max not set";
      throw this.fire("error", new ne("error", this, null, { error: new Error(a) })), new Error(a);
    }
    const n = an.fromLngLat(t);
    return [n.x * this.paddedSizeMax, n.y * this.paddedSizeMax];
  }
  //#region pxToLngLat
  /**
   * Converts a px coordinate to a LngLat, based on the image metadata.
   *
   * @internal
   * @param {LngLat} lngLat - The LngLat to convert.
   * @returns {[number, number]} The px coordinate.
   */
  pxToLngLat(t) {
    if (!this.paddedSizeMax) {
      const a = "[ImageViewer]: Unable to convert px to LngLat, padded size max not set";
      throw this.fire("error", new ne("error", this, null, { error: new Error(a) })), new Error(a);
    }
    return new an(t[0] / this.paddedSizeMax, t[1] / this.paddedSizeMax).toLngLat();
  }
  //#region getSDKInternal
  /**
   * Get the internal SDK instance.
   *
   * @returns {Map} The internal SDK instance.
   * @internal
   */
  getSDKInternal() {
    return this.sdk;
  }
  /**
   * Get the canvas of the internal SDK instance.
   *
   * @returns {HTMLCanvasElement} The canvas of the internal SDK instance.
   */
  getCanvas() {
    return this.sdk.getCanvas();
  }
  //#region flyTo
  /**
   * Fly to a given center.
   *
   * @param {ImageViewerFlyToOptions} options - The options for the fly to.
   * @param {MapDataEvent} eventData - The event data.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  flyTo(t, n) {
    const a = this.pxToLngLat(t.center);
    return this.sdk.flyTo({ ...t, pitch: 0, center: a }, n), this;
  }
  //#region jumpTo
  /**
   * Jump to a given center.
   *
   * @param {ImageViewerJumpToOptions} options - The options for the jump to.
   * @param {MapDataEvent} eventData - The event data.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  jumpTo(t, n) {
    const a = this.pxToLngLat(t.center);
    return this.sdk.jumpTo({ ...t, pitch: 0, center: a }, n), this;
  }
  //#region setZoom
  /**
   * Set the zoom level.
   *
   * @param {number} zoom - The zoom level.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  setZoom(t) {
    return this.sdk.setZoom(t), this;
  }
  //#region getZoom
  /**
   * Get the zoom level.
   *
   * @returns {number} The zoom level.
   */
  getZoom() {
    return this.sdk.getZoom();
  }
  //#region getCenter
  /**
   * Get the center of the ImageViewer in pixels.
   *
   * @internal
   * @returns {[number, number]} The center of the ImageViewer.
   */
  getCenter() {
    const t = this.sdk.getCenter();
    return this.lngLatToPx(t);
  }
  //#region setCenter
  /**
   * Set the center of the ImageViewer in pixels.
   *
   * @param {number} center - The center of the ImageViewer.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  setCenter(t) {
    return this.sdk.setCenter(this.pxToLngLat(t)), this;
  }
  //#region setBearing
  /**
   * Set the bearing of the ImageViewer in degrees.
   *
   * @param {number} bearing - The bearing of the ImageViewer.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  setBearing(t) {
    return this.sdk.setBearing(t), this;
  }
  //#region getBearing
  /**
   * Get the bearing of the ImageViewer in degrees.
   *
   * @returns {number} The bearing of the ImageViewer.
   */
  getBearing() {
    return this.sdk.getBearing();
  }
  //#region panBy
  /**
   * Pan by a given delta in pixels.
   *
   * @param {PointLike} delta - The delta to pan by.
   * @param {ImageViewerEaseToOptions} options - The options for the pan.
   * @param {any} eventData - The event data.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  panBy(t, n, a) {
    return this.sdk.panBy(t, { ...n, pitch: 0 }, a), this;
  }
  //#region panTo
  /**
   * Pan to a given center in pixels.
   *
   * @param {number} center - The center to pan to.
   * @param {ImageViewerEaseToOptions} options - The options for the pan.
   * @param {any} eventData - The event data.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  panTo(t, n, a) {
    return this.sdk.panTo(this.pxToLngLat(t), { ...n, pitch: 0 }, a), this;
  }
  //#region getImageMetadata
  /**
   * Get the image metadata.
   *
   * @returns {ImageMetadata} The image metadata.
   */
  getImageMetadata() {
    return this.imageMetadata;
  }
  //#region getImageBounds
  /**
   * Get the visible bounds of the image in the viewport in imagePixels.
   * [topLeft, bottomRight]
   *
   * @returns {[[number, number], [number, number]]} The visible bounds of the image.
   */
  getImageBounds() {
    const n = this.sdk.getBounds().toArray().map((i) => this.lngLatToPx(ii.convert(i))), a = [n[0][0], n[1][1]], o = [n[1][0], n[0][1]];
    return [a, o];
  }
  //#region fitImageBounds
  /**
   * Set the bounds of the image.
   *
   * @param {[[number, number], [number, number]]} bounds - The bounds of the image.
   * @returns {ImageViewer} The ImageViewer instance.
   */
  fitImageBounds([t, n]) {
    const a = this.pxToLngLat(t), o = this.pxToLngLat(n), i = Vc.convert([a, o]);
    return this.sdk.fitBounds(i), this;
  }
  //#region remove
  /**
   * Destroys the ImageViewer, removes the map instance and all event listeners. Useful for cleanup.
   *
   * @returns {ImageViewer} The ImageViewer instance.
   */
  remove() {
    this.fire("beforeremove", new ne("beforeremove", this)), this.sdk.remove(), this._listeners && Object.entries(this._listeners).forEach(([t, n]) => {
      n.forEach((a) => {
        this.off(t, a);
      });
    }), this._oneTimeListeners && Object.entries(this._oneTimeListeners).forEach(([t, n]) => {
      n.forEach((a) => {
        this.off(t, a);
      });
    });
  }
  pointIsWithinImageBounds(t) {
    const n = this.getImageMetadata();
    if (!n)
      return !1;
    const a = [
      [0, 0],
      [n.width, n.height]
    ];
    return t[0] >= a[0][0] && t[0] <= a[1][0] && t[1] >= a[0][1] && t[1] <= a[1][1];
  }
}
function Sc(r) {
  return `${Go()}/${r}/image.json?key=${j.apiKey}`;
}
function xc(r) {
  return `${Go()}/${r}/{z}/{x}/{y}?key=${j.apiKey}`;
}
function Go() {
  return "https://api.maptiler.com/images";
}
const { Evented: kc } = k;
class vp extends kc {
  constructor({ ...t }) {
    super();
    g(this, "viewer");
    g(this, "marker");
    g(this, "position", [0, 0]);
    this.marker = new Ci(t);
  }
  /**
   * Adds the ImageViewerMarker to an instance of ImageViewer.
   *
   * @param {ImageViewer} viewer - The instance of ImageViewer to add the ImageViewerMarker to.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  addTo(t) {
    if (!(t instanceof wc))
      throw new Error("[ImageViewerMarker]: an ImageViewerMarker must be added to an instance of ImageViewer");
    this.viewer = t, Ac(this.marker, this, this.viewer[qo]);
    const n = this.viewer.getSDKInternal();
    return this.setPosition(this.position), mc(this.marker), this.marker.addTo(n), this;
  }
  /**
   * Adds a class name to the ImageViewerMarker.
   *
   * @param {string} className - The class name to add to the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  addClassName(t) {
    return this.marker.addClassName(t), this;
  }
  /**
   * Gets the element of the ImageViewerMarker.
   *
   * @returns {HTMLElement} The element of the ImageViewerMarker.
   */
  getElement() {
    return this.marker.getElement();
  }
  /**
   * Gets the position of the ImageViewerMarker.
   *
   * @returns {PointLike} The position of the ImageViewerMarker.
   * @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)
   *
   */
  getPosition() {
    return this.position;
  }
  /**
   * Gets the offset of the ImageViewerMarker.
   *
   * @returns {PointLike} The offset of the ImageViewerMarker.
   * @see  [PointLike](https://docs.maptiler.com/sdk-js/api/geography/#pointlike)
   */
  getOffset() {
    return this.marker.getOffset();
  }
  /**
   * Gets the pitch alignment of the ImageViewerMarker.
   *
   * @returns {Alignment} The pitch alignment of the ImageViewerMarker.
   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
   */
  getPitchAlignment() {
    return this.marker.getPitchAlignment();
  }
  /**
   * Gets the popup of the ImageViewerMarker.
   *
   * @returns {Popup} The popup of the ImageViewerMarker.
   * @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)
   */
  getPopup() {
    return this.marker.getPopup();
  }
  /**
   * Gets the rotation of the ImageViewerMarker.
   *
   * @returns {number} The rotation of the ImageViewerMarker.
   */
  getRotation() {
    return this.marker.getRotation();
  }
  /**
   * Gets the rotation alignment of the ImageViewerMarker.
   *
   * @returns {Alignment} The rotation alignment of the ImageViewerMarker.
   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
   */
  getRotationAlignment() {
    return this.marker.getRotationAlignment();
  }
  /**
   * Checks if the ImageViewerMarker is draggable.
   *
   * @returns {boolean} True if the ImageViewerMarker is draggable, false otherwise.
   */
  isDraggable() {
    return this.marker.isDraggable();
  }
  /**
   * Fires an event on the ImageViewerMarker.
   *
   * @param {MarkerEventTypes | Event} event - The event to fire.
   * @param {Record<string, any>} data - The data to fire the event with.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  fire(t, n) {
    return super.fire(t, n), this;
  }
  /**
   * Removes an event listener from the ImageViewerMarker.
   *
   * @param {MarkerEventTypes} event - The event to remove the listener from.
   * @param {ImageViewerMarkerEvent} listener - The listener to remove.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  off(t, n) {
    return super.off(t, n), this;
  }
  /**
   * Adds an event listener to the ImageViewerMarker.
   *
   * @param {MarkerEventTypes} event - The event to add the listener to.
   * @param {ImageViewerMarkerEvent} listener - The listener to add.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  on(t, n) {
    return super.on(t, n);
  }
  /**
   * Checks if the ImageViewerMarker is within the image bounds.
   *
   * @returns {boolean} True if the ImageViewerMarker is within the image bounds, false otherwise.
   */
  isWithinImageBounds() {
    return this.viewer.pointIsWithinImageBounds(this.position);
  }
  /**
   * Removes the ImageViewerMarker from the ImageViewer and cleans up the event listeners.
   *
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  remove() {
    return this.marker.remove(), this.marker._listeners && Object.entries(this.marker._listeners).forEach(([t, n]) => {
      n.forEach((a) => {
        this.off(t, a);
      });
    }), this.marker._oneTimeListeners && Object.entries(this.marker._oneTimeListeners).forEach(([t, n]) => {
      n.forEach((a) => {
        this.off(t, a);
      });
    }), this;
  }
  /**
   * Removes a class name from the ImageViewerMarker dom element.
   *
   * @param {string} className - The class name to remove from the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  removeClassName(t) {
    return this.marker.removeClassName(t), this;
  }
  /**
   * Sets the draggable state of the ImageViewerMarker.
   *
   * @param {boolean} draggable - The draggable state of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setDraggable(t) {
    return this.marker.setDraggable(t), this;
  }
  /**
   * Sets the position of the ImageViewerMarker.
   *
   * @param {[number, number]} px - The position of the ImageViewerMarker in image pixels.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setPosition(t) {
    if (this.position[0] = t[0], this.position[1] = t[1], !this.viewer)
      return this;
    const n = this.viewer[Vo](t);
    return this.marker.setLngLat(n), this;
  }
  /**
   * Sets the offset of the ImageViewerMarker.
   *
   * @param {PointLike} offset - The offset of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setOffset(t) {
    return this.marker.setOffset(t), this;
  }
  /**
   * Sets the opacity of the ImageViewerMarker.
   *
   * @param {string} opacity - The opacity of the ImageViewerMarker.
   * @param {string} opacityWhenCovered - The opacity of the ImageViewerMarker when covered.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setOpacity(t, n) {
    return this.marker.setOpacity(t, n), this;
  }
  /**
   * Sets the pitch alignment of the ImageViewerMarker.
   *
   * @param {Alignment} pitchAlignment - The pitch alignment of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
   */
  setPitchAlignment(t) {
    return this.marker.setPitchAlignment(t), this;
  }
  /**
   * Sets the popup of the ImageViewerMarker.
   *
   * @param {Popup} popup - The popup of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   * @see [Popup](https://docs.maptiler.com/sdk-js/api/markers/#popup)
   */
  setPopup(t) {
    return this.marker.setPopup(t), this;
  }
  /**
   * Sets the rotation of the ImageViewerMarker.
   *
   * @param {number} rotation - The rotation of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setRotation(t) {
    return this.marker.setRotation(t), this;
  }
  /**
   * Sets the rotation alignment of the ImageViewerMarker.
   *
   * @param {Alignment} rotationAlignment - The rotation alignment of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   * @see  [MapLibreGL.Alignment](https://maplibre.org/maplibre-gl-js/docs/API/type-aliases/Alignment/)
   */
  setRotationAlignment(t) {
    return this.marker.setRotationAlignment(t), this;
  }
  /**
   * Sets if subpixel positioning is enabled for the ImageViewerMarker.
   *
   * @param {boolean} subpixelPositioning - The subpixel positioning of the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  setSubpixelPositioning(t) {
    return this.marker.setSubpixelPositioning(t), this;
  }
  /**
   * Toggles a class name on the ImageViewerMarker dom element.
   *
   * @param {string} className - The class name to toggle on the ImageViewerMarker.
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  toggleClassName(t) {
    return this.marker.toggleClassName(t), this;
  }
  /**
   * Toggles the popup of the ImageViewerMarker.
   *
   * @returns {ImageViewerMarker} The ImageViewerMarker instance.
   */
  togglePopup() {
    return this.marker.togglePopup(), this;
  }
}
const Lc = ["dragstart", "drag", "dragend"], Cc = ["lngLat", "_defaultPrevented", "target"];
class Ec {
  constructor(e, t, n) {
    g(this, "type");
    g(this, "target");
    this.type = e, this.target = t, Object.assign(this, n);
  }
}
function Ac(r, e, t) {
  Lc.forEach((n) => {
    r.on(n, (a) => {
      var i, s;
      if ((i = a.target) == null ? void 0 : i.getLngLat()) {
        const l = t((s = a.target) == null ? void 0 : s.getLngLat());
        e.setPosition(l);
      }
      e.fire(
        n,
        new Ec(n, e, {
          ...Object.fromEntries(Object.entries(a).filter(([l]) => !Cc.includes(l)))
        })
      );
    });
  });
}
function _n(r) {
  if (typeof DOMParser < "u") {
    const e = new DOMParser().parseFromString(r, "application/xml");
    if (e.querySelector("parsererror"))
      throw new Error("The provided string is not valid XML");
    return e;
  }
  throw new Error("No XML parser found");
}
function Ho(r, e) {
  if (!r.hasChildNodes())
    return !1;
  for (const t of Array.from(r.childNodes)) {
    const n = t.nodeName;
    if (typeof n == "string" && n.trim().toLowerCase() === e.toLowerCase())
      return !0;
  }
  return !1;
}
function Ia(r) {
  if (typeof XMLSerializer < "u")
    return new XMLSerializer().serializeToString(r);
  throw new Error("No XML serializer found");
}
function Zo(r) {
  const e = typeof r == "string" ? _n(r) : r;
  if (!Ho(e, "gpx"))
    throw new Error("The XML document is not valid GPX");
  const t = K(e, "trk"), n = K(e, "rte"), a = K(e, "wpt"), o = {
    type: "FeatureCollection",
    features: []
  };
  for (const i of Array.from(t)) {
    const s = Mc(i);
    s && o.features.push(s);
  }
  for (const i of Array.from(n)) {
    const s = Pc(i);
    s && o.features.push(s);
  }
  for (const i of Array.from(a))
    o.features.push(Rc(i));
  return o;
}
function Ko(r, e) {
  let t = r;
  if (typeof t == "string" && (t = _n(t)), !Ho(t, "kml"))
    throw new Error("The XML document is not valid KML");
  const n = {
    type: "FeatureCollection",
    features: []
  }, a = {}, o = {}, i = {}, s = K(t, "Placemark"), l = K(t, "Style"), u = K(t, "StyleMap");
  for (const c of Array.from(l)) {
    const p = Pa(e !== void 0 ? e(c) : Ia(c)).toString(16);
    a[`#${He(c, "id")}`] = p, o[p] = c;
  }
  for (const c of Array.from(u)) {
    a[`#${He(c, "id")}`] = Pa(e !== void 0 ? e(c) : Ia(c)).toString(16);
    const p = K(c, "Pair"), d = {};
    for (const f of Array.from(p))
      d[F(_(f, "key")) ?? ""] = F(_(f, "styleUrl"));
    i[`#${He(c, "id")}`] = d;
  }
  for (const c of Array.from(s))
    n.features = n.features.concat(Ic(c, a, o, i));
  return n;
}
function Ma(r) {
  if (r === null) return ["#000000", 1];
  let e = "", t = 1, n = r;
  return n.startsWith("#") && (n = n.substring(1)), (n.length === 6 || n.length === 3) && (e = n), n.length === 8 && (t = Number.parseInt(n.substring(0, 2), 16) / 255, e = `#${n.substring(6, 8)}${n.substring(4, 6)}${n.substring(2, 4)}`), [e ?? "#000000", t ?? 1];
}
function Tc(r) {
  return Wo(r.split(" "));
}
function _c(r) {
  let e = K(r, "coord");
  const t = [], n = [];
  e.length === 0 && (e = K(r, "gx:coord"));
  for (const o of Array.from(e))
    t.push(Tc(F(o) ?? ""));
  const a = K(r, "when");
  for (const o of Array.from(a)) n.push(F(o));
  return {
    coords: t,
    times: n
  };
}
function Bt(r) {
  const e = ["Polygon", "LineString", "Point", "Track", "gx:Track"];
  let t, n, a, o, i;
  const s = [], l = [];
  if (_(r, "MultiGeometry") !== null)
    return Bt(_(r, "MultiGeometry"));
  if (_(r, "MultiTrack") !== null)
    return Bt(_(r, "MultiTrack"));
  if (_(r, "gx:MultiTrack") !== null)
    return Bt(_(r, "gx:MultiTrack"));
  for (a = 0; a < e.length; a++)
    if (n = K(r, e[a]), n) {
      for (o = 0; o < n.length; o++)
        if (t = n[o], e[a] === "Point")
          s.push({
            type: "Point",
            coordinates: Jo(F(_(t, "coordinates")) ?? "")
          });
        else if (e[a] === "LineString")
          s.push({
            type: "LineString",
            coordinates: za(F(_(t, "coordinates")) ?? "")
          });
        else if (e[a] === "Polygon") {
          const u = K(t, "LinearRing"), c = [];
          for (i = 0; i < u.length; i++)
            c.push(za(F(_(u[i], "coordinates")) ?? ""));
          s.push({
            type: "Polygon",
            coordinates: c
          });
        } else if (e[a] === "Track" || e[a] === "gx:Track") {
          const u = _c(t);
          s.push({
            type: "LineString",
            coordinates: u.coords
          }), u.times.length && l.push(u.times);
        }
    }
  return { geoms: s, coordTimes: l };
}
function Ic(r, e, t, n) {
  const a = Bt(r), o = {}, i = F(_(r, "name")), s = F(_(r, "address")), l = F(_(r, "description")), u = _(r, "TimeSpan"), c = _(r, "TimeStamp"), p = _(r, "ExtendedData"), d = _(r, "visibility");
  let f, h = F(_(r, "styleUrl")), m = _(r, "LineStyle"), y = _(r, "PolyStyle");
  if (!a.geoms.length) return [];
  if (i && (o.name = i), s && (o.address = s), h) {
    h.startsWith("#") || (h = `#${h}`), o.styleUrl = h, e[h] && (o.styleHash = e[h]), n[h] && (o.styleMapHash = n[h], o.styleHash = e[n[h].normal ?? ""]);
    const v = t[o.styleHash ?? ""];
    if (v) {
      m || (m = _(v, "LineStyle")), y || (y = _(v, "PolyStyle"));
      const x = _(v, "IconStyle");
      if (x) {
        const E = _(x, "Icon");
        if (E) {
          const C = F(_(E, "href"));
          C && (o.icon = C);
        }
      }
    }
  }
  if (l && (o.description = l), u) {
    const v = F(_(u, "begin")), x = F(_(u, "end"));
    v && x && (o.timespan = { begin: v, end: x });
  }
  if (c !== null && (o.timestamp = F(_(c, "when")) ?? (/* @__PURE__ */ new Date()).toISOString()), m !== null) {
    const v = Ma(F(_(m, "color"))), x = v[0], E = v[1], C = Number.parseFloat(F(_(m, "width")) ?? "");
    x && (o.stroke = x), Number.isNaN(E) || (o["stroke-opacity"] = E), Number.isNaN(C) || (o["stroke-width"] = C);
  }
  if (y) {
    const v = Ma(F(_(y, "color"))), x = v[0], E = v[1], C = F(_(y, "fill")), T = F(_(y, "outline"));
    x && (o.fill = x), Number.isNaN(E) || (o["fill-opacity"] = E), C && (o["fill-opacity"] = C === "1" ? o["fill-opacity"] || 1 : 0), T && (o["stroke-opacity"] = T === "1" ? o["stroke-opacity"] || 1 : 0);
  }
  if (p) {
    const v = K(p, "Data"), x = K(p, "SimpleData");
    for (f = 0; f < v.length; f++)
      o[v[f].getAttribute("name") ?? ""] = F(_(v[f], "value")) ?? "";
    for (f = 0; f < x.length; f++)
      o[x[f].getAttribute("name") ?? ""] = F(x[f]) ?? "";
  }
  d !== null && (o.visibility = F(d) ?? ""), a.coordTimes.length !== 0 && (o.coordTimes = a.coordTimes.length === 1 ? a.coordTimes[0] : a.coordTimes);
  const b = {
    type: "Feature",
    geometry: a.geoms.length === 1 ? a.geoms[0] : {
      type: "GeometryCollection",
      geometries: a.geoms
    },
    properties: o
  };
  return He(r, "id") && (b.id = He(r, "id") ?? void 0), [b];
}
function Xo(r, e) {
  const t = K(r, e), n = [], a = [];
  let o = [];
  const i = t.length;
  if (!(i < 2)) {
    for (let s = 0; s < i; s++) {
      const l = Qo(t[s]);
      n.push(l.coordinates), l.time && a.push(l.time), (l.heartRate || o.length) && (o.length === 0 && (o = new Array(s).fill(null)), o.push(l.heartRate));
    }
    return {
      line: n,
      times: a,
      heartRates: o
    };
  }
}
function Mc(r) {
  const e = K(r, "trkseg"), t = [], n = [], a = [];
  let o;
  for (let s = 0; s < e.length; s++)
    if (o = Xo(e[s], "trkpt"), o !== void 0 && (o.line && t.push(o.line), o.times && o.times.length && n.push(o.times), a.length || o.heartRates && o.heartRates.length)) {
      if (!a.length)
        for (let l = 0; l < s; l++)
          a.push(new Array(t[l].length).fill(null));
      o.heartRates && o.heartRates.length ? a.push(o.heartRates) : a.push(new Array(o.line.length).fill(null));
    }
  if (t.length === 0) return;
  const i = {
    ...In(r),
    ...Yo(_(r, "extensions"))
  };
  return n.length !== 0 && (i.coordTimes = t.length === 1 ? n[0] : n), a.length !== 0 && (i.heartRates = t.length === 1 ? a[0] : a), t.length === 1 ? {
    type: "Feature",
    properties: i,
    geometry: {
      type: "LineString",
      coordinates: t[0]
    }
  } : {
    type: "Feature",
    properties: i,
    geometry: {
      type: "MultiLineString",
      coordinates: t
    }
  };
}
function Pc(r) {
  const e = Xo(r, "rtept");
  return e === void 0 ? void 0 : {
    type: "Feature",
    properties: {
      ...In(r),
      ...Yo(_(r, "extensions"))
    },
    geometry: {
      type: "LineString",
      coordinates: e.line
    }
  };
}
function Rc(r) {
  return {
    type: "Feature",
    properties: { ...In(r), ...Jr(r, ["sym"]) },
    geometry: {
      type: "Point",
      coordinates: Qo(r).coordinates
    }
  };
}
function Yo(r) {
  const e = {};
  if (r) {
    const t = _(r, "line");
    if (t) {
      const n = F(_(t, "color")), a = Number.parseFloat(F(_(t, "opacity")) ?? "0"), o = Number.parseFloat(F(_(t, "width")) ?? "0");
      n && (e.stroke = n), Number.isNaN(a) || (e["stroke-opacity"] = a), Number.isNaN(o) || (e["stroke-width"] = o * 96 / 25.4);
    }
  }
  return e;
}
function In(r) {
  const e = Jr(r, ["name", "cmt", "desc", "type", "time", "keywords"]), t = K(r, "link");
  if (t.length !== 0) {
    e.links = [];
    for (const n of Array.from(t)) {
      const a = {
        href: He(n, "href"),
        ...Jr(n, ["text", "type"])
      };
      e.links.push(a);
    }
  }
  return e;
}
function Pa(r) {
  let e = 0;
  if (!r || !r.length) return e;
  for (let t = 0; t < r.length; t++)
    e = (e << 5) - e + r.charCodeAt(t) | 0;
  return e;
}
function K(r, e) {
  return r.getElementsByTagName(e);
}
function He(r, e) {
  return r.getAttribute(e);
}
function Ra(r, e) {
  return Number.parseFloat(He(r, e) ?? "0");
}
function _(r, e) {
  const t = K(r, e);
  return t.length ? t[0] : null;
}
function zc(r) {
  return r.normalize && r.normalize(), r;
}
function Wo(r) {
  return r.map(Number.parseFloat).map((e) => Number.isNaN(e) ? null : e);
}
function F(r) {
  return r && zc(r), r && r.textContent;
}
function Jr(r, e) {
  const t = {};
  let n, a;
  for (a = 0; a < e.length; a++)
    n = _(r, e[a]), n && (t[e[a]] = F(n) ?? "");
  return t;
}
function Jo(r) {
  return Wo(r.replace(/\s*/g, "").split(","));
}
function za(r) {
  const e = r.replace(/^\s*|\s*$/g, "").split(/\s+/), t = [];
  for (const n of e) t.push(Jo(n));
  return t;
}
function Qo(r) {
  const e = [Ra(r, "lon"), Ra(r, "lat")], t = _(r, "ele"), n = _(r, "gpxtpx:hr") || _(r, "hr"), a = _(r, "time");
  let o;
  return t && (o = Number.parseFloat(F(t) ?? "0"), Number.isNaN(o) || e.push(o)), {
    coordinates: e,
    time: a ? F(a) : null,
    heartRate: n !== null ? Number.parseFloat(F(n) ?? "0") : null
  };
}
function Oc(r) {
  let e = r;
  try {
    typeof e == "string" && (e = _n(e));
  } catch {
    return null;
  }
  try {
    return Zo(e);
  } catch {
  }
  try {
    return Ko(e);
  } catch {
  }
  return null;
}
async function Fc(r, e = {}) {
  const t = e.download ?? !1, n = await $c(r);
  if (t) {
    const a = e.filename ?? "maptiler_screenshot.png", o = document.createElement("a");
    o.style.display = "none", document.body.appendChild(o), o.href = URL.createObjectURL(n), o.download = a, o.click(), setTimeout(() => {
      document.body.removeChild(o), URL.revokeObjectURL(o.href);
    }, 0);
  }
  return n;
}
function $c(r) {
  return new Promise((e, t) => {
    r.redraw(), r.once("idle", () => {
      r.getCanvas().toBlob((n) => {
        if (!n) {
          t(Error("Screenshot could not be created."));
          return;
        }
        e(n);
      }, "image/png");
    });
  });
}
const Qr = [
  // https://colorhunt.co/palette/1d5b79468b97ef6262f3aa60
  ["#1D5B79", "#468B97", "#EF6262", "#F3AA60"],
  // https://colorhunt.co/palette/614bc333bbc585e6c5c8ffe0
  ["#614BC3", "#33BBC5", "#85E6C5", "#C8FFE0"],
  // https://colorhunt.co/palette/4619597a316fcd6688aed8cc
  ["#461959", "#7A316F", "#CD6688", "#AED8CC"],
  // https://colorhunt.co/palette/0079ff00dfa2f6fa70ff0060
  ["#0079FF", "#00DFA2", "#F6FA70", "#FF0060"],
  //https://colorhunt.co/palette/39b5e0a31acbff78f0f5ea5a
  ["#39B5E0", "#A31ACB", "#FF78F0", "#F5EA5A"],
  // https://colorhunt.co/palette/37e2d5590696c70a80fbcb0a
  ["#37E2D5", "#590696", "#C70A80", "#FBCB0A"],
  // https://colorhunt.co/palette/ffd36efff56d99ffcd9fb4ff
  ["#FFD36E", "#FFF56D", "#99FFCD", "#9FB4FF"],
  // https://colorhunt.co/palette/00ead3fff5b7ff449f005f99
  ["#00EAD3", "#FFF5B7", "#FF449F", "#005F99"],
  // https://colorhunt.co/palette/10a19d540375ff7000ffbf00
  ["#10A19D", "#540375", "#FF7000", "#FFBF00"]
];
function yr() {
  return Qr[~~(Math.random() * Qr.length)][~~(Math.random() * 4)];
}
function Mt() {
  return `maptiler_source_${Da()}`;
}
function Pt() {
  return `maptiler_layer_${Da()}`;
}
function en(r, e) {
  if (e <= r[0].zoom)
    return r[0].value;
  if (e >= r[r.length - 1].zoom)
    return r[r.length - 1].value;
  for (let t = 0; t < r.length - 1; t += 1)
    if (e >= r[t].zoom && e < r[t + 1].zoom) {
      const n = r[t + 1].zoom - r[t].zoom, a = (e - r[t].zoom) / n;
      return a * r[t + 1].value + (1 - a) * r[t].value;
    }
  return 0;
}
function Oe(r) {
  return ["interpolate", ["linear"], ["zoom"], ...r.flatMap((e) => [e.zoom, e.value])];
}
function O(r) {
  return ["interpolate", ["linear"], ["zoom"], ...r.flatMap((e) => [e.zoom, e.value])];
}
function ei(r, e) {
  if (typeof e == "number" && typeof r == "number")
    return 2 * e + r;
  if (typeof e == "number" && Array.isArray(r))
    return ["interpolate", ["linear"], ["zoom"], ...r.flatMap((t) => [t.zoom, 2 * e + t.value])];
  if (typeof r == "number" && Array.isArray(e))
    return ["interpolate", ["linear"], ["zoom"], ...e.flatMap((t) => [t.zoom, 2 * t.value + r])];
  if (Array.isArray(r) && Array.isArray(e)) {
    const t = Array.from(/* @__PURE__ */ new Set([...r.map((n) => n.zoom), ...e.map((n) => n.zoom)])).sort((n, a) => n < a ? -1 : 1);
    return ["interpolate", ["linear"], ["zoom"], ...t.flatMap((n) => [n, 2 * en(e, n) + en(r, n)])];
  }
  return 0;
}
function ti(r, e) {
  return ["interpolate", ["linear"], ["get", e], ...r.flatMap((t) => [t.propertyValue, t.value])];
}
function Mn(r) {
  const e = r.trimStart(), t = `${e}${" ".repeat(r.length - e.length)}`, n = Array.from(t);
  if (!n.every((s) => s === " " || s === "_"))
    throw new Error("A dash pattern must be composed only of whitespace and underscore characters.");
  if (!(n.some((s) => s === "_") && n.some((s) => s === " ")))
    throw new Error("A dash pattern must contain at least one underscore and one whitespace character");
  const i = [1];
  for (let s = 1; s < n.length; s += 1) {
    const l = n[s - 1], u = n[s];
    l === u ? i[i.length - 1] += 1 : i.push(1);
  }
  return i;
}
function tn(r, e) {
  return ["interpolate", ["linear"], ["get", e], ...r.flatMap((t) => [t.value, t.color])];
}
function rn(r, e, t = !0) {
  return t ? [
    "interpolate",
    ["linear"],
    ["zoom"],
    0,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.025])],
    2,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.05])],
    4,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.1])],
    8,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius * 0.25])],
    16,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius])]
  ] : ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.value, n.pointRadius])];
}
function ri(r, e, t = !0) {
  return t ? [
    "interpolate",
    ["linear"],
    ["zoom"],
    0,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.025])],
    2,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.05])],
    4,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.1])],
    8,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value * 0.25])],
    16,
    ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value])]
  ] : ["interpolate", ["linear"], ["get", e], ...r.flatMap((n) => [n.propertyValue, n.value])];
}
function nn(r, e) {
  return r.every((t) => t.color[3] === r[0].color[3]) ? r[0].color[3] ? r[0].color[3] / 255 : 1 : [
    "interpolate",
    ["linear"],
    ["get", e],
    ...r.getRawColorStops().flatMap((t) => {
      const n = t.value, a = t.color;
      return [n, a.length === 4 ? a[3] / 255 : 1];
    })
  ];
}
function ni(r, e = 10) {
  return [
    "interpolate",
    ["linear"],
    ["heatmap-density"],
    ...Array.from({ length: e + 1 }, (t, n) => {
      const a = n / e;
      return [a, r.getColorHex(a)];
    }).flat()
  ];
}
function Nt(r) {
  const e = r.toString(16);
  return e.length === 1 ? `0${e}` : e;
}
function Nc(r) {
  return `#${Nt(r[0])}${Nt(r[1])}${Nt(r[2])}${r.length === 4 ? Nt(r[3]) : ""}`;
}
class A extends Array {
  constructor(t = {}) {
    super();
    g(this, "min", 0);
    g(this, "max", 1);
    "min" in t && (this.min = t.min), "max" in t && (this.max = t.max), "stops" in t && this.setStops(t.stops, { clone: !1 });
  }
  /**
   * Converts a array-definition color ramp definition into a usable ColorRamp instance.
   * Note: units are not converted and may need to to be converted beforehand (eg. kelvin to centigrade)
   * @param cr
   * @returns
   */
  static fromArrayDefinition(t) {
    return new A({
      stops: t.map((n) => ({
        value: n[0],
        color: n[1]
      }))
    });
  }
  setStops(t, n = { clone: !0 }) {
    const a = n.clone ? this.clone() : this;
    a.length = 0;
    let o = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
    for (let s = 0; s < t.length; s += 1)
      o = Math.min(o, t[s].value), i = Math.max(i, t[s].value), a.push({
        value: t[s].value,
        color: t[s].color.slice()
        // we want to make sure we do a deep copy and not a reference
      });
    return a.sort((s, l) => s.value < l.value ? -1 : 1), this.min = o, this.max = i, a;
  }
  scale(t, n, a = { clone: !0 }) {
    const o = a.clone, i = this[0].value, l = this.at(-1).value - i, u = n - t, c = [];
    for (let p = 0; p < this.length; p += 1) {
      const h = (this[p].value - i) / l * u + t;
      o ? c.push({
        value: h,
        color: this[p].color.slice()
      }) : this[p].value = h;
    }
    return o ? new A({ stops: c }) : this;
  }
  // for some reason, I had to reimplement this
  at(t) {
    return t < 0 ? this[this.length + t] : this[t];
  }
  clone() {
    return new A({ stops: this.getRawColorStops() });
  }
  getRawColorStops() {
    const t = [];
    for (let n = 0; n < this.length; n += 1)
      t.push({ value: this[n].value, color: this[n].color });
    return t;
  }
  reverse(t = { clone: !0 }) {
    const n = t.clone ? this.clone() : this;
    for (let a = 0; a < ~~(n.length / 2); a += 1) {
      const o = n[a].color;
      n[a].color = n.at(-(a + 1)).color, n.at(-(a + 1)).color = o;
    }
    return n;
  }
  getBounds() {
    return { min: this.min, max: this.max };
  }
  getColor(t, n = { smooth: !0 }) {
    if (t <= this[0].value)
      return this[0].color;
    if (t >= this.at(-1).value)
      return this.at(-1).color;
    for (let a = 0; a < this.length - 1; a += 1) {
      if (t > this[a + 1].value)
        continue;
      const o = this[a].color;
      if (!n.smooth)
        return o.slice();
      const i = this[a].value, s = this[a + 1].value, l = this[a + 1].color, u = (s - t) / (s - i);
      return o.map((c, p) => Math.round(c * u + l[p] * (1 - u)));
    }
    return [0, 0, 0];
  }
  /**
   * Get the color as an hexadecimal string
   */
  getColorHex(t, n = {
    smooth: !0,
    withAlpha: !1
  }) {
    return Nc(this.getColor(t, n));
  }
  /**
   * Get the color of the color ramp at a relative position in [0, 1]
   */
  getColorRelative(t, n = { smooth: !0 }) {
    const a = this.getBounds();
    return this.getColor(a.min + t * (a.max - a.min), n);
  }
  getCanvasStrip(t = {
    horizontal: !0,
    size: 512,
    smooth: !0
  }) {
    const n = document.createElement("canvas");
    n.width = t.horizontal ? t.size : 1, n.height = t.horizontal ? 1 : t.size;
    const a = n.getContext("2d");
    if (!a) throw new Error("Canvs context is missing");
    const o = a.getImageData(0, 0, n.width, n.height), i = o.data, s = t.size, l = this[0].value, p = (this.at(-1).value - l) / s;
    for (let d = 0; d < s; d += 1) {
      const f = this.getColor(l + d * p, {
        smooth: t.smooth
      });
      i[d * 4] = f[0], i[d * 4 + 1] = f[1], i[d * 4 + 2] = f[2], i[d * 4 + 3] = f.length > 3 ? f[3] : 255;
    }
    return a.putImageData(o, 0, 0), n;
  }
  /**
   * Apply a non-linear ressampling. This will create a new instance of ColorRamp with the same bounds.
   */
  resample(t, n = 15) {
    const a = this.getBounds(), o = this.scale(0, 1), i = 1 / (n - 1);
    let s;
    if (t === "ease-in-square")
      s = Array.from({ length: n }, (c, p) => {
        const d = p * i, f = d ** 2, h = o.getColor(f);
        return { value: d, color: h };
      });
    else if (t === "ease-out-square")
      s = Array.from({ length: n }, (c, p) => {
        const d = p * i, f = 1 - (1 - d) ** 2, h = o.getColor(f);
        return { value: d, color: h };
      });
    else if (t === "ease-out-sqrt")
      s = Array.from({ length: n }, (c, p) => {
        const d = p * i, f = d ** 0.5, h = o.getColor(f);
        return { value: d, color: h };
      });
    else if (t === "ease-in-sqrt")
      s = Array.from({ length: n }, (c, p) => {
        const d = p * i, f = 1 - (1 - d) ** 0.5, h = o.getColor(f);
        return { value: d, color: h };
      });
    else if (t === "ease-out-exp")
      s = Array.from({ length: n }, (c, p) => {
        const d = p * i, f = 1 - 2 ** (-10 * d), h = o.getColor(f);
        return { value: d, color: h };
      });
    else if (t === "ease-in-exp")
      s = Array.from({ length: n }, (c, p) => {
        const d = p * i, f = 2 ** (10 * d - 10), h = o.getColor(f);
        return { value: d, color: h };
      });
    else
      throw new Error("Invalid ressampling method.");
    return new A({ stops: s }).scale(a.min, a.max);
  }
  /**
   * Makes a clone of this color ramp that is fully transparant at the begining of their range
   */
  transparentStart() {
    const t = this.getRawColorStops();
    t.unshift({
      value: t[0].value,
      color: t[0].color.slice()
    }), t[1].value += 1e-3;
    for (const n of t)
      n.color.length === 3 && n.color.push(255);
    return t[0].color[3] = 0, new A({ stops: t });
  }
  /**
   * Check if this color ramp has a transparent start
   */
  hasTransparentStart() {
    return this[0].color.length === 4 && this[0].color[3] === 0;
  }
}
const ai = {
  /**
   * A fully transparent [0, 0, 0, 0] colorramp to hide data.
   * Defined in interval [0, 1], without unit.
   */
  NULL: new A({
    stops: [
      { value: 0, color: [0, 0, 0, 0] },
      { value: 1, color: [0, 0, 0, 0] }
    ]
  }),
  GRAY: new A({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic jet color ramp.
   * Defined in interval [0, 1], without unit.
   */
  JET: new A({
    stops: [
      { value: 0, color: [0, 0, 131] },
      { value: 0.125, color: [0, 60, 170] },
      { value: 0.375, color: [5, 255, 255] },
      { value: 0.625, color: [255, 255, 0] },
      { value: 0.875, color: [250, 0, 0] },
      { value: 1, color: [128, 0, 0] }
    ]
  }),
  /**
   * Classic HSV color ramp (hue, saturation, value).
   * Defined in interval [0, 1], without unit.
   */
  HSV: new A({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 0.169, color: [253, 255, 2] },
      { value: 0.173, color: [247, 255, 2] },
      { value: 0.337, color: [0, 252, 4] },
      { value: 0.341, color: [0, 252, 10] },
      { value: 0.506, color: [1, 249, 255] },
      { value: 0.671, color: [2, 0, 253] },
      { value: 0.675, color: [8, 0, 253] },
      { value: 0.839, color: [255, 0, 251] },
      { value: 0.843, color: [255, 0, 245] },
      { value: 1, color: [255, 0, 6] }
    ]
  }),
  /**
   * Classic hot color ramp.
   * Defined in interval [0, 1], without unit.
   */
  HOT: new A({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.3, color: [230, 0, 0] },
      { value: 0.6, color: [255, 210, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic spring color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SPRING: new A({
    stops: [
      { value: 0, color: [255, 0, 255] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic summer color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SUMMER: new A({
    stops: [
      { value: 0, color: [0, 128, 102] },
      { value: 1, color: [255, 255, 102] }
    ]
  }),
  /**
   * Classic autommn color ramp.
   * Defined in interval [0, 1], without unit.
   */
  AUTOMN: new A({
    stops: [
      { value: 0, color: [255, 0, 0] },
      { value: 1, color: [255, 255, 0] }
    ]
  }),
  /**
   * Classic winter color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WINTER: new A({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [0, 255, 128] }
    ]
  }),
  /**
   * Classic bone color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BONE: new A({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.376, color: [84, 84, 116] },
      { value: 0.753, color: [169, 200, 200] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic copper color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COPPER: new A({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.804, color: [255, 160, 102] },
      { value: 1, color: [255, 199, 127] }
    ]
  }),
  /**
   * Classic greys color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREYS: new A({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic yignbu color ramp (blue to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIGNBU: new A({
    stops: [
      { value: 0, color: [8, 29, 88] },
      { value: 0.125, color: [37, 52, 148] },
      { value: 0.25, color: [34, 94, 168] },
      { value: 0.375, color: [29, 145, 192] },
      { value: 0.5, color: [65, 182, 196] },
      { value: 0.625, color: [127, 205, 187] },
      { value: 0.75, color: [199, 233, 180] },
      { value: 0.875, color: [237, 248, 217] },
      { value: 1, color: [255, 255, 217] }
    ]
  }),
  /**
   * Classic greens color ramp.
   * Defined in interval [0, 1], without unit.
   */
  GREENS: new A({
    stops: [
      { value: 0, color: [0, 68, 27] },
      { value: 0.125, color: [0, 109, 44] },
      { value: 0.25, color: [35, 139, 69] },
      { value: 0.375, color: [65, 171, 93] },
      { value: 0.5, color: [116, 196, 118] },
      { value: 0.625, color: [161, 217, 155] },
      { value: 0.75, color: [199, 233, 192] },
      { value: 0.875, color: [229, 245, 224] },
      { value: 1, color: [247, 252, 245] }
    ]
  }),
  /**
   * Classic yiorrd color ramp (red to light yellow).
   * Defined in interval [0, 1], without unit.
   */
  YIORRD: new A({
    stops: [
      { value: 0, color: [128, 0, 38] },
      { value: 0.125, color: [189, 0, 38] },
      { value: 0.25, color: [227, 26, 28] },
      { value: 0.375, color: [252, 78, 42] },
      { value: 0.5, color: [253, 141, 60] },
      { value: 0.625, color: [254, 178, 76] },
      { value: 0.75, color: [254, 217, 118] },
      { value: 0.875, color: [255, 237, 160] },
      { value: 1, color: [255, 255, 204] }
    ]
  }),
  /**
   * Classic blue-red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLUERED: new A({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rdbu color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RDBU: new A({
    stops: [
      { value: 0, color: [5, 10, 172] },
      { value: 0.35, color: [106, 137, 247] },
      { value: 0.5, color: [190, 190, 190] },
      { value: 0.6, color: [220, 170, 132] },
      { value: 0.7, color: [230, 145, 90] },
      { value: 1, color: [178, 10, 28] }
    ]
  }),
  /**
   * Classic picnic color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PICNIC: new A({
    stops: [
      { value: 0, color: [0, 0, 255] },
      { value: 0.1, color: [51, 153, 255] },
      { value: 0.2, color: [102, 204, 255] },
      { value: 0.3, color: [153, 204, 255] },
      { value: 0.4, color: [204, 204, 255] },
      { value: 0.5, color: [255, 255, 255] },
      { value: 0.6, color: [255, 204, 255] },
      { value: 0.7, color: [255, 153, 255] },
      { value: 0.8, color: [255, 102, 204] },
      { value: 0.9, color: [255, 102, 102] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic rainbow color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW: new A({
    stops: [
      { value: 0, color: [150, 0, 90] },
      { value: 0.125, color: [0, 0, 200] },
      { value: 0.25, color: [0, 25, 255] },
      { value: 0.375, color: [0, 152, 255] },
      { value: 0.5, color: [44, 255, 150] },
      { value: 0.625, color: [151, 255, 0] },
      { value: 0.75, color: [255, 234, 0] },
      { value: 0.875, color: [255, 111, 0] },
      { value: 1, color: [255, 0, 0] }
    ]
  }),
  /**
   * Classic Portland color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PORTLAND: new A({
    stops: [
      { value: 0, color: [12, 51, 131] },
      { value: 0.25, color: [10, 136, 186] },
      { value: 0.5, color: [242, 211, 56] },
      { value: 0.75, color: [242, 143, 56] },
      { value: 1, color: [217, 30, 30] }
    ]
  }),
  /**
   * Classic blackbody color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BLACKBODY: new A({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.2, color: [230, 0, 0] },
      { value: 0.4, color: [230, 210, 0] },
      { value: 0.7, color: [255, 255, 255] },
      { value: 1, color: [160, 200, 255] }
    ]
  }),
  /**
   * Classic earth color ramp.
   * Defined in interval [0, 1], without unit.
   */
  EARTH: new A({
    stops: [
      { value: 0, color: [0, 0, 130] },
      { value: 0.1, color: [0, 180, 180] },
      { value: 0.2, color: [40, 210, 40] },
      { value: 0.4, color: [230, 230, 50] },
      { value: 0.6, color: [120, 70, 20] },
      { value: 1, color: [255, 255, 255] }
    ]
  }),
  /**
   * Classic electric color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ELECTRIC: new A({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.15, color: [30, 0, 100] },
      { value: 0.4, color: [120, 0, 100] },
      { value: 0.6, color: [160, 90, 0] },
      { value: 0.8, color: [230, 200, 0] },
      { value: 1, color: [255, 250, 220] }
    ]
  }),
  /**
   * Classic viridis color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VIRIDIS: new A({
    stops: [
      { value: 0, color: [68, 1, 84] },
      { value: 0.13, color: [71, 44, 122] },
      { value: 0.25, color: [59, 81, 139] },
      { value: 0.38, color: [44, 113, 142] },
      { value: 0.5, color: [33, 144, 141] },
      { value: 0.63, color: [39, 173, 129] },
      { value: 0.75, color: [92, 200, 99] },
      { value: 0.88, color: [170, 220, 50] },
      { value: 1, color: [253, 231, 37] }
    ]
  }),
  /**
   * Classic inferno color ramp.
   * Defined in interval [0, 1], without unit.
   */
  INFERNO: new A({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [31, 12, 72] },
      { value: 0.25, color: [85, 15, 109] },
      { value: 0.38, color: [136, 34, 106] },
      { value: 0.5, color: [186, 54, 85] },
      { value: 0.63, color: [227, 89, 51] },
      { value: 0.75, color: [249, 140, 10] },
      { value: 0.88, color: [249, 201, 50] },
      { value: 1, color: [252, 255, 164] }
    ]
  }),
  /**
   * Classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  MAGMA: new A({
    stops: [
      { value: 0, color: [0, 0, 4] },
      { value: 0.13, color: [28, 16, 68] },
      { value: 0.25, color: [79, 18, 123] },
      { value: 0.38, color: [129, 37, 129] },
      { value: 0.5, color: [181, 54, 122] },
      { value: 0.63, color: [229, 80, 100] },
      { value: 0.75, color: [251, 135, 97] },
      { value: 0.88, color: [254, 194, 135] },
      { value: 1, color: [252, 253, 191] }
    ]
  }),
  /**
   * Classic plasma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PLASMA: new A({
    stops: [
      { value: 0, color: [13, 8, 135] },
      { value: 0.13, color: [75, 3, 161] },
      { value: 0.25, color: [125, 3, 168] },
      { value: 0.38, color: [168, 34, 150] },
      { value: 0.5, color: [203, 70, 121] },
      { value: 0.63, color: [229, 107, 93] },
      { value: 0.75, color: [248, 148, 65] },
      { value: 0.88, color: [253, 195, 40] },
      { value: 1, color: [240, 249, 33] }
    ]
  }),
  /**
   * Classic warm color ramp.
   * Defined in interval [0, 1], without unit.
   */
  WARM: new A({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [172, 0, 187] },
      { value: 0.25, color: [219, 0, 170] },
      { value: 0.38, color: [255, 0, 130] },
      { value: 0.5, color: [255, 63, 74] },
      { value: 0.63, color: [255, 123, 0] },
      { value: 0.75, color: [234, 176, 0] },
      { value: 0.88, color: [190, 228, 0] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic cool color ramp.
   * Defined in interval [0, 1], without unit.
   */
  COOL: new A({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.13, color: [116, 0, 218] },
      { value: 0.25, color: [98, 74, 237] },
      { value: 0.38, color: [68, 146, 231] },
      { value: 0.5, color: [0, 204, 197] },
      { value: 0.63, color: [0, 247, 146] },
      { value: 0.75, color: [0, 255, 88] },
      { value: 0.88, color: [40, 255, 8] },
      { value: 1, color: [147, 255, 0] }
    ]
  }),
  /**
   * Classic rainboz soft color ramp.
   * Defined in interval [0, 1], without unit.
   */
  RAINBOW_SOFT: new A({
    stops: [
      { value: 0, color: [125, 0, 179] },
      { value: 0.1, color: [199, 0, 180] },
      { value: 0.2, color: [255, 0, 121] },
      { value: 0.3, color: [255, 108, 0] },
      { value: 0.4, color: [222, 194, 0] },
      { value: 0.5, color: [150, 255, 0] },
      { value: 0.6, color: [0, 255, 55] },
      { value: 0.7, color: [0, 246, 150] },
      { value: 0.8, color: [50, 167, 222] },
      { value: 0.9, color: [103, 51, 235] },
      { value: 1, color: [124, 0, 186] }
    ]
  }),
  /**
   * Classic bathymetry color ramp.
   * Defined in interval [0, 1], without unit.
   */
  BATHYMETRY: new A({
    stops: [
      { value: 0, color: [40, 26, 44] },
      { value: 0.13, color: [59, 49, 90] },
      { value: 0.25, color: [64, 76, 139] },
      { value: 0.38, color: [63, 110, 151] },
      { value: 0.5, color: [72, 142, 158] },
      { value: 0.63, color: [85, 174, 163] },
      { value: 0.75, color: [120, 206, 163] },
      { value: 0.88, color: [187, 230, 172] },
      { value: 1, color: [253, 254, 204] }
    ]
  }),
  /**
   * Classic cdom color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CDOM: new A({
    stops: [
      { value: 0, color: [47, 15, 62] },
      { value: 0.13, color: [87, 23, 86] },
      { value: 0.25, color: [130, 28, 99] },
      { value: 0.38, color: [171, 41, 96] },
      { value: 0.5, color: [206, 67, 86] },
      { value: 0.63, color: [230, 106, 84] },
      { value: 0.75, color: [242, 149, 103] },
      { value: 0.88, color: [249, 193, 135] },
      { value: 1, color: [254, 237, 176] }
    ]
  }),
  /**
   * Classic chlorophyll color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CHLOROPHYLL: new A({
    stops: [
      { value: 0, color: [18, 36, 20] },
      { value: 0.13, color: [25, 63, 41] },
      { value: 0.25, color: [24, 91, 59] },
      { value: 0.38, color: [13, 119, 72] },
      { value: 0.5, color: [18, 148, 80] },
      { value: 0.63, color: [80, 173, 89] },
      { value: 0.75, color: [132, 196, 122] },
      { value: 0.88, color: [175, 221, 162] },
      { value: 1, color: [215, 249, 208] }
    ]
  }),
  /**
   * Classic density color ramp.
   * Defined in interval [0, 1], without unit.
   */
  DENSITY: new A({
    stops: [
      { value: 0, color: [54, 14, 36] },
      { value: 0.13, color: [89, 23, 80] },
      { value: 0.25, color: [110, 45, 132] },
      { value: 0.38, color: [120, 77, 178] },
      { value: 0.5, color: [120, 113, 213] },
      { value: 0.63, color: [115, 151, 228] },
      { value: 0.75, color: [134, 185, 227] },
      { value: 0.88, color: [177, 214, 227] },
      { value: 1, color: [230, 241, 241] }
    ]
  }),
  /**
   * Classic freesurface blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_BLUE: new A({
    stops: [
      { value: 0, color: [30, 4, 110] },
      { value: 0.13, color: [47, 14, 176] },
      { value: 0.25, color: [41, 45, 236] },
      { value: 0.38, color: [25, 99, 212] },
      { value: 0.5, color: [68, 131, 200] },
      { value: 0.63, color: [114, 156, 197] },
      { value: 0.75, color: [157, 181, 203] },
      { value: 0.88, color: [200, 208, 216] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic freesurface red color ramp.
   * Defined in interval [0, 1], without unit.
   */
  FREESURFACE_RED: new A({
    stops: [
      { value: 0, color: [60, 9, 18] },
      { value: 0.13, color: [100, 17, 27] },
      { value: 0.25, color: [142, 20, 29] },
      { value: 0.38, color: [177, 43, 27] },
      { value: 0.5, color: [192, 87, 63] },
      { value: 0.63, color: [205, 125, 105] },
      { value: 0.75, color: [216, 162, 148] },
      { value: 0.88, color: [227, 199, 193] },
      { value: 1, color: [241, 237, 236] }
    ]
  }),
  /**
   * Classic oxygen color ramp.
   * Defined in interval [0, 1], without unit.
   */
  OXYGEN: new A({
    stops: [
      { value: 0, color: [64, 5, 5] },
      { value: 0.13, color: [106, 6, 15] },
      { value: 0.25, color: [144, 26, 7] },
      { value: 0.38, color: [168, 64, 3] },
      { value: 0.5, color: [188, 100, 4] },
      { value: 0.63, color: [206, 136, 11] },
      { value: 0.75, color: [220, 174, 25] },
      { value: 0.88, color: [231, 215, 44] },
      { value: 1, color: [248, 254, 105] }
    ]
  }),
  /**
   * Classic par color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PAR: new A({
    stops: [
      { value: 0, color: [51, 20, 24] },
      { value: 0.13, color: [90, 32, 35] },
      { value: 0.25, color: [129, 44, 34] },
      { value: 0.38, color: [159, 68, 25] },
      { value: 0.5, color: [182, 99, 19] },
      { value: 0.63, color: [199, 134, 22] },
      { value: 0.75, color: [212, 171, 35] },
      { value: 0.88, color: [221, 210, 54] },
      { value: 1, color: [225, 253, 75] }
    ]
  }),
  /**
   * Classic phase color ramp.
   * Defined in interval [0, 1], without unit.
   */
  PHASE: new A({
    stops: [
      { value: 0, color: [145, 105, 18] },
      { value: 0.13, color: [184, 71, 38] },
      { value: 0.25, color: [186, 58, 115] },
      { value: 0.38, color: [160, 71, 185] },
      { value: 0.5, color: [110, 97, 218] },
      { value: 0.63, color: [50, 123, 164] },
      { value: 0.75, color: [31, 131, 110] },
      { value: 0.88, color: [77, 129, 34] },
      { value: 1, color: [145, 105, 18] }
    ]
  }),
  /**
   * Classic salinity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  SALINITY: new A({
    stops: [
      { value: 0, color: [42, 24, 108] },
      { value: 0.13, color: [33, 50, 162] },
      { value: 0.25, color: [15, 90, 145] },
      { value: 0.38, color: [40, 118, 137] },
      { value: 0.5, color: [59, 146, 135] },
      { value: 0.63, color: [79, 175, 126] },
      { value: 0.75, color: [120, 203, 104] },
      { value: 0.88, color: [193, 221, 100] },
      { value: 1, color: [253, 239, 154] }
    ]
  }),
  /**
   * Classic temperature color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TEMPERATURE: new A({
    stops: [
      { value: 0, color: [4, 35, 51] },
      { value: 0.13, color: [23, 51, 122] },
      { value: 0.25, color: [85, 59, 157] },
      { value: 0.38, color: [129, 79, 143] },
      { value: 0.5, color: [175, 95, 130] },
      { value: 0.63, color: [222, 112, 101] },
      { value: 0.75, color: [249, 146, 66] },
      { value: 0.88, color: [249, 196, 65] },
      { value: 1, color: [232, 250, 91] }
    ]
  }),
  /**
   * Classic turbidity color ramp.
   * Defined in interval [0, 1], without unit.
   */
  TURBIDITY: new A({
    stops: [
      { value: 0, color: [34, 31, 27] },
      { value: 0.13, color: [65, 50, 41] },
      { value: 0.25, color: [98, 69, 52] },
      { value: 0.38, color: [131, 89, 57] },
      { value: 0.5, color: [161, 112, 59] },
      { value: 0.63, color: [185, 140, 66] },
      { value: 0.75, color: [202, 174, 88] },
      { value: 0.88, color: [216, 209, 126] },
      { value: 1, color: [233, 246, 171] }
    ]
  }),
  /**
   * Classic velocity blue color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_BLUE: new A({
    stops: [
      { value: 0, color: [17, 32, 64] },
      { value: 0.13, color: [35, 52, 116] },
      { value: 0.25, color: [29, 81, 156] },
      { value: 0.38, color: [31, 113, 162] },
      { value: 0.5, color: [50, 144, 169] },
      { value: 0.63, color: [87, 173, 176] },
      { value: 0.75, color: [149, 196, 189] },
      { value: 0.88, color: [203, 221, 211] },
      { value: 1, color: [254, 251, 230] }
    ]
  }),
  /**
   * Classic velocity green color ramp.
   * Defined in interval [0, 1], without unit.
   */
  VELOCITY_GREEN: new A({
    stops: [
      { value: 0, color: [23, 35, 19] },
      { value: 0.13, color: [24, 64, 38] },
      { value: 0.25, color: [11, 95, 45] },
      { value: 0.38, color: [39, 123, 35] },
      { value: 0.5, color: [95, 146, 12] },
      { value: 0.63, color: [152, 165, 18] },
      { value: 0.75, color: [201, 186, 69] },
      { value: 0.88, color: [233, 216, 137] },
      { value: 1, color: [255, 253, 205] }
    ]
  }),
  /**
   * Classic cube helix color ramp.
   * Defined in interval [0, 1], without unit.
   */
  CUBEHELIX: new A({
    stops: [
      { value: 0, color: [0, 0, 0] },
      { value: 0.07, color: [22, 5, 59] },
      { value: 0.13, color: [60, 4, 105] },
      { value: 0.2, color: [109, 1, 135] },
      { value: 0.27, color: [161, 0, 147] },
      { value: 0.33, color: [210, 2, 142] },
      { value: 0.4, color: [251, 11, 123] },
      { value: 0.47, color: [255, 29, 97] },
      { value: 0.53, color: [255, 54, 69] },
      { value: 0.6, color: [255, 85, 46] },
      { value: 0.67, color: [255, 120, 34] },
      { value: 0.73, color: [255, 157, 37] },
      { value: 0.8, color: [241, 191, 57] },
      { value: 0.87, color: [224, 220, 93] },
      { value: 0.93, color: [218, 241, 142] },
      { value: 1, color: [227, 253, 198] }
    ]
  }),
  /**
   * The cividis color ramp is color blind friendly.
   * Read more here https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0199239
   * Defined in interval [0, 1], without unit.
   */
  CIVIDIS: new A({
    stops: [
      { value: 0, color: [0, 32, 77, 255] },
      { value: 0.125, color: [5, 54, 110, 255] },
      { value: 0.25, color: [65, 77, 108, 255] },
      { value: 0.375, color: [97, 100, 111, 255] },
      { value: 0.5, color: [125, 124, 121, 255] },
      { value: 0.625, color: [156, 149, 120, 255] },
      { value: 0.75, color: [190, 175, 111, 255] },
      { value: 0.875, color: [225, 204, 94, 255] },
      { value: 1, color: [255, 235, 70, 255] }
    ]
  }),
  /**
   * Classic turbo color ramp.
   * This is a luminance-constant alternative to the jet, making it more
   * clor-blind friendly.
   * Defined in interval [0, 1], without unit.
   */
  TURBO: new A({
    stops: [
      { value: 0, color: [48, 18, 59, 255] },
      { value: 0.125, color: [70, 107, 227, 255] },
      { value: 0.25, color: [40, 187, 236, 255] },
      { value: 0.375, color: [49, 242, 153, 255] },
      { value: 0.5, color: [162, 252, 60, 255] },
      { value: 0.625, color: [237, 208, 58, 255] },
      { value: 0.75, color: [251, 128, 34, 255] },
      { value: 0.875, color: [210, 49, 5, 255] },
      { value: 1, color: [122, 4, 3, 255] }
    ]
  }),
  /**
   * The rocket color ramp is perceptually uniform, which makes it more
   * color bliend friendly than the classic magma color ramp.
   * Defined in interval [0, 1], without unit.
   */
  ROCKET: new A({
    stops: [
      { value: 0, color: [250, 235, 221, 0] },
      { value: 0.133, color: [250, 235, 221, 255] },
      { value: 0.266, color: [246, 170, 130, 255] },
      { value: 0.4, color: [240, 96, 67, 255] },
      { value: 0.533, color: [203, 27, 79, 255] },
      { value: 0.666, color: [132, 30, 90, 255] },
      { value: 0.8, color: [63, 27, 68, 255] },
      { value: 1, color: [3, 5, 26, 255] }
    ]
  }),
  /**
   * The mako color ramp is perceptually uniform and can be seen as
   * a color blind friendly alternative to bathymetry or yignbu.
   * Defined in interval [0, 1], without unit.
   */
  MAKO: new A({
    stops: [
      { value: 0, color: [11, 4, 5, 255] },
      { value: 0.125, color: [43, 28, 53, 255] },
      { value: 0.25, color: [62, 53, 107, 255] },
      { value: 0.375, color: [59, 86, 152, 255] },
      { value: 0.5, color: [53, 123, 162, 255] },
      { value: 0.625, color: [53, 158, 170, 255] },
      { value: 0.75, color: [73, 193, 173, 255] },
      { value: 0.875, color: [150, 221, 181, 255] },
      { value: 1, color: [222, 245, 229, 255] }
    ]
  })
};
async function jc(r, e, t = {}) {
  var a, o;
  if (!e.sourceId && !e.data)
    throw new Error("Creating a polyline layer requires an existing .sourceId or a valid .data property");
  let n = e.data;
  if (typeof n == "string") {
    if (Qt(n))
      n = `https://api.maptiler.com/data/${e.data}/features.json?key=${j.apiKey}`;
    else if (((a = n.split(".").pop()) == null ? void 0 : a.toLowerCase().trim()) === "gpx") {
      const s = await (await fetch(n, t)).text();
      n = Zo(s);
    } else if (((o = n.split(".").pop()) == null ? void 0 : o.toLowerCase().trim()) === "kml") {
      const s = await (await fetch(n, t)).text();
      n = Ko(s);
    } else {
      const i = ji(n) ?? Oc(n);
      i && (n = i);
    }
    if (!n)
      throw new Error("Polyline data was provided as string but is incompatible with valid formats.");
  }
  return Dc(r, {
    ...e,
    data: n
  });
}
function Dc(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.sourceId ?? Mt(), n = e.layerId ?? Pt(), a = {
    polylineLayerId: n,
    polylineOutlineLayerId: "",
    polylineSourceId: t
  };
  e.data && !r.getSource(t) && r.addSource(t, {
    type: "geojson",
    data: e.data
  });
  const o = e.lineWidth ?? 3, i = e.lineColor ?? yr(), s = e.lineOpacity ?? 1, l = e.lineBlur ?? 0, u = e.lineGapWidth ?? 0;
  let c = e.lineDashArray ?? null;
  const p = e.outlineWidth ?? 1, d = e.outlineColor ?? "#FFFFFF", f = e.outlineOpacity ?? 1, h = e.outlineBlur ?? 0;
  if (typeof c == "string" && (c = Mn(c)), e.outline === !0) {
    const m = `${n}_outline`;
    a.polylineOutlineLayerId = m, r.addLayer(
      {
        id: m,
        type: "line",
        source: t,
        layout: {
          "line-join": e.lineJoin ?? "round",
          "line-cap": e.lineCap ?? "round"
        },
        minzoom: e.minzoom ?? 0,
        maxzoom: e.maxzoom ?? 23,
        paint: {
          "line-opacity": typeof f == "number" ? f : O(f),
          "line-color": typeof d == "string" ? d : Oe(d),
          "line-width": ei(o, p),
          "line-blur": typeof h == "number" ? h : O(h)
        }
      },
      e.beforeId
    );
  }
  return r.addLayer(
    {
      id: n,
      type: "line",
      source: t,
      layout: {
        "line-join": e.lineJoin ?? "round",
        "line-cap": e.lineCap ?? "round"
      },
      minzoom: e.minzoom ?? 0,
      maxzoom: e.maxzoom ?? 23,
      paint: {
        "line-opacity": typeof s == "number" ? s : O(s),
        "line-color": typeof i == "string" ? i : Oe(i),
        "line-width": typeof o == "number" ? o : O(o),
        "line-blur": typeof l == "number" ? l : O(l),
        "line-gap-width": typeof u == "number" ? u : O(u),
        // For some reasons passing "line-dasharray" with the value "undefined"
        // results in no showing the line while it should have the same behavior
        // of not adding the property "line-dasharray" as all.
        // As a workaround, we are inlining the addition of the prop with a conditional
        // which is less readable.
        ...c && { "line-dasharray": c }
      }
    },
    e.beforeId
  ), a;
}
function Uc(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.sourceId ?? Mt(), n = e.layerId ?? Pt(), a = {
    polygonLayerId: n,
    polygonOutlineLayerId: e.outline ? `${n}_outline` : "",
    polygonSourceId: t
  };
  if (e.data && !r.getSource(t)) {
    let m = e.data;
    typeof m == "string" && Qt(m) && (m = `https://api.maptiler.com/data/${m}/features.json?key=${j.apiKey}`), r.addSource(t, {
      type: "geojson",
      data: m
    });
  }
  let o = e.outlineDashArray ?? null;
  const i = e.outlineWidth ?? 1, s = e.outlineColor ?? "#FFFFFF", l = e.outlineOpacity ?? 1, u = e.outlineBlur ?? 0, c = e.fillColor ?? yr(), p = e.fillOpacity ?? 1, d = e.outlinePosition ?? "center", f = e.pattern ?? null;
  typeof o == "string" && (o = Mn(o));
  const h = (m = null) => {
    if (r.addLayer(
      {
        id: n,
        type: "fill",
        source: t,
        minzoom: e.minzoom ?? 0,
        maxzoom: e.maxzoom ?? 23,
        paint: {
          "fill-color": typeof c == "string" ? c : Oe(c),
          "fill-opacity": typeof p == "number" ? p : O(p),
          // Adding a pattern if provided
          ...m && { "fill-pattern": m }
        }
      },
      e.beforeId
    ), e.outline === !0) {
      let y;
      d === "inside" ? typeof i == "number" ? y = 0.5 * i : y = O(
        i.map(({ zoom: b, value: v }) => ({
          zoom: b,
          value: 0.5 * v
        }))
      ) : d === "outside" ? typeof i == "number" ? y = -0.5 * i : y = O(
        i.map((b) => ({
          zoom: b.zoom,
          value: -0.5 * b.value
        }))
      ) : y = 0, r.addLayer(
        {
          id: a.polygonOutlineLayerId,
          type: "line",
          source: t,
          layout: {
            "line-join": e.outlineJoin ?? "round",
            "line-cap": e.outlineCap ?? "butt"
          },
          minzoom: e.minzoom ?? 0,
          maxzoom: e.maxzoom ?? 23,
          paint: {
            "line-opacity": typeof l == "number" ? l : O(l),
            "line-color": typeof s == "string" ? s : Oe(s),
            "line-width": typeof i == "number" ? i : O(i),
            "line-blur": typeof u == "number" ? u : O(u),
            "line-offset": y,
            // For some reasons passing "line-dasharray" with the value "undefined"
            // results in no showing the line while it should have the same behavior
            // of not adding the property "line-dasharray" as all.
            // As a workaround, we are inlining the addition of the prop with a conditional
            // which is less readable.
            ...o && {
              "line-dasharray": o
            }
          }
        },
        e.beforeId
      );
    }
  };
  return f ? r.hasImage(f) ? h(f) : r.loadImage(f).then((m) => {
    r.addImage(f, m.data), h(f);
  }).catch((m) => {
    console.error("Could not load the pattern image.", m.message), h();
  }) : h(), a;
}
function Bc(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.minPointRadius ?? 10, n = e.maxPointRadius ?? 50, a = e.cluster ?? !1, o = 20, i = Array.isArray(e.pointColor) ? e.pointColor : ai.TURBO.scale(10, e.cluster ? 1e4 : 1e3).resample("ease-out-square"), s = i.getBounds(), l = e.sourceId ?? Mt(), u = e.layerId ?? Pt(), c = e.showLabel ?? a, p = e.alignOnViewport ?? !0, d = e.outline ?? !1, f = e.outlineOpacity ?? 1, h = e.outlineWidth ?? 1, m = e.outlineColor ?? "#FFFFFF";
  let y;
  const b = e.zoomCompensation ?? !0, v = e.minzoom ?? 0, x = e.maxzoom ?? 23;
  typeof e.pointOpacity == "number" ? y = e.pointOpacity : Array.isArray(e.pointOpacity) ? y = O(e.pointOpacity) : e.cluster ? y = nn(i, "point_count") : e.property ? y = nn(i, e.property) : y = O([
    { zoom: v, value: 0 },
    { zoom: v + 0.25, value: 1 },
    { zoom: x - 0.25, value: 1 },
    { zoom: x, value: 0 }
  ]);
  const E = {
    pointLayerId: u,
    clusterLayerId: "",
    labelLayerId: "",
    pointSourceId: l
  };
  if (e.data && !r.getSource(l)) {
    let C = e.data;
    typeof C == "string" && Qt(C) && (C = `https://api.maptiler.com/data/${C}/features.json?key=${j.apiKey}`), r.addSource(l, {
      type: "geojson",
      data: C,
      cluster: a
    });
  }
  if (a) {
    E.clusterLayerId = `${u}_cluster`;
    const C = Array.from({ length: o }, (T, N) => {
      const ge = s.min + N * (s.max - s.min) / (o - 1);
      return {
        value: ge,
        pointRadius: t + (n - t) * (N / (o - 1)) ** 0.5,
        color: i.getColorHex(ge)
      };
    });
    r.addLayer(
      {
        id: E.clusterLayerId,
        type: "circle",
        source: l,
        filter: ["has", "point_count"],
        paint: {
          // 'circle-color': options.pointColor ?? colorDrivenByProperty(clusterStyle, "point_count"),
          "circle-color": typeof e.pointColor == "string" ? e.pointColor : tn(C, "point_count"),
          "circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : rn(C, "point_count", !1),
          "circle-pitch-alignment": p ? "viewport" : "map",
          "circle-pitch-scale": "map",
          // scale with camera distance regardless of viewport/biewport alignement
          "circle-opacity": y,
          ...d && {
            "circle-stroke-opacity": typeof f == "number" ? f : O(f),
            "circle-stroke-width": typeof h == "number" ? h : O(h),
            "circle-stroke-color": typeof m == "string" ? m : Oe(m)
          }
        },
        minzoom: v,
        maxzoom: x
      },
      e.beforeId
    ), r.addLayer(
      {
        id: E.pointLayerId,
        type: "circle",
        source: l,
        filter: ["!", ["has", "point_count"]],
        paint: {
          "circle-pitch-alignment": p ? "viewport" : "map",
          "circle-pitch-scale": "map",
          // scale with camera distance regardless of viewport/biewport alignement
          // 'circle-color':  options.pointColor ?? clusterStyle[0].color,
          "circle-color": typeof e.pointColor == "string" ? e.pointColor : i.getColorHex(i.getBounds().min),
          "circle-radius": typeof e.pointRadius == "number" ? e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : C[0].pointRadius * 0.75,
          "circle-opacity": y,
          ...d && {
            "circle-stroke-opacity": typeof f == "number" ? f : O(f),
            "circle-stroke-width": typeof h == "number" ? h : O(h),
            "circle-stroke-color": typeof m == "string" ? m : Oe(m)
          }
        },
        minzoom: v,
        maxzoom: x
      },
      e.beforeId
    );
  } else {
    let C = typeof e.pointColor == "string" ? e.pointColor : Array.isArray(e.pointColor) ? e.pointColor.getColorHex(e.pointColor.getBounds().min) : yr(), T = typeof e.pointRadius == "number" ? b ? O([
      { zoom: 0, value: e.pointRadius * 0.025 },
      { zoom: 2, value: e.pointRadius * 0.05 },
      { zoom: 4, value: e.pointRadius * 0.1 },
      { zoom: 8, value: e.pointRadius * 0.25 },
      { zoom: 16, value: e.pointRadius * 1 }
    ]) : e.pointRadius : Array.isArray(e.pointRadius) ? O(e.pointRadius) : b ? O([
      { zoom: 0, value: t * 0.05 },
      { zoom: 2, value: t * 0.1 },
      { zoom: 4, value: t * 0.2 },
      { zoom: 8, value: t * 0.5 },
      { zoom: 16, value: t * 1 }
    ]) : t;
    if (e.property && Array.isArray(e.pointColor)) {
      const N = Array.from({ length: o }, (ge, Xe) => {
        const Ye = s.min + Xe * (s.max - s.min) / (o - 1);
        return {
          value: Ye,
          pointRadius: typeof e.pointRadius == "number" ? e.pointRadius : t + (n - t) * (Xe / (o - 1)) ** 0.5,
          color: typeof e.pointColor == "string" ? e.pointColor : i.getColorHex(Ye)
        };
      });
      C = tn(N, e.property), T = rn(N, e.property, b);
    }
    r.addLayer(
      {
        id: E.pointLayerId,
        type: "circle",
        source: l,
        layout: {
          // Contrary to labels, we want to see the small one in front. Weirdly "circle-sort-key" works in the opposite direction as "symbol-sort-key".
          "circle-sort-key": e.property ? ["/", 1, ["get", e.property]] : 0
        },
        paint: {
          "circle-pitch-alignment": p ? "viewport" : "map",
          "circle-pitch-scale": "map",
          // scale with camera distance regardless of viewport/biewport alignement
          "circle-color": C,
          "circle-opacity": y,
          "circle-radius": T,
          ...d && {
            "circle-stroke-opacity": typeof f == "number" ? f : O(f),
            "circle-stroke-width": typeof h == "number" ? h : O(h),
            "circle-stroke-color": typeof m == "string" ? m : Oe(m)
          }
        },
        minzoom: v,
        maxzoom: x
      },
      e.beforeId
    );
  }
  if (c !== !1 && (e.cluster || e.property)) {
    E.labelLayerId = `${u}_label`;
    const C = e.labelColor ?? "#fff", T = e.labelSize ?? 12;
    r.addLayer(
      {
        id: E.labelLayerId,
        type: "symbol",
        source: l,
        filter: ["has", e.cluster ? "point_count" : e.property],
        layout: {
          "text-field": e.cluster ? "{point_count_abbreviated}" : `{${e.property}}`,
          "text-font": ["Noto Sans Regular"],
          "text-size": T,
          "text-pitch-alignment": p ? "viewport" : "map",
          "symbol-sort-key": ["/", 1, ["get", e.cluster ? "point_count" : e.property]]
          // so that the largest value goes on top
        },
        paint: {
          "text-color": C,
          "text-opacity": y
        },
        minzoom: v,
        maxzoom: x
      },
      e.beforeId
    );
  }
  return E;
}
function qc(r, e) {
  if (e.layerId && r.getLayer(e.layerId))
    throw new Error(`A layer already exists with the layer id: ${e.layerId}`);
  const t = e.sourceId ?? Mt(), n = e.layerId ?? Pt(), a = e.minzoom ?? 0, o = e.maxzoom ?? 23, i = e.zoomCompensation ?? !0, s = e.opacity ?? [
    { zoom: a, value: 0 },
    { zoom: a + 0.25, value: 1 },
    { zoom: o - 0.25, value: 1 },
    { zoom: o, value: 0 }
  ];
  let l = Array.isArray(e.colorRamp) ? e.colorRamp : ai.TURBO.transparentStart();
  const u = l.getBounds();
  (u.min !== 0 || u.max !== 1) && (l = l.scale(0, 1)), l.hasTransparentStart() || (l = l.transparentStart());
  const c = e.intensity ?? [
    { zoom: 0, value: 0.01 },
    { zoom: 4, value: 0.2 },
    { zoom: 16, value: 1 }
  ], p = e.property ?? null, d = e.weight ?? 1;
  let f = 1;
  p ? typeof d == "number" ? (f = d, typeof e.weight == "number" && console.warn("The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`")) : Array.isArray(d) ? f = ti(d, p) : console.warn("The option `.property` is ignored when `.propertyValueWeights` is not of type `PropertyValueWeights`") : typeof d == "number" ? f = d : Array.isArray(d) && console.warn("The options `.propertyValueWeights` can only be used when `.property` is provided.");
  const h = [
    { zoom: 0, value: 50 * 0.025 },
    { zoom: 2, value: 50 * 0.05 },
    { zoom: 4, value: 50 * 0.1 },
    { zoom: 8, value: 50 * 0.25 },
    { zoom: 16, value: 50 }
  ], m = e.radius ?? (i ? h : 10);
  let y = 1;
  typeof m == "number" ? y = m : Array.isArray(m) && "zoom" in m[0] ? y = O(m) : p && Array.isArray(m) && "propertyValue" in m[0] ? y = ri(m, p, i) : !p && Array.isArray(m) && "propertyValue" in m[0] ? (y = O(h), console.warn("The option `.radius` can only be property-driven if the option `.property` is provided.")) : y = O(h);
  const b = {
    heatmapLayerId: n,
    heatmapSourceId: t
  };
  if (e.data && !r.getSource(t)) {
    let v = e.data;
    typeof v == "string" && Qt(v) && (v = `https://api.maptiler.com/data/${v}/features.json?key=${j.apiKey}`), r.addSource(t, {
      type: "geojson",
      data: v
    });
  }
  return r.addLayer(
    {
      id: n,
      type: "heatmap",
      source: t,
      minzoom: a,
      maxzoom: o,
      paint: {
        "heatmap-weight": f,
        "heatmap-intensity": typeof c == "number" ? c : O(c),
        "heatmap-color": ni(l),
        "heatmap-radius": y,
        "heatmap-opacity": typeof s == "number" ? s : O(s)
      }
    },
    e.beforeId
  ), b;
}
const bp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  addHeatmap: qc,
  addPoint: Bc,
  addPolygon: Uc,
  addPolyline: jc,
  colorDrivenByProperty: tn,
  colorPalettes: Qr,
  computeRampedOutlineWidth: ei,
  dashArrayMaker: Mn,
  generateRandomLayerName: Pt,
  generateRandomSourceName: Mt,
  getRandomColor: yr,
  heatmapIntensityFromColorRamp: ni,
  lerpZoomNumberValues: en,
  opacityDrivenByProperty: nn,
  paintColorOptionsToPaintSpec: Oe,
  radiusDrivenByProperty: rn,
  radiusDrivenByPropertyHeatmap: ri,
  rampedOptionsToLayerPaintSpec: O,
  rampedPropertyValueWeight: ti,
  takeScreenshot: Fc
}, Symbol.toStringTag, { value: "Module" }));
function oi() {
  return "3.10.2";
}
const wp = k.Map, Sp = k.Marker, xp = k.Popup, kp = k.Style, Lp = k.CanvasSource, Cp = k.GeoJSONSource, Ep = k.ImageSource, Ap = k.RasterTileSource, Tp = k.RasterDEMTileSource, _p = k.VectorTileSource, Ip = k.VideoSource, Mp = k.NavigationControl, Pp = k.GeolocateControl, Rp = k.AttributionControl, zp = k.LogoControl, Op = k.ScaleControl, Fp = k.FullscreenControl, $p = k.TerrainControl, Np = k.BoxZoomHandler, jp = k.ScrollZoomHandler, Dp = k.CooperativeGesturesHandler, Up = k.KeyboardHandler, Bp = k.TwoFingersTouchPitchHandler, qp = k.MapWheelEvent, Vp = k.MapTouchEvent, Gp = k.MapMouseEvent, Hp = k.config, Zp = k.getVersion, {
  setRTLTextPlugin: Kp,
  getRTLTextPluginStatus: Xp,
  LngLat: ii,
  LngLatBounds: Vc,
  MercatorCoordinate: an,
  Evented: Yp,
  AJAXError: Wp,
  prewarm: Jp,
  clearPrewarmedResources: Qp,
  Hash: ef,
  Point: si,
  EdgeInsets: tf,
  DragRotateHandler: rf,
  DragPanHandler: nf,
  TwoFingersTouchZoomRotateHandler: af,
  DoubleClickZoomHandler: of,
  TwoFingersTouchZoomHandler: sf,
  TwoFingersTouchRotateHandler: lf,
  getWorkerCount: uf,
  setWorkerCount: cf,
  getMaxParallelImageRequests: pf,
  setMaxParallelImageRequests: ff,
  getWorkerUrl: df,
  setWorkerUrl: hf,
  addSourceType: mf,
  importScriptInWorkers: yf,
  addProtocol: gf,
  removeProtocol: vf
} = k;
export {
  Wp as AJAXError,
  sp as AttributionControl,
  Rp as AttributionControlMLGL,
  up as BoxZoomHandler,
  Np as BoxZoomHandlerMLGL,
  ep as CanvasSource,
  Lp as CanvasSourceMLGL,
  A as ColorRamp,
  ai as ColorRampCollection,
  pp as CooperativeGesturesHandler,
  Dp as CooperativeGesturesHandlerMLGL,
  Ne as CubemapFaceNames,
  Bu as CubemapImagesPresets,
  Or as CubemapLayer,
  Ce as DOMcreate,
  Lt as DOMremove,
  of as DoubleClickZoomHandler,
  nf as DragPanHandler,
  rf as DragRotateHandler,
  tf as EdgeInsets,
  Yp as Evented,
  _i as FullscreenControl,
  Fp as FullscreenControlMLGL,
  tp as GeoJSONSource,
  Cp as GeoJSONSourceMLGL,
  Ei as GeolocateControl,
  Pp as GeolocateControlMLGL,
  ac as GeolocationType,
  ef as Hash,
  rp as ImageSource,
  Ep as ImageSourceMLGL,
  wc as ImageViewer,
  ne as ImageViewerEvent,
  vp as ImageViewerMarker,
  Ec as ImageViewerMarkerEvent,
  fp as KeyboardHandler,
  Up as KeyboardHandlerMLGL,
  z as Language,
  ii as LngLat,
  Vc as LngLatBounds,
  Ai as LogoControl,
  zp as LogoControlMLGL,
  Po as Map,
  wp as MapMLGL,
  yp as MapMouseEvent,
  Gp as MapMouseEventMLGL,
  Sf as MapStyle,
  xf as MapStyleVariant,
  mp as MapTouchEvent,
  Vp as MapTouchEventMLGL,
  hp as MapWheelEvent,
  qp as MapWheelEventMLGL,
  hu as MaptilerCustomControl,
  Kr as MaptilerExternalControl,
  du as MaptilerGeolocateControl,
  $n as MaptilerLogoControl,
  pu as MaptilerNavigationControl,
  mu as MaptilerProjectionControl,
  cu as MaptilerTerrainControl,
  Ci as Marker,
  Sp as MarkerMLGL,
  an as MercatorCoordinate,
  Mp as NavigationControMLGL,
  Na as NavigationControl,
  si as Point,
  Jc as Popup,
  xp as PopupMLGL,
  Fr as RadialGradientLayer,
  ap as RasterDEMTileSource,
  Tp as RasterDEMTileSourceMLGL,
  np as RasterTileSource,
  Ap as RasterTileSourceMLGL,
  kf as ReferenceMapStyle,
  Ti as ScaleControl,
  Op as ScaleControlMLGL,
  cp as ScrollZoomHandler,
  jp as ScrollZoomHandlerMLGL,
  Ii as SdkConfig,
  Lf as ServiceError,
  Qc as Style,
  kp as StyleMLGL,
  $p as TerrainControMLGL,
  lp as TerrainControl,
  dp as TwoFingersTouchPitchHandler,
  Bp as TwoFingersTouchPitchHandlerMLGL,
  lf as TwoFingersTouchRotateHandler,
  sf as TwoFingersTouchZoomHandler,
  af as TwoFingersTouchZoomRotateHandler,
  op as VectorTileSource,
  _p as VectorTileSourceMLGL,
  ip as VideoSource,
  Ip as VideoSourceMLGL,
  gf as addProtocol,
  mf as addSourceType,
  Cf as areSameLanguages,
  Ef as bufferToPixelDataBrowser,
  Af as canParsePixelData,
  Tf as circumferenceAtLatitude,
  Qp as clearPrewarmedResources,
  j as config,
  Hp as configMLGL,
  _f as coordinates,
  Ge as cubemapPresets,
  If as data,
  gp as displayWebGLContextLostWarning,
  Mf as elevation,
  Pf as expandMapStyle,
  Rf as geocoding,
  zf as geolocation,
  Of as getAutoLanguage,
  Fn as getBrowserLanguage,
  Ff as getBufferToPixelDataParser,
  $f as getLanguageInfoFromCode,
  Nf as getLanguageInfoFromFlag,
  jf as getLanguageInfoFromKey,
  Zp as getMapLibreVersion,
  pf as getMaxParallelImageRequests,
  Xp as getRTLTextPluginStatus,
  Df as getTileCache,
  oi as getVersion,
  Di as getWebGLSupportError,
  uf as getWorkerCount,
  df as getWorkerUrl,
  Zo as gpx,
  Oc as gpxOrKml,
  Ho as hasChildNodeWithName,
  bp as helpers,
  yf as importScriptInWorkers,
  Uf as isLanguageInfo,
  Ko as kml,
  Bf as mapStylePresetList,
  qf as math,
  Vf as misc,
  Jp as prewarm,
  vf as removeProtocol,
  ff as setMaxParallelImageRequests,
  Kp as setRTLTextPlugin,
  cf as setWorkerCount,
  hf as setWorkerUrl,
  Gf as staticMaps,
  _n as str2xml,
  Hf as styleToStyle,
  Zf as toLanguageInfo,
  Ao as toggleProjection,
  Eo as toggleTerrain,
  Ia as xml2str
};
//# sourceMappingURL=maptiler-sdk.mjs.map
